<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>拿鐵派的馬克 Blog</title>
    <link>https://mark-lin.com/</link>
    <description>Recent content on 拿鐵派的馬克 Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <managingEditor>h091237557@gmail.com (marklin)</managingEditor>
    <webMaster>h091237557@gmail.com (marklin)</webMaster>
    <lastBuildDate>Mon, 30 Sep 2019 20:16:57 +0800</lastBuildDate>
    
        <atom:link href="https://mark-lin.com/index.xml" rel="self" type="application/rss+xml" />
    

    
    <item>
      <title>30-30 之馬克版的一個好的系統攻略本 - 性能基礎篇</title>
      <link>https://mark-lin.com/posts/20190930/</link>
      <pubDate>Mon, 30 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190930/</guid>
      <description>這漫長辛苦的 30 天總於結束囉 ~ 接下來依慣例第 30 天都是總結篇。 這 30 天的過程咱們都在追求『 一個好的系統 』中的其中一個重點 : 性能 性能越高的系統，可以帶給『 公司 』與『 用戶 』雙方都達到愉悅的情況。 咱們先看看第一階</description>
    </item>
    
    <item>
      <title>30-29 之資料庫層擴展中間件 - MyCAT 的淺淺談</title>
      <link>https://mark-lin.com/posts/20190929/</link>
      <pubDate>Sun, 29 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190929/</guid>
      <description>正文開始 前面幾篇文章中，咱們提到了如何擴展資料庫層級服務，讓它可以接更多的客，但是這些擴展方法中，都有提到一個『 中間件 』來使用，接下後本篇文章中，咱們將介紹其中一種比較常見的中間件 : MyCAT 本篇文章分為以下</description>
    </item>
    
    <item>
      <title>30-28 之資料庫層擴展難題 -  MySQL 分散式事務處理</title>
      <link>https://mark-lin.com/posts/20190928/</link>
      <pubDate>Sat, 28 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190928/</guid>
      <description>正文開始 本篇文章中，咱們要來說說分散式系統中，最麻煩的部份『 分散式事務 』這一塊，接下來咱們來認真的理一下這個鬼。 本篇分為以下幾個章節 : 分散式事務難題 分散式事務的處理方案 : 2 PC 二階段提交（ Two-phase Commit ） MySQL XA 事務</description>
    </item>
    
    <item>
      <title>30-27之資料庫層的擴展 - 分區表</title>
      <link>https://mark-lin.com/posts/20190927/</link>
      <pubDate>Fri, 27 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190927/</guid>
      <description>正文開始 上一篇文章中，咱們有提到了兩種資料庫層的擴展方式 : 分庫 分表 其中分表是用來解決單表太大的問題，而接下來本章節要來介紹另一種處理單表太的工具 : 分區表 本篇文章分以下幾個章節 : 分區概念 MySQL 分區的切分類型</description>
    </item>
    
    <item>
      <title>30-26之資料庫層的擴展 - 分庫分表架構</title>
      <link>https://mark-lin.com/posts/20190926/</link>
      <pubDate>Thu, 26 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190926/</guid>
      <description>正文開始 上一篇文章中，咱們介紹了資料庫層的分散的第一個起手式『 讀寫分離 』，這個方案是將寫與讀分散在不同的機器上，正常情況下，大部份的系統使用這種方案就已經可以處理很好了。 但 ! 如果你已經將資料庫層與緩存</description>
    </item>
    
    <item>
      <title>30-25之資料庫層的擴展 - 讀寫分離架構</title>
      <link>https://mark-lin.com/posts/20190925/</link>
      <pubDate>Wed, 25 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190925/</guid>
      <description>正文開始 前面的文章我們說明完應用層的分散式架構以後，接下來我們要來思考如果讓『 資料庫層 』做更多的事情。 在正式開始章節之前，我們先來想想看一件事情。 資料庫層可以向應用層一樣加機器，就可以做更多的事情嗎 ?</description>
    </item>
    
    <item>
      <title>30-24 之應用層擴展『 外傳 』 - IM 服務擴展與雷坑</title>
      <link>https://mark-lin.com/posts/20190924/</link>
      <pubDate>Tue, 24 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190924/</guid>
      <description>正文開始 上一篇文章中，咱們理解了一般 web 系統的擴展方法後，接下來我們來一篇外傳，來說說關於 即時通訊服務 ( IM Instant Messaging Service ) 的擴展。 本篇文章共分以下幾個章節 : IM 服務的先行知識 IM 服務的擴展方案 1 - 負載均衡 IM 服務的擴</description>
    </item>
    
    <item>
      <title>30-23 之應用層的擴展 - 負載均衡服務</title>
      <link>https://mark-lin.com/posts/20190923/</link>
      <pubDate>Mon, 23 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190923/</guid>
      <description>正文開始 前面幾篇的文章中，我們知道如何儘可能的在單機上，可以以最少的資源做最多的事，但是單機一定有它的限制，因此接下來我們要開始正式進入所謂的『 分散式系統 』。 分散式系統不是簡單的增加機器就可以增加效能</description>
    </item>
    
    <item>
      <title>30-22 之網路傳輸的優化 - HTTP 1.0 至 HTTP 3.0</title>
      <link>https://mark-lin.com/posts/20190922/</link>
      <pubDate>Sun, 22 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190922/</guid>
      <description>正文開始 本篇文章中，網路世界最重的協議 http，不只如上圖應用所示只有用戶端那有用到，現階段大部份很多 server 都還是會實用 http 去其它 server 取資料，所以一個系統中，最重要的應用層協議，咱們幾乎可能說是『 Http 』。 本篇文</description>
    </item>
    
    <item>
      <title>30-21 之網路傳輸的加速 - CDN 與 HTTP 緩存</title>
      <link>https://mark-lin.com/posts/20190921/</link>
      <pubDate>Sat, 21 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190921/</guid>
      <description>正文開始 前幾篇文章中，咱們討論完資料庫層的資料緩存以後，接下來咱們要來談談另外兩個緩存 : CDN ( Content Delivery Network ) HTTP 緩存 本篇文章分為以下幾個章節 : CDN 與運行流程 HTTP 緩存與運行流程 CDN 與 HTTP 緩存搞在一起用 這裡先說一下，接下來</description>
    </item>
    
    <item>
      <title>30-20 之資料緩存失效問題</title>
      <link>https://mark-lin.com/posts/20190920/</link>
      <pubDate>Fri, 20 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190920/</guid>
      <description>正文開始 上一篇文章中咱們已經學習了一些緩存基本的策略，那接下來我們要來理解一下一個重要的主題 : 如果緩存失效的情況，與可能會發生什麼事情呢 ? 基本上緩存失效後的結果，會很慘，尤其是你當初建立緩存時，就是已</description>
    </item>
    
    <item>
      <title>30-19 之資料庫層的優化  - 資料緩存策略</title>
      <link>https://mark-lin.com/posts/20190919/</link>
      <pubDate>Thu, 19 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190919/</guid>
      <description>正文開始 上一篇咱們基本上已經理解緩存服務 redis 的基本概念後，接下來咱們要進入正題 : 緩存策略 相信不少人應該會覺得這很簡單，不就是將熱資料丟到緩存，然後用戶先優先去緩存取得，沒有則去資料庫拿去嗎 ? 用腦袋想很簡</description>
    </item>
    
    <item>
      <title>30-18 之資料緩存層的服務 - Redis 概念與一致性難題</title>
      <link>https://mark-lin.com/posts/20190918/</link>
      <pubDate>Wed, 18 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190918/</guid>
      <description>正文開始 前面幾篇文章咱們已經學習完了資料層性能相關的知識，而接下來這篇文章，咱們要來學習，如何進一步的讓系統可以做更多的事情。 資料庫單機性能優化到最後，仍然還是逃不過性能的貧頸，但這並不是說單機優化沒</description>
    </item>
    
    <item>
      <title>30-17 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 2 )</title>
      <link>https://mark-lin.com/posts/20190917/</link>
      <pubDate>Tue, 17 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190917/</guid>
      <description>正文開始 上一章節咱們學習到了，在並行情況下 mysql 可能會發生什麼樣的資料不一致問題，並且也學習到了這些問題它又是如何解決。 雖然 innodb 已經儘可能的解決上述這些問題，但是如果要完全解決，性能代價太大，因此後來有了一</description>
    </item>
    
    <item>
      <title>30-16 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 1 )</title>
      <link>https://mark-lin.com/posts/20190916/</link>
      <pubDate>Mon, 16 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190916/</guid>
      <description>正文開始 本篇文章中，咱們要說說另一種資料不一致性產生的場景，那就是 : 『 並行 』產生的不一致性難題 基本上並行所產生的不一致性難題，可以分為以下幾種類型 : 更新不一致 髒讀 不可重讀 幻讀 本篇將會分為以下幾個章節來</description>
    </item>
    
    <item>
      <title>30-15 之資料庫層的難題 - 單機『 故障 』一致性難題</title>
      <link>https://mark-lin.com/posts/20190915/</link>
      <pubDate>Sun, 15 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190915/</guid>
      <description>正文開始 前面幾篇文章中，咱們理解完了 mysql 的索引概念與原理，並且理解了在 mysql 中一個查詢的速度與否取決於索引與表的設計。接下來咱們要來理解一些會拖性能後腿的東西。 這個會性能後腿的東西就是 : 一致性難題 在追求高性</description>
    </item>
    
    <item>
      <title>30-14 之資料庫層的優化 - 表的設計</title>
      <link>https://mark-lin.com/posts/20190914/</link>
      <pubDate>Sat, 14 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190914/</guid>
      <description>正文開始 本篇文章中咱們將要從『 表 』的角度來儘可能的優化性能。 表設計的幾個小建議 正規與非正規的小戰爭 表設計的幾個小建議 這個章節會給一些建立表時的小建議，雖然這裡優化的點不多，但是每一個地方都做到好，才是</description>
    </item>
    
    <item>
      <title>30-13 之資料庫層的優化 - 索引設計與雷區</title>
      <link>https://mark-lin.com/posts/20190913/</link>
      <pubDate>Fri, 13 Sep 2019 20:12:39 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190913/</guid>
      <description>正文開始 前面兩篇文章中，咱們已經學習完索引的核心觀念以後，接下來咱們學學在使用時有那些的優質的方法與注意事項。 30-11 之資料庫層的核心 - 索引結構演化論 B+樹 30-12 之資料庫層的核心 - MySQL 的索引實現 本篇文章分為以下幾</description>
    </item>
    
    <item>
      <title>30-12 之資料庫層的核心 - MySQL 的索引實現</title>
      <link>https://mark-lin.com/posts/20190912/</link>
      <pubDate>Thu, 12 Sep 2019 20:11:06 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190912/</guid>
      <description>正文開始 上一篇文章中，我們理解了 innoDB 索引的基本原理 b+ 樹的，也理解了為什麼 innoDB 要選擇 b+ 樹的原因後，那接下來，我們要來理解，在 innoDB 中『 實際上 』是如何使用 b+ 樹來建立索引機制 ? 本篇文章分為以下幾個章節 : 一張乾淨的表</description>
    </item>
    
    <item>
      <title>30-11 之資料庫層的核心 - 索引結構演化論 B&#43;樹</title>
      <link>https://mark-lin.com/posts/20190911/</link>
      <pubDate>Wed, 11 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190911/</guid>
      <description>正文開始 接下來咱們要來理解資料庫系統中最核心的問題 : 要如何儲放資料，才能更快速的找到資料呢 ? 而這個東西的技術就是所謂的 : 索引 而在 mysql 中決定如何儲放的是資料庫儲存引擎來決定，而這裡咱們將要從 mysql 預設引擎 innodb 來</description>
    </item>
    
    <item>
      <title>30-10 之資料庫層架構與優化方向</title>
      <link>https://mark-lin.com/posts/20190910/</link>
      <pubDate>Tue, 10 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190910/</guid>
      <description>正文開始 前面幾篇文章中，咱們大致上學習完了應用層的一些性能優化的基本知識，接下來咱們要來學學資料庫層的高性能優化方向。 在這裡先說一下一個重點 : 資料庫絕對是一個系統的性能核心，請把優質的 DBA 們當寶來餵食 接</description>
    </item>
    
    <item>
      <title>30-09之應用層的兩個池 - 進 ( 線 ) 程池與連線池</title>
      <link>https://mark-lin.com/posts/20190909/</link>
      <pubDate>Mon, 09 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190909/</guid>
      <description>正文開始 接下來咱們要來談談，在應用層中很常提到的兩個池『線程池』與『連線池』，它們兩個在應用層扮演了性能方面什麼樣的角色。 本篇文章分為以下幾個章節 : 什麼是進程池 ? 為什麼需要它呢 ? 進程池的數量設置。 什麼</description>
    </item>
    
    <item>
      <title>30-08 之應用層的 I/O 優化 ( 維護性 ) - 協程 Coroutine</title>
      <link>https://mark-lin.com/posts/20190908/</link>
      <pubDate>Sun, 08 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190908/</guid>
      <description>正文開始 上一篇文章說明完了非阻塞 I/O 模式核心 reactor，並且它可以幫我們建立 : 異步非阻塞的 I/O 操作。 而接下這篇文章我們將要來說說 coroutine 協程這東西，協程這東西在 I/O 優化佔據什麼地位呢 ? 簡單的說它可以讓我們實現</description>
    </item>
    
    <item>
      <title>30-07 之應用層的 I/O 優化 - 非阻塞 I/O 模型 Reactor</title>
      <link>https://mark-lin.com/posts/20190907/</link>
      <pubDate>Sat, 07 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190907/</guid>
      <description>正文開始 接下來本篇文章，咱們要來說明所謂的『 I/O 』模型。 這個東西我當初看到也有點不太能理解，為什麼需要它，但後來理解以後發覺，你只要知道一個 http 請求 web server 是如何處理的，從 0 至 1，那這樣的話當你完全通了，就知</description>
    </item>
    
    <item>
      <title>30-06 之應用層的 I/O 優化 - Stream ( 與一些 IPC 知識 )</title>
      <link>https://mark-lin.com/posts/20190906/</link>
      <pubDate>Fri, 06 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190906/</guid>
      <description>正文開始 Stream 這個東東，基本上在每一個語言你都看的到，而今天我們將要深入的來理解它到底是什麼東西，並且它在一些 I/O 操作上可以幫助我們解決什麼事情。 本篇文章將分為以下幾個章節 Stream 是什麼 ? 可以解決什麼事情 ? Stream 在 IPC</description>
    </item>
    
    <item>
      <title>30-05 之應用層的 I/O 加速 - 零拷貝 ( Zero Copy )</title>
      <link>https://mark-lin.com/posts/20190905/</link>
      <pubDate>Thu, 05 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190905/</guid>
      <description>正文開始 前二篇文章中，咱們已經學習完運算方面的優化，而接下來幾篇文章，咱們要來說明 I/O 優化這個議題。 I/O 基本上可以分為兩種，『 文件 I/O 』與『 網路 I/O 』，這兩種 I/O 操作原理大同小議，但是優化方式卻有些不同，接下來</description>
    </item>
    
    <item>
      <title>30-04 之應用層的運算加速 - 並行運算</title>
      <link>https://mark-lin.com/posts/20190904/</link>
      <pubDate>Wed, 04 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190904/</guid>
      <description>正文開始 假設你已經將你的演算法進行了優化，但是這時發現，這一項演算法工作還是需要花到非常多的時間處理，那要怎麼辦呢 ? 假設你所在的機器是多核心 CPU，那這時的確是有解，那就是本篇文章的主題 : 開啟 Process 或 Thread 來</description>
    </item>
    
    <item>
      <title>30-03 之應用層的運算加速 - 演算法</title>
      <link>https://mark-lin.com/posts/20190903/</link>
      <pubDate>Tue, 03 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190903/</guid>
      <description>正文開始 本篇文章開始，我們將要深入的探討，每一個服務，要如何儘可能的達到高性能呢 ? 這首先第一部份，我們要探討以下主題 : 在應用層，要如何儘可能的使用越少的資源( CPU、Memory )，來做最多的事情呢 ?</description>
    </item>
    
    <item>
      <title>30-02 之單機架構的性能優化方向與目標</title>
      <link>https://mark-lin.com/posts/20190902/</link>
      <pubDate>Mon, 02 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190902/</guid>
      <description>接下來咱們會從最基本的開始 : 儘可能的優化單機性能 基本上不少高性能的書籍都是直接跳至分散式架構，但是如果一個開發者連單機都處理不好，我不太相信他開發出來的分散式架構是高性能的。 單機處理的好，才是高性能的</description>
    </item>
    
    <item>
      <title>30-01 之何謂一個好的系統呢  ?</title>
      <link>https://mark-lin.com/posts/20190901/</link>
      <pubDate>Sun, 01 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190901/</guid>
      <description>何謂一個好的系統呢 ? 為什麼會問這個問題呢 ? 因為事實上這個是我原本想要撰寫的主題。咱們工程師在開發系統，所學習的大部份的技術，基本上都是為了追求『建立一個好的系統』，然後我本來想將建立一個好的系統的知識</description>
    </item>
    
  </channel>
</rss>