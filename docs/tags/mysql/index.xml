<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mysql on 拿鐵派的馬克 Blog</title>
    <link>https://mark-lin.com/tags/mysql/</link>
    <description>Recent content in mysql on 拿鐵派的馬克 Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <managingEditor>h091237557@gmail.com (marklin)</managingEditor>
    <webMaster>h091237557@gmail.com (marklin)</webMaster>
    <lastBuildDate>Sun, 29 Sep 2019 20:16:57 +0800</lastBuildDate>
    
        <atom:link href="https://mark-lin.com/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>30-29 之資料庫層擴展中間件 - MyCAT 的淺淺談</title>
      <link>https://mark-lin.com/posts/20190929/</link>
      <pubDate>Sun, 29 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190929/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191014/20089358vvYv5IdCqA.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;前面幾篇文章中，咱們提到了如何擴展資料庫層級服務，讓它可以接更多的客，但是這些擴展方法中，都有提到一個『 中間件 』來使用，接下後本篇文章中，咱們將介紹其中一種比較常見的中間件 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MyCAT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章分為以下幾個章節 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MyCAT 基本概念&lt;/li&gt;
&lt;li&gt;MyCAT 的各種架構實現配置&lt;/li&gt;
&lt;li&gt;使用 Docker 來實現 MyCAT 讀寫分離&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mycat-&#34;&gt;MyCAT 基本概念&lt;/h2&gt;
&lt;p&gt;在資料庫中間件中，事實上分為兩種類型 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;proxy&lt;/li&gt;
&lt;li&gt;smart-client&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它們兩個的基本差別如下圖 1 所示，proxy 是一個外部的服務，所有的應用都會透過這個 proxy 服務來操作資料庫。&lt;/p&gt;
&lt;p&gt;而 smart-client 概念就是包在應用層中，當成一個 sdk 概念的程式碼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191014/20089358Ud8qBybBEg.png&#34; alt=&#34;&#34;&gt;
圖 1 : proxy vs smart-client&lt;/p&gt;
&lt;p&gt;而其中 mycat 就是屬於 proxy 的其中一種應用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;現在幾個比較可以說的出名字的中間件有 :&lt;/p&gt;
&lt;p&gt;proxy : cobar、mycat、mysql-router、atlas、vitess
smart-client : 大部份語言有實現簡單版的，而如果是支援比較多功能的有 sharding-jdbc、tddl。&lt;/p&gt;
&lt;p&gt;有興趣的友人可以自已查查來比較看看。&lt;/p&gt;
&lt;h4 id=&#34;-&#34;&gt;這裡問一下，那一種比較好呢 ?&lt;/h4&gt;
&lt;p&gt;首先咱們先說說 smart-client 的優點 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;實現簡單 : 大部份的語言都有相對應簡單的實現套件，例如大部份 orm 套都只要設定好 master 與 slave 然後開啟讀寫分離，就會自動的處理 ( ex. django orm、laravel eloquent model )。&lt;/li&gt;
&lt;li&gt;沒有服務壞掉風險 : proxy 是一個服務，所以你需要考慮到它是否有高可用，而 smart-client 則否，它只是個 sdk。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Smart-client 缺點 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較深入的功能需自已實現 : 例如分散式事務、負載平衡這些，大部份的套件都沒有，真想要只能自已在這些套件上，在封裝一個層級來自已實現。&lt;/li&gt;
&lt;li&gt;版本問題 : 有可能不同服務上，有不同的版本，這也代表如果一個版本有 bug，那就所有的應用都要升級，當服務多時，你要如何確保所有服務都有升級呢 ?&lt;/li&gt;
&lt;li&gt;語言問題 : 只有與中間件 sdk 同語言的才能使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;總結來說，如果你的資料庫層級只到了『 讀寫分離 』的情境，那建議是只要使用 smart-client 模式，而是是直接使用各語言有提供的套件就好，而如果到了『 分庫分表 』而且公司內有很多人會使用，那就真的要考慮 proxy 了。&lt;/p&gt;
&lt;h3 id=&#34;mycat-1&#34;&gt;MyCat 特性&lt;/h3&gt;
&lt;p&gt;mycat 是一個由阿里開發的 cobar 演變來的資料庫的中間件服務，它是屬於『 proxy 類型 』，它基本上有以下的特點 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持讀寫分離、分庫分表。&lt;/li&gt;
&lt;li&gt;NIO 的實現。&lt;/li&gt;
&lt;li&gt;支持分散式事務 ( XA 協議的協調者 )&lt;/li&gt;
&lt;li&gt;支持跨庫 join，但是限兩表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先第一點 mycat 支持讀寫分離、分庫分表，寫讓咱們應用端一樣照常的寫一樣 sql，然後內部會自動幫處理這些事情。&lt;/p&gt;
&lt;p&gt;第二點 mycat 他本身是 nio 也就所謂的 non-blocking i/o 機制，就是咱們下面這篇文章中所提到的 reactor 模式，這也代表太可以處理大量的請求。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20190907/&#34;&gt;30-07 之應用層的 I/O 優化 - 非阻塞 I/O 模型 Reactor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三點支持分散式事務，也就是咱們應用端一樣像往常一樣使用事務，而 mycat 就會自動幫咱們變成分散式事務。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20190928/&#34;&gt;30-28 之資料庫層擴展難題 - MySQL 分散式事務處理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第四點跟庫 join，這可以讓咱們應用端寫 join 和平常一樣，但是注意，它只限兩表。&lt;/p&gt;
&lt;h2 id=&#34;mycat-2&#34;&gt;MyCAT 的各種架構實現配置&lt;/h2&gt;
&lt;h3 id=&#34;heading1&#34;&gt;基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;這個部份定義了 mycat 的邏輯資料庫，像咱們下 sql 時有時後需要補一個 use xxxdb 的這種語句時，以下範例來看，咱們下的就是 use masterdb 這樣。&lt;/li&gt;
&lt;li&gt;定義 mycat 的邏輯資料節點，它會使用連到對應對 dataHost 與 database。&lt;/li&gt;
&lt;li&gt;定義 mycat 的邏輯 host，並且也定義好這個 host 的模式，例如是不是負載均衡等。&lt;/li&gt;
&lt;li&gt;定義實際使用的資料庫位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中 dataHost 有些參數注意一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maxCon : 代表最大連線量，某些方面這個可以說是一個連線池。&lt;/li&gt;
&lt;li&gt;balance : 負載均衡的類型&lt;/li&gt;
&lt;li&gt;0 : 不開啟讀寫分離，就都寫到 writeHost。&lt;/li&gt;
&lt;li&gt;1 : 雙主重模式用，這個有點複雜。&lt;/li&gt;
&lt;li&gt;2 : 所有讀操作，都隨機分配在 writeHost 與 readHost。&lt;/li&gt;
&lt;li&gt;3 : 所有讀操作，都送到 read，writeHost 只處理寫操作。&lt;/li&gt;
&lt;li&gt;writeType : 寫的負載均衡類型&lt;/li&gt;
&lt;li&gt;0 : 所有寫操作都送到第一台 writeHost，當它掛了，會自動切換為第二台。&lt;/li&gt;
&lt;li&gt;1 : 所有寫操作隨機送到某台 writeHost。&lt;/li&gt;
&lt;li&gt;2 : 不執行寫的操作。&lt;/li&gt;
&lt;li&gt;switchType : 主從切換模式，但是有點看不太懂它的類型&lt;/li&gt;
&lt;li&gt;slaveThreshold : 主從延遲 hreshold，也就是說主從的延遲超過這個時間，這此從庫不會參於這次分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE mycat:schema SYSTEM &amp;#34;schema.dtd&amp;#34;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;mycat:schema&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns:mycat=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://io.mycat/&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;

	&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; 1. 定義 mycat 邏輯資料庫 &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;schema&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;masterdb&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkSQLschema=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sqlMaxLimit=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dataNode=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;db1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;

	&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; 2. 定義 mycat 邏輯資料操作節點 &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; 不過比較特別的是 database 它是指實際要連到的預設資料庫 &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dataNode&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;db1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dataHost=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xxx-db&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;database=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;test&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;

	&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; 3. 定義 mycat 邏輯 host   &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dataHost&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;xxx-db&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxCon=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1000&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minCon=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;10&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;balance=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;
			  &lt;span style=&#34;color:#a6e22e&#34;&gt;writeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dbType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mysql&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dbDriver=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;native&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;switchType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;slaveThreshold=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;heartbeat&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;select user()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/heartbeat&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; 4. 定義實際使用資料庫位置 &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;writeHost&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;host=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;m1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;url=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;192.168.0.10:3306&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;user=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/writeHost&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dataHost&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/mycat:schema&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這裡簡單畫一下配置的關係圖，如下圖 2 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191014/20089358sPVF5WeBJR.png&#34; alt=&#34;&#34;&gt;
圖 2 : mycat 配置圖關係&lt;/p&gt;
&lt;h3 id=&#34;mycat-3&#34;&gt;MyCAT 讀寫分離實現&lt;/h3&gt;
&lt;p&gt;下面為讀寫分離的配置，差別在於 dataHost 的的設定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;balance 改為 3 : 代表所有讀的操作，會送到 wrtie 裡面的 read 機讀取。&lt;/li&gt;
&lt;li&gt;增加 readHost 配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;當要使用時，你可以下以下的 sql 來取得資料。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE mycat:schema SYSTEM &amp;#34;schema.dtd&amp;#34;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;mycat:schema&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns:mycat=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://io.mycat/&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;

	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;schema&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;db&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkSQLschema=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sqlMaxLimit=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dataNode=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;db-node&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;

	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dataNode&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;db-node&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dataHost=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;db-host&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;database=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;test&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; 以下有變  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dataHost&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;db-host&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxCon=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1000&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minCon=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;10&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;balance=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;
			  &lt;span style=&#34;color:#a6e22e&#34;&gt;writeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dbType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mysql&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dbDriver=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;native&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;switchType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;-1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;slaveThreshold=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;heartbeat&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;select user()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/heartbeat&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; !. 定義實際使用資料庫位置 (寫)  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;writeHost&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;host=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;writer&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;url=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;192.168.0.10:3306&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;user=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;password=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pass&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
			&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; !. 定義實際使用資料庫位置 (讀)  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;gt;&lt;/span&gt;
			&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;readHost&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;host=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;reader&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;url=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;192.168.0.20:3306&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;user=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;password=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pass&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/writeHost&amp;gt;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dataHost&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/mycat:schema&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下圖 3 為 mycat 讀寫分離的配置概念圖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191014/20089358ExN78AQM1s.png&#34; alt=&#34;&#34;&gt;
圖 3 : mycat 讀寫分離的配置概念圖&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 注意事項 ~&lt;/strong&gt;
有個東西要注意一下，mysql 的資料同步是要自已實現，mycat 不能會幫你處理喔。&lt;/p&gt;
&lt;h3 id=&#34;mycat-4&#34;&gt;MyCAT 分庫實現&lt;/h3&gt;
&lt;p&gt;分庫的配置就是什麼都建立兩組，然後用戶端要打時，自已決定去打那一個位置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE mycat:schema SYSTEM &amp;#34;schema.dtd&amp;#34;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;mycat:schema&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns:mycat=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://io.mycat/&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;schema&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Order&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkSQLschema=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sqlMaxLimit=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dataNode=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order-node&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;schema&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkSQLschema=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sqlMaxLimit=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dataNode=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user-node&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dataNode&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order-node&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dataHost=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order-host&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;database=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;db1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dataNode&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user-node&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dataHost=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user-host&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;database=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;db2&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dataHost&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;order-host&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxCon=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1000&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minCon=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;10&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;balance=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;
                          &lt;span style=&#34;color:#a6e22e&#34;&gt;writeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dbType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mysql&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dbDriver=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;native&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;switchType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;slaveThreshold=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;heartbeat&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;select user()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/heartbeat&amp;gt;&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;writeHost&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;host=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;host1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;url=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;192.168.1.199:3306&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;user=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;password=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;123456&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dataHost&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;dataHost&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;user-host&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxCon=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1000&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minCon=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;10&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;balance=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;
                          &lt;span style=&#34;color:#a6e22e&#34;&gt;writeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dbType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mysql&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dbDriver=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;native&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;switchType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;slaveThreshold=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;heartbeat&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;select user()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/heartbeat&amp;gt;&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;writeHost&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;host=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;host2&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;url=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;192.168.1.166:3306&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;user=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;password=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;123456&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/dataHost&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/mycat:schema&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191014/20089358cu2pPkzWjr.png&#34; alt=&#34;&#34;&gt;
圖 4 : 分庫分表 mycat 配置概念圖&lt;/p&gt;
&lt;h2 id=&#34;-docker--mycat-&#34;&gt;使用 Docker 來實現 MyCAT 讀寫分離&lt;/h2&gt;
&lt;p&gt;請至筆者的 github 抓取這個專案，不過先說一下，這個 docker-compose 是抓了其它 mycat 的配置來修修改改，改改修修，雖然可以動，不過裡面還很亂，閒時會慢慢的用乾淨點。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/h091237557/docker-composer-tools&#34;&gt;馬克的 github-docker-tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中需要注意看的檔案如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docker-compose : 所有服務的配置。&lt;/li&gt;
&lt;li&gt;config/hosts : 將服務的 host 進行指定。&lt;/li&gt;
&lt;li&gt;config/mycat/server.xml : mycat 實際服務的權限配置。&lt;/li&gt;
&lt;li&gt;config/mycat/schema.xml : mycat 資料庫配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading2&#34;&gt;基本使用&lt;/h3&gt;
&lt;p&gt;移至 mycat-master-slave 這個資料夾裡面，然後在執行以下指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-compose up
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;等待一段時間以後，你可以使用以下的指令進行連線，正常應該是可以成功的連進去，其中這個位置是連到 mycat 喔。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql -h127.0.0.1 -P8066 -uroot -ppass

host: 127.0.0.1:8066
username: root
password: pass
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後你就可以在裡面下指令了，一開始應該是空的，那你可以使用以下指令建立一下測試資訊。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;use db;
&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;(
   id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; AUTO_INCREMENT,
   name VARCHAR(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
   age INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
   &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt; ( id )
) ENGINE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;utf8mb4;

&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt; (name, age) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;A-Mark&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt; (name, age) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;B-Jack&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt; (name, age) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;C-Ian&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;36&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt; (name, age) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;E-Jiro&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt; (name, age) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;D-Fucc&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;27&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INTO&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt; (name, age) &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;C-Mark&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;46&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然後你就可以正常的執行 sql 操作囉。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;user&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;dockercompose-&#34;&gt;Docker-Compose 檔說明&lt;/h3&gt;
&lt;p&gt;這裡使用 docker-compose 來配置一個模擬的 mycat 讀寫分離情境，其中有三個服務 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mysql_write : 用來專門寫入的 mysql&lt;/li&gt;
&lt;li&gt;mysql_read : 用來專門讀取的 mysql&lt;/li&gt;
&lt;li&gt;mycat : 就是資料庫中件間服務&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有幾個重點說一下。&lt;/p&gt;
&lt;p&gt;首先讀與寫的 mysql 服務都是使用 bitnami/mysql:5.7 ，是因為它可以很簡單的讓我可以使用兩台資料庫資料同步的功能，不然用原生的很配置要寫很常。&lt;/p&gt;
&lt;p&gt;然後這裡還有設置 db 的 docker network，不知道為什麼嘗試的時後直接使用 link 會失敗，詳細原因就待查，反正這只是淺淺的範例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yml&#34; data-lang=&#34;yml&#34;&gt;version: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3&amp;#39;&lt;/span&gt;

services:
  mysql_write:
    image: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;bitnami/mysql:5.7&amp;#39;&lt;/span&gt; 
    ports:
      - &lt;span style=&#34;color:#ae81ff&#34;&gt;33061&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;3306&lt;/span&gt;
    networks:
      db:
        ipv4_address: &lt;span style=&#34;color:#ae81ff&#34;&gt;192.168&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.0&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.10&lt;/span&gt;
    environment:
      - MYSQL_REPLICATION_MODE=master
      - MYSQL_REPLICATION_USER=repl_user
      - MYSQL_USER=mark
      - MYSQL_DATABASE=test
      - ALLOW_EMPTY_PASSWORD=yes
      - MYSQL_ROOT_PASSWORD=pass
    volumes:
      - ./mysql/write/:/etc/mysql/conf.d
      - ./config/hosts:/etc/hosts:ro
  mysql_read:
    image: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;bitnami/mysql:5.7&amp;#39;&lt;/span&gt; 
    ports:
      - &lt;span style=&#34;color:#ae81ff&#34;&gt;33062&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;3306&lt;/span&gt;
    networks:
      db:
        ipv4_address: &lt;span style=&#34;color:#ae81ff&#34;&gt;192.168&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.0&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.20&lt;/span&gt;
    environment:
      - MYSQL_REPLICATION_MODE=slave
      - MYSQL_REPLICATION_USER=repl_user
      - MYSQL_USER=mark
      - MYSQL_DATABASE=test
      - MYSQL_MASTER_HOST=&lt;span style=&#34;color:#ae81ff&#34;&gt;192.168&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.0&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.10&lt;/span&gt;
      - MYSQL_MASTER_PORT_NUMBER=&lt;span style=&#34;color:#ae81ff&#34;&gt;3306&lt;/span&gt;
      - MYSQL_MASTER_ROOT_PASSWORD=pass
      - ALLOW_EMPTY_PASSWORD=yes
    volumes:
      - ./mysql/read/:/etc/mysql/conf.d
      - ./config/hosts:/etc/hosts:ro
  mycat:
    image: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;qiyue/mycat:1.6.5&amp;#39;&lt;/span&gt;
    volumes:
      - ./config/mycat/:/usr/local/mycat/conf/
      - ./log/mycat-logs/:/mycat/logs/:rw
    ports:
      - &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;8066:8066&amp;#34;&lt;/span&gt;
      - &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;9066:9066&amp;#34;&lt;/span&gt;
    networks:
      db:
        ipv4_address: &lt;span style=&#34;color:#ae81ff&#34;&gt;192.168&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.0&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.5&lt;/span&gt;
    ulimits:
      nproc: &lt;span style=&#34;color:#ae81ff&#34;&gt;65535&lt;/span&gt;
    hostname: mycat
    restart: always
networks:
    db:
      driver: bridge
      ipam:
        driver: default
        config:
          - subnet: &lt;span style=&#34;color:#ae81ff&#34;&gt;192.168&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.0&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.0&lt;/span&gt;/&lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然後還有這三個服務都配置在 db 這個 network 內網中，然後這裡比較特別的是，會將這三台服務配置 config/hosts 也就是讓人在內網中打 writer 就會對應到 192.168.0.10 這個位置，概念就像是 localhost 指向。&lt;/p&gt;
&lt;p&gt;原本想嘗試在 mycat 中直接配置 ip，但嘗試了一下不太行，原因還是待查，難怪看起他人的配置都是要配置 config/hosts。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1	localhost
192.168.0.10	writer
192.168.0.20	reader
192.168.0.5	mycat
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這裡就淺淡到這囉。詳細的內容自已去 github 看 code 吧，因為嚴格來說算最後的一天，我疲勞了。&lt;/p&gt;
&lt;h2 id=&#34;heading3&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章咱們介紹了其中一種資料庫中件間『 MyCAT 』。然後咱們非常淺的理解一下它的使用範例，與使用 docker 來實際上將它建立出來。&lt;/p&gt;
&lt;p&gt;那為啥會選他來介紹，只因為它資料比較多…… 到了今天已經沒有多餘的體力可以更深入的調查與研究了，未來如果有機會在開篇來真的詳細談談這東西。&lt;/p&gt;
&lt;p&gt;雖然才 29 天，但基本上就和最後一天沒差多少了，雖然參加過不少次，但是真的最後寫到很疲勞，終於要結束了……&lt;/p&gt;
&lt;h2 id=&#34;heading4&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000010208682&#34;&gt;MyCat简单使用与配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kknews.cc/zh-tw/tech/2kq6xjr.html&#34;&gt;資料庫中間件詳解 | 珍藏版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kknews.cc/zh-tw/tech/m3zqqk6.html&#34;&gt;MySQL中間件盤點&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/186229/&#34;&gt;MySQL 5.7: 使用MySQL Router實現應用程式的高可用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/jeikerxiao/article/details/81107105&#34;&gt;Mycat单库分表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.twblogs.net/a/5d5f4748bd9eee5327fdf731&#34;&gt;數據庫中間件 MyCat 的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/liuwel/docker-mycat&#34;&gt;github-liuwel/docker-mycat&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-28 之資料庫層擴展難題 -  MySQL 分散式事務處理</title>
      <link>https://mark-lin.com/posts/20190928/</link>
      <pubDate>Sat, 28 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190928/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191013/2008935880kTCS16cb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;本篇文章中，咱們要來說說分散式系統中，最麻煩的部份『 分散式事務 』這一塊，接下來咱們來認真的理一下這個鬼。&lt;/p&gt;
&lt;p&gt;本篇分為以下幾個章節 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分散式事務難題&lt;/li&gt;
&lt;li&gt;分散式事務的處理方案 : 2 PC 二階段提交（ Two-phase Commit ）&lt;/li&gt;
&lt;li&gt;MySQL XA 事務實現與使用&lt;/li&gt;
&lt;li&gt;MySQL XA 問題 - 性能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading1&#34;&gt;分散式事務難題&lt;/h2&gt;
&lt;p&gt;首先咱們都知道資料庫有所謂的『 事務 』機制，比較準備的說是事務這個『 單位 』，它當初建立出來是為了解決所謂的 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;確保『 同一組資料庫業務操作 』可以有正確的結果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它們不會因為某項業務的其中一項操作錯誤了，導致整個資料庫的資料不正確 ( A )。&lt;/p&gt;
&lt;p&gt;它們不會因為系統固障而導致原本成功修改的資料消失 ( D )。&lt;/p&gt;
&lt;p&gt;它們不會因為並行操作，導致資料產生產生無法預期的結果 ( I )。&lt;/p&gt;
&lt;p&gt;總而言之，事務在固障與並行的情況下，不會產生所謂的『 資料不一致性 』 ( C )&lt;/p&gt;
&lt;p&gt;如果事務可以確保上述事情，那就可以說 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這個事務有 ACID 的特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然後咱們在以下三篇文章中，咱們有談到，在 mysql 單機事務的情況下，它們用了以下的機制來確保這些機制 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性 A : undo log&lt;/li&gt;
&lt;li&gt;持久性 D : redo log&lt;/li&gt;
&lt;li&gt;隔離性 I : 鎖 + mvcc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10222851&#34;&gt;30-15 之資料庫層的難題 - 單機『 故障 』一致性難題&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10223427&#34;&gt;30-16 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 1 )&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10223842&#34;&gt;30-17 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 2 )&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是注意 ! 上述都是單機 acid 的解法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那如果換到『 分散式 』的情況怎麼辦呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這就是咱們接下來要說的東西『 mysql xa 協議 』。&lt;/p&gt;
&lt;p&gt;不過先說一下，mysql xa 協議嚴格來說，它只能解決所謂的 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原子性 A、隔離性 I&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;持久性這個我還不確定，而一致性這鬼，這東西在分散式的概念又與單機的概念不太相同了，詳細的原因請看看 cap 理論與 base 理論，這裡我不能給準確的答案。&lt;/p&gt;
&lt;p&gt;但在開始 xa 協議之前，咱們要先來看看一個東西 2 pc。&lt;/p&gt;
&lt;h2 id=&#34;---2-pc-twophase-commit-&#34;&gt;分散式事務的處理方案 : 二階段提交（ 2 PC Two-phase Commit ）&lt;/h2&gt;
&lt;p&gt;記好 2 pc 它是儘可能讓咱們在分散式的環境下，可以實現『 事務原子性 』，而不是所有的 acid 特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2 PC 是為了實現分散式事務的原子性特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然後比較白話文的說法為 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2 PC 是為了讓『 分散式事務 』可以達成，要麻全完成，要麻全部未完成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它的基本原理如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Phrase 1 : 準備階段&lt;/li&gt;
&lt;li&gt;Phrase 2 : 提交階段&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-pc-&#34;&gt;2 PC 流程&lt;/h3&gt;
&lt;h4 id=&#34;phrase-1--&#34;&gt;Phrase 1 : 準備階段&lt;/h4&gt;
&lt;p&gt;接下來咱們第一階段的流程如下圖 1 所示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用戶發送個業務進來處理，&lt;/li&gt;
&lt;li&gt;協調者會建立一個分散式事務，這個事務內含對資料庫 a 與 b 的操作，然後會往每資料庫的參與者進行相對應的操作。&lt;/li&gt;
&lt;li&gt;參與者收到請求後，會執行各事務的開始與操作 ( 注意沒有執行 commit 喔 )&lt;/li&gt;
&lt;li&gt;參與者回應給協調者說，我這已經可以『 準備 commit 』了喔&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191013/20089358yFAjXu9QFJ.png&#34; alt=&#34;&#34;&gt;
圖 1 : 成功的第一階段&lt;/p&gt;
&lt;h4 id=&#34;phrase-2--&#34;&gt;Phrase 2 : 提交階段&lt;/h4&gt;
&lt;p&gt;上面的第一階段，協調者已經從各參與者收到 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我們都可以『 準備 commit 』了喔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下來操作流程如下圖 2 所示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;協調者和參與者說，你們可以 commit 了&lt;/li&gt;
&lt;li&gt;各參與者實際執行事務 commit。&lt;/li&gt;
&lt;li&gt;各參與者回應成功給協調者。&lt;/li&gt;
&lt;li&gt;當協調者收到『 所有 』參與者成功的回應，才代表這個分散式事務成功結束。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191013/20089358Avanzn7QaY.png&#34; alt=&#34;&#34;&gt;
圖 2 : 成功的第二階段&lt;/p&gt;
&lt;h3 id=&#34;heading2&#34;&gt;失敗情況&lt;/h3&gt;
&lt;h4 id=&#34;phrase-1--1&#34;&gt;Phrase 1 : 準備階段&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;用戶發送個業務進來處理，&lt;/li&gt;
&lt;li&gt;協調者會建立一個分散式事務，這個事務內含對資料庫 a 與 b 的操作，然後會往每資料庫的參與者進行相對應的操作。&lt;/li&gt;
&lt;li&gt;參與者收到請求後，會執行各事務的開始與操作 ( 注意沒有執行 commit 喔 )&lt;/li&gt;
&lt;li&gt;注意 ! 這時參與者 b 的回應一直沒收到。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191013/20089358aXCFFSGyyM.png&#34; alt=&#34;&#34;&gt;
圖 3 : 失敗的第一階段&lt;/p&gt;
&lt;h4 id=&#34;phrase-2--1&#34;&gt;Phrase 2 : 回滾階段&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;協調者和參與者說，你們全部給我 rollback !&lt;/li&gt;
&lt;li&gt;各參與者實際執行事務 rollback。&lt;/li&gt;
&lt;li&gt;各參與者回應成功給協調者。&lt;/li&gt;
&lt;li&gt;當協調者收到『 所有 』參與者成功的回應，才代表這個事務結束。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191013/20089358uJNehjN1m1.png&#34; alt=&#34;&#34;&gt;
圖 4 : 失敗的第二階段&lt;/p&gt;
&lt;h2 id=&#34;mysql-xa-&#34;&gt;MySQL XA 事務實現與使用&lt;/h2&gt;
&lt;p&gt;上述章節就是最基本的 2 pc 流程，而咱們也知道這個流程可以確保咱們的 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分散式事務 ACID 特性的原子性 A&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下來咱們要來說說 mysql 有支援的 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;XA 協議&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而如果是用 mysql 的 xa 協議可以確保 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分散式事務 ACID 特性的隔離性 I&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在這章章開始前先問一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;xa 協議與 2 pc 是有什麼關係呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的 2 pc 是一種概念與方法，然後 xa 協議是定義出來 2 pc 中『 協調者 』與『 參與者 』各自實際上要做的事情，就像是通訊協議一樣， http 協議定義好，接受方與放送方都要可以解析 http 封包。&lt;/p&gt;
&lt;p&gt;首先 mysql 它有支援所謂的『 xa 協議 』，但是它有分為兩種 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;內 xa 協議 : 它主要是用來處理 binlog 與 redo log 的事務。&lt;/li&gt;
&lt;li&gt;外 xa 協議 : 就是支援多個資料庫的協議，而這就是咱們在這章節說的分散式事務原子性的實現。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中咱們的重點是『 外 xa 協議 』，mysql 在這裡的支援為『 xa 協議的參與者 』，所以當有個協調者以 xa 協議發送請求到 mysql 上，它就會進行 2 pc 的處理，就如果 5 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191013/20089358VfyXxDoUzk.png&#34; alt=&#34;&#34;&gt;
圖 5 : mysql 2 pc xa 協議圖&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;這裡為什麼協調者那要打個問號呢 ? mysql 沒支援嗎 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嗯對沒有。&lt;/p&gt;
&lt;p&gt;協調者要自已寫程式碼，又或是使用一些資料庫中間件，這些中間件有些會有支援 xa 協調者的功能，下一篇文章會簡單的說明一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識補充 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;淺淡一下，為什麼要有『 內 xa 協議 』呢 ?&lt;/p&gt;
&lt;p&gt;binlog 在 mysql 中是用來記錄 sql 操作log ，而 redo log 是 innodb 用來記錄修改過的頁 log，反正兩個都是記錄修改資料的 log。這兩個東東詳細的介紹可以看以下兩篇文章。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10222851&#34;&gt;30-15 之資料庫層的難題 - 單機『 故障 』一致性難題&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面有提到，它倆『 嚴格來說 』都是『 記錄修改資料的 log 』，只是以不同的觀點來記錄，一個是 sql 修改，一個是那個硬碟頁修改。&lt;/p&gt;
&lt;p&gt;那這時要如何的保證一致性呢 ? 也就是不會發生一個有 log 而另一個沒 log 的問題。它的解法就是
『 內 xa 協議 』也就是說它也是透過 2 pc 來達成這件事情。&lt;/p&gt;
&lt;h3 id=&#34;mysql-xa-1&#34;&gt;MySQL XA 的使用方式&lt;/h3&gt;
&lt;p&gt;下面為咱們實際使用 mysql xa 的概念碼，其中下述程式為上圖 5 中的協調者的程式碼。其中注意一下，雖然是用 js 寫的，都這裡全部假設都是同步的就好，反正只是概念碼。&lt;/p&gt;
&lt;p&gt;基本上下述程式碼分為幾個階段 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;兩個資料庫開啟分散式事務 xid1。&lt;/li&gt;
&lt;li&gt;兩個資料庫進行 sql 業務操作。&lt;/li&gt;
&lt;li&gt;db_a 的資料庫進行 xa 第一階段，也就是確認『 可否準備提交 』&lt;/li&gt;
&lt;li&gt;db_b 的資料庫進行 xa 第一階段，也就是確認『 可否準備提交 』&lt;/li&gt;
&lt;li&gt;當兩個資料庫都確認可提交後，執行 xa 第二階段，提交此分散式事務。&lt;/li&gt;
&lt;li&gt;如果中間有發生失敗，則將此分散式事務進行 rollback。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 協調者所執行的概念碼
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;connA&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mysql&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createConnection&lt;/span&gt;({
  &lt;span style=&#34;color:#a6e22e&#34;&gt;database&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;DB_A&amp;#39;&lt;/span&gt;
});
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;connB&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mysql&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createConnection&lt;/span&gt;({
  &lt;span style=&#34;color:#a6e22e&#34;&gt;database&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;DB_B&amp;#39;&lt;/span&gt;
});


&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
    &lt;span style=&#34;color:#75715e&#34;&gt;// (1) 兩個資料庫指定同一個『 分散式事務編號 xid1 』
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;connA&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XA START xid1&amp;#39;&lt;/span&gt;);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;connB&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XA START xid1&amp;#39;&lt;/span&gt;);

    &lt;span style=&#34;color:#75715e&#34;&gt;// (2) 兩個資料庫的操作
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;connA&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Update user SET name = Mark WHERE id = 1&amp;#39;&lt;/span&gt;);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;connB&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Update user SET name = Ian WHERE id = 2&amp;#39;&lt;/span&gt;);

    &lt;span style=&#34;color:#75715e&#34;&gt;// (3) DB_A 的 2PC Phrase 1 準備階段確認
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;connA&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XA END xid1&amp;#39;&lt;/span&gt;);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;connA&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XA PREPARE xid1&amp;#39;&lt;/span&gt;);

    &lt;span style=&#34;color:#75715e&#34;&gt;// (4) DB_B 的 2PC Phrase 1 準備階段確認
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;connB&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XA END xid1&amp;#39;&lt;/span&gt;);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;connB&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XA PREPARE xid1&amp;#39;&lt;/span&gt;);

    &lt;span style=&#34;color:#75715e&#34;&gt;// (5) 2PC Phrase 2 提交階段
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;connA&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XA COMMIT xid1&amp;#39;&lt;/span&gt;);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;connB&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XA COMMIT xid1&amp;#39;&lt;/span&gt;);
} &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; {

    &lt;span style=&#34;color:#75715e&#34;&gt;// (6) 2PC 錯誤時兩個資料庫都 rollback
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;connA&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XA ROLLBACK xid1&amp;#39;&lt;/span&gt;);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;connB&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;XA ROLLBACK xid1&amp;#39;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;奇怪這裡還沒提到 xa 協議如何實現 ACID 的隔離性啊 ? 別急等等有&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;mysql-xa-2&#34;&gt;MySQL XA 問題&lt;/h2&gt;
&lt;p&gt;mysql 根據 2 pc 所實現 xa 協議有個很嚴重的問題那就是 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;性能很毛&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用 mysql xa 性能會非常的差，主要有以下兩個原因 :&lt;/p&gt;
&lt;h3 id=&#34;-1--&#34;&gt;性能差原因 1 : 需要等待每個參與者&lt;/h3&gt;
&lt;p&gt;如果下圖 6 所示，如果每個協調者是同步操作的情況下，那有幾個參與者就要等幾次，而如果是非同步的協調者，那還是要等一個最久的參與者回應，才能往下走，你想想，如果其中一個網路有問題或啥的，等了 5 秒，那就代表這整個分散式事務要 5 秒才能處理完。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191013/20089358p9TqAwrZ02.png&#34; alt=&#34;&#34;&gt;
圖 6 : xa 協議性能差原因 1&lt;/p&gt;
&lt;h3 id=&#34;-2--mysql--serializable&#34;&gt;性能差原因 2 : MySQL 的事務隔離級別需調整成 SERIALIZABLE&lt;/h3&gt;
&lt;p&gt;mysql 官網要求如果要使用分散式事務 xa 那就要將隔離級別改為 serializable&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, for a distributed transaction, you must use the SERIALIZABLE isolation level to achieve ACID properties. It is enough to use REPEATABLE READ for a nondistributed transaction, but not for a distributed transaction&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而這裡就是實現隔離性的原因 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql xa 協議要求的 serializable 隔離級別，可以確保分散式事務的 ACID 特性中的隔離性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;為什麼要改成 serializable 隔離級別呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先簡單複習一下，咱們 mysql 資料庫預設的 RR 隔離級別的特性如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;讀不加鎖，使用 mvcc 版本讀，每次讀取時，只會讀事務開始前的最新版本。&lt;/li&gt;
&lt;li&gt;寫加鎖。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然後問題就出在下述圖 7 的這種情況。這個情況是這樣的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;預設欄位值 :
X 資料庫 count = 0
Y 資料庫 price = 10

分散式事務 A 裡面包含兩個不同資料庫 X,Y 的更新操作

X 資料庫操作 =&amp;gt; 將欄位 count 更新為 100
Y 資料庫操作 =&amp;gt; 將欄位 price 更為為 20
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後咱們還有另一個分散式事務 B 進行以下的操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;分取式事務 B 裡面包含兩個不同資料庫 X,Y 的讀取操作

X 資料庫操作 =&amp;gt; 讀取 count 欄位
Y 資料庫操作 =&amp;gt; 讀取 price 欄位

最後將結果相乘得出值 = count * price
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191013/20089358e7ABsXRvyY.png&#34; alt=&#34;&#34;&gt;
圖 7 : xa 協議如果是 rr 級別的問題&lt;/p&gt;
&lt;p&gt;這裡先說一下，為啥圖 7 的正確讀取的結果，會有兩種，這種道理可以想成串行執行，如果兩個事務執行是一個前，一個後，那結果就會有兩種，因為看誰先執行，而這兩種結果是可以接受的，因為它符合 acid 的『 隔離性 』，一個事務的操作，不會影響到另一個事務。&lt;/p&gt;
&lt;p&gt;好那先拉回來，問題出在那呢 ?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;問題就出在圖 7 紅色框框那的讀取，它會讀到 x 資料庫單機事務已提交的值 count = 100。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這有啥毛病呢 ? 事務不是提交了嗎 ? 嗯『 單機事務 』已經提交了沒錯，但是別忘了『 分散式事務 』還沒提交。&lt;/p&gt;
&lt;p&gt;咱們在說一致性問題時，有提到一個難題那就是『 髒讀 』。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;髒讀代表某個事務會讀取到其它事務『 未提交 』的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而這也代表它沒有符合 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;acid 的隔離性，因為 a 分散式事務的操作影響到 b 分散式事務的讀取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以分散式事務角度來看，它已經發生髒讀的情況，因為分散式事務 b 讀取到分散式事務 a 的『 未提交 』值。&lt;/p&gt;
&lt;p&gt;就是因為這種情況，所以 mysql 要使用 xa 協議就一定要將它隔離級別 serializable。當級別改成它後，操作特性就變成如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;讀加鎖 ( 不管 mvcc 版本 )&lt;/li&gt;
&lt;li&gt;寫加鎖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以如果是 serializable 的隔離級別，結果變的圖下圖 8 所示，這樣就會讀取到正確的結果。這就是為什麼使用 xa 一定要 serializable 級別的原因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xa 一定要使用 serializable 級別的原因在於，rr 級別在分取式事務情況，會發生髒讀的問題&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191013/200893580k5oFjKC0f.png&#34; alt=&#34;&#34;&gt;
圖 8 : xa 協議如果是 serializable 級別的結果&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;而由於這個 serializable 級別要求，使得分散式事務變成串行處理，也相對確保了 ACID 的隔離性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;~ 小備註 ~&lt;/strong&gt;
如果不熟悉資料庫隔離級別的友人，可以參考以下兩篇文章。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20190916/&#34;&gt;30-16 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 1 )&lt;/a&gt;
&lt;a href=&#34;https://mark-lin.com/posts/20190917/&#34;&gt;30-17 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 2 )&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading3&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章中咱們提到了某些方面我覺得算是分散式系統中的大難題 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果讓分散式事務執行 acid 的特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而這裡咱們將了一個最基本的方式 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2 PC + MySQL XA 協議&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不過記好這個方案性能很毛。&lt;strong&gt;還有個重點，嚴格來說這個 2 pc 是只完成了 acid 中的 a 與 i 這個兩個特性&lt;/strong&gt;，而致於其它兩個特性在分散式環境要如何解呢 ? 不好意思可能要下一次鐵人賽才知道了……&lt;/p&gt;
&lt;p&gt;最後這裡淺淡一下實務上的使用，首先，我在實務上到現在沒有看到太多真的有在使用 mysql xa 協議來處理分散式事務的這東西，最主要的原因在於性能這個問題。只要用了 mysql xa 所有資料庫都要調整成 serializable 級別，那資料庫的性能幾乎可以說是差了 10 倍左右，這影響非常的巨大。&lt;/p&gt;
&lt;p&gt;那現在大部份公司如何的處理分散式事務這一塊呢 ? 我知道有幾個名詞例如消息隊列處理或 tcc 等這些方法，但在實務上台灣有沒有公司用我就不知道呢。&lt;/p&gt;
&lt;p&gt;說實話，就算是在咱公司也都沒有處理這塊 ( 我所知道的部份 )，雖然咱們有分庫，但是那是為了『 業務或維護 』而分，不是為了性能，咱們在使用時大部份 95 % 的時間還是單庫操作，真有多庫操作也都是讀的情況。&lt;/p&gt;
&lt;p&gt;不過這裡也只是我自已看到的東西，假設有看到有台灣公司有處理這塊的，真想跪請他們分享一下是如何處理這塊鬼問題的。&lt;/p&gt;
&lt;p&gt;順到說一下這也讓我有點好奇，微服務這一塊，它這裡是如何處理的呢 ? 這或需是未來另一個可以深入探討的方向呢。&lt;/p&gt;
&lt;h2 id=&#34;heading4&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.itread01.com/content/1547223243.html&#34;&gt;[DB] 資料庫分散式事務&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5bf201f7f265da610f63528a&#34;&gt;拜托，面试请不要再问我TCC分布式事务的实现原理！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/38248080&#34;&gt;漫谈事务与分布式事务（1）- 理解 ACID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/275845393/answer/385101903&#34;&gt;请问分布式事务一致性与raft或paxos协议解决的一致性问题是同一回事吗？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5d9c358f6fb9a04e2f71c251?utm_source=gold_browser_extension&#34;&gt;分布式事务 两阶段提交 (2PC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5d9eb3c8e51d4578305f3086?utm_source=gold_browser_extension&#34;&gt;阿里分布式事务解决方案 Fescar 解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/soonfly/article/details/70677138&#34;&gt;详解Mysql分布式事务XA（跨数据库事务）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5b5a0bf9f265da0f6523913b&#34;&gt;再有人问你分布式事务，把这篇扔给他&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.6/en/innodb-consistent-read.html&#34;&gt;mysql-14.7.2.3 Consistent Nonlocking Reads&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-27之資料庫層的擴展 - 分區表</title>
      <link>https://mark-lin.com/posts/20190927/</link>
      <pubDate>Fri, 27 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190927/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191012/20089358IsTcYcPdWQ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;上一篇文章中，咱們有提到了兩種資料庫層的擴展方式 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分庫&lt;/li&gt;
&lt;li&gt;分表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中分表是用來解決單表太大的問題，而接下來本章節要來介紹另一種處理單表太的工具 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分區表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章分以下幾個章節 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分區概念&lt;/li&gt;
&lt;li&gt;MySQL 分區的切分類型&lt;/li&gt;
&lt;li&gt;分區使用的注意事項&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading1&#34;&gt;分區概念&lt;/h2&gt;
&lt;p&gt;分區表的核心概念為 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;將一張大表，根據『 規則 』拆分為『 隱藏 』的小表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;觀念和分表事實上完全相同，就差在『 隱藏 』這個字詞上。它們的差異如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分表 : 分表後，應用層需要修改 sql 操作位置，指定到對應的分表上。&lt;/li&gt;
&lt;li&gt;分區 : 分區後，應用層『 不 』需要修改 sql 操作位置，資料庫層會自動幫你處理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是說假設是使用 type 這個欄位來『 分表 』那你在查詢時可能需為變成如下指令 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user 根據 type 拆分成三個表 :
1. user_type_A 表
2. user_type_B 表
3. user_type_C 長

SELECT * FROM user_type_A WHERE name = &#39;mark&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而如果是『 分區表 』的話為 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM user WHERE name = &#39;mark&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;這裡問個問題 ~ 那實務上要使用分表還是分區呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先這兩個沒有互相排斥，兩個可以一起使用，但如果是要先選一個來用的話，要選那個呢 ? 目前我是覺得『 分區 』比較簡單實現，但是它在使用上會比較需要『 使用者 』注意，一個用不好，性能反而會下降。&lt;/p&gt;
&lt;p&gt;而『 分表 』某些方面來說彈性較大，可以做的業務較多，但相對的除非有一個很完美的中間件團隊，不然坑如果直接各別讓『 使用者 』直接用資料庫，會天下大亂的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分區表這個東西在不少資料庫上都有提供像 mysql、ms-sql、postgresql 等都有支援。&lt;/p&gt;
&lt;h3 id=&#34;heading2&#34;&gt;分表區的優點&lt;/h3&gt;
&lt;p&gt;分區有以下幾個好處 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;減少修改時對索引樹的維護 : 因為越大的樹越難維護，所以切小後，每顆樹就好維護多了。&lt;/li&gt;
&lt;li&gt;減少索引碎片處理 : 只要是有進行修改，就有可能會讓索引樹一個洞一個洞的，而通常會下達指令來整理這顆樹，但是這很耗效能，而且如果樹越大，資源吃越多。&lt;/li&gt;
&lt;li&gt;增加查詢效率 : 越大的樹查詢效率一定越小，而不過切小後，『 只對 』那顆小樹查那就快多了。&lt;/li&gt;
&lt;li&gt;增加表的維護性 : 假設咱們要針對大表中某一段時間砍資料，那這時如果每張表是以時間來分的話，那就只要直接砍掉小表，這樣也不會影響到其它小表的查詢。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面看似美好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但分區表不是銀彈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;後面章節會說明它的坑處。&lt;/p&gt;
&lt;h2 id=&#34;mysql-&#34;&gt;MySQL 分區的切分類型&lt;/h2&gt;
&lt;p&gt;mysql 中分區表提供了以下的類型，然後咱們指定分區的那個欄位都稱為 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分區鍵&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分區鍵的選擇要點提醒&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那個欄位會變成每一次查詢時，都會要用的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;-1--range-&#34;&gt;類型 1 : RANGE 分區&lt;/h4&gt;
&lt;p&gt;假設咱們由一張儲員工的資料表，那咱們可以選擇以『 RANGE 』來分區，通常這種分區欄位比較常見的有日期或啥有順序的編號之類。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; users (
    id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
    age INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
)
PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; RANGE (age) (
    PARTITION p0 &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LESS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;THAN&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;),
    PARTITION p1 &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LESS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;THAN&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;),
    PARTITION p2 &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LESS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;THAN&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;),
    PARTITION p3 &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LESS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;THAN&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假設咱們有以下的員工 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A : age = 18
B : age = 25
C : age = 35
D : age = 45
E : age = 15
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那這樣上述資料會分別放在不同的分區表中 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p0 : A,E
p1 : B
p2 : C
p 3 : D
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;-2--list-&#34;&gt;類型 2 : LIST 分區&lt;/h4&gt;
&lt;p&gt;list 這種分區通常是用在枚舉類型上，如下範例，咱們有一個 type 欄位，然後使用數字來代表類型，然後就使用這個類型來決定分區。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; users (
    id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
    age INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
)
PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; list (&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt;) (
    PARTITION p0 &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LESS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;THAN&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;),
    PARTITION p1 &lt;span style=&#34;color:#66d9ef&#34;&gt;VALUES&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LESS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;THAN&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;),
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假設咱們有以下的員工 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A : age = 18, type : 0
B : age = 25, type : 1
C : age = 35, type : 2
D : age = 45, type : 0
E : age = 15, type : 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那這樣上述資料會分別放在不同的分區表中 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p0 : A,B,D,E
p1 : E
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;-3--hash-&#34;&gt;類型 3 : Hash 分區&lt;/h4&gt;
&lt;p&gt;它就是會直接將 id 進行 hash 後分成四個區。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; users (
    id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
    age INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
)
PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; HASH(id)
PARTITIONS &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;-4--key-&#34;&gt;類型 4 : KEY 分區&lt;/h4&gt;
&lt;p&gt;它就是會直接根據指定的 pk 來分區。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; users (
    id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt;, ,
    age INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
)
PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt;()
PARTITIONS &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;heading3&#34;&gt;分區使用的注意事項&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;-1--&#34;&gt;注意 1 : 查詢時一定有用到分區鍵，不然還是會每個分區找&lt;/h3&gt;
&lt;p&gt;假設咱們有以下的分區表。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; users (
    id INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt;, ,
    age INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;,
    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; INT &lt;span style=&#34;color:#66d9ef&#34;&gt;NOT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NULL&lt;/span&gt;
)
PARTITION &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;KEY&lt;/span&gt;()
PARTITIONS &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然後咱們下達以下的指令進行 query :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXPLAIN SELECT * FROM users WHERE age = 10;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那你會看到以下的結果如下 explain 的結果，你會發現它去每一個分區都找過。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;partitions 
p0,p1,p2,p2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而如果改成 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXPLAIN SELECT * FROM users WHERE id = 1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;結果如下，就有使用到分區表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;partitions 
p0
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;-2--&#34;&gt;注意 2 : 沒有使用到分區表查詢會慢&lt;/h3&gt;
&lt;p&gt;分區別是為了解決單表太大，導致操作太慢所進行的一種解法，以 b+ 樹的概念來看，就是將一顆大樹分成幾個小樹。&lt;/p&gt;
&lt;p&gt;但是這有一個問題，如果你的查詢沒有用到分區，那也就代表你需要去每個小樹找，那這樣整體而言 i/o 的次樹會大於一顆大樹。&lt;/p&gt;
&lt;p&gt;mysql innodb 是使用 b+ 樹來建立資料，在資料庫中基本上樹的高度大約為 2 至 3，不論資料的多與少，這也代表你分區以後，那幾顆分區後出來的 b+ 樹高度也是會差不多的。&lt;/p&gt;
&lt;p&gt;所以有可能大表查詢需要 3 次 i/o，但變到小表可能就只需要 2 次 i/o，但是如果沒有指定分區查詢的話，假設有 4 個小表，那就代表要 2 * 4 = 8 次 i/o 查詢，這樣反而變慢了。&lt;/p&gt;
&lt;p&gt;所以這裡記好 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查詢時一定要包含分區鍵來查詢，沒用到會很慢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;-3--null-&#34;&gt;注意 3 : NULL 的問題&lt;/h3&gt;
&lt;p&gt;如果你的分區鍵中，所對應的表格是 null 的話，那他會如何處理呢 ?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它會都儲在第一個分區&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以有時後不知覺第一個分區查詢會非常慢就是這個原因。&lt;/p&gt;
&lt;h3 id=&#34;-4--&#34;&gt;注意 4 : 索引的使用問題&lt;/h3&gt;
&lt;p&gt;分區鍵與索引鍵不相同時&lt;/p&gt;
&lt;p&gt;假設咱們有一張表，它們的分區與索引鍵如下 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;欄位 a 與 b

分區鍵 : a
索引鍵 : b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那你想想，如果這個時後下以下的 sql 會如何呢 ? 它基本上會去每一個分區表中的每個顆 b+ 樹去找一次，就算有使用索引 b 仍然會非常的慢，尤其如果是沒有用到『 覆蓋索引 』。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM table WHERE b = 1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以這裡建議，任何查詢一定要配分區鍵&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM table WHERE b = 1 AND a = x
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;~ 小備註 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面有提到覆蓋索引這東西，如果還不知道的友人們，可以參考看看筆者這篇文章。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10221572&#34;&gt;30-12 之資料庫層的核心 - MySQL 的索引實現&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;-5---range--insert-&#34;&gt;注意 5 : 在 Range 類型 INSERT 時的問題&lt;/h3&gt;
&lt;p&gt;在範例類型的分區表的操作時，insert 實際上是進行以下事情 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分區層鎖住所有分區表，然後決定它是在那，再將它丟入那個分區&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事實上這個操作非常的消耗性能，所以基本會建議 range 不要設太多分區。&lt;/p&gt;
&lt;h3 id=&#34;-6---explain-&#34;&gt;注意 6 : 記得常用 Explain 來看看有沒有分區&lt;/h3&gt;
&lt;p&gt;注意 explain 中的 partiation 欄位，如果是全部的分區都有掃到，那就要考慮改一下你的語法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id: 1
select_type: simple
table: user
partiation: p1
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;--&#34;&gt;最後的注意 : 分區鍵的選擇非常重要&lt;/h3&gt;
&lt;p&gt;你只要記好，你只有一次機會選擇它，上線已後要改，會出人命的。&lt;/p&gt;
&lt;h2 id=&#34;heading4&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章中，咱們介紹了淺談了資料庫分區表的概念，它的概念事實上和咱們上一章節介紹的分表非常的相似，但是還是有點不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分表 : 分表後，應用層需要修改 sql 操作位置，指定到對應的分表上。&lt;/li&gt;
&lt;li&gt;分區 : 分區後，應用層『 不 』需要修改 sql 操作位置，資料庫層會自動幫你處理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然後這裡說一下，並不是所有表太大，都需要使用分表或分區這兩個擴展，很多情況下，事實上不需要所有的資料都需要存放在資料庫中，這些資料事實上可以考慮轉移至 s3 或啥的，唯有當資料一定要存在資料庫中，且都需要查詢的情況，才可考慮。&lt;/p&gt;
&lt;p&gt;不然分表與分區後，應用端操作是個雷，資料庫端也是個雷。&lt;/p&gt;
&lt;p&gt;最後在提醒一下分區與分表是用在 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;單表太大的情境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而不是資料庫太大的情境，我真看過有人不管表大不大，一律都分區這樣玩。&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mysql.taobao.org/monthly/2017/11/09/&#34;&gt;MySQL · 最佳实践 · 分区表基本类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/partitioning-range.html&#34;&gt;MySQL 官網分區&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ituring.com.cn/article/472244&#34;&gt;【原创】MYSQL 的那些“坑”&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/partitioning-overview.html&#34;&gt;Overview of Partitioning in MySQL-8.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-26之資料庫層的擴展 - 分庫分表架構</title>
      <link>https://mark-lin.com/posts/20190926/</link>
      <pubDate>Thu, 26 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190926/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191011/20089358wfhe9Vz08O.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;上一篇文章中，咱們介紹了資料庫層的分散的第一個起手式『 讀寫分離 』，這個方案是將寫與讀分散在不同的機器上，正常情況下，大部份的系統使用這種方案就已經可以處理很好了。&lt;/p&gt;
&lt;p&gt;但 !&lt;/p&gt;
&lt;p&gt;如果你已經將資料庫層與緩存層的架構都已經建立好，但還是發現有性能貧頸，那接下來才會建議使用幾個方案，因為這些方案沒用好，會衍生出非常多的問題。&lt;/p&gt;
&lt;p&gt;本篇文章分為以下幾個章節，這些就是接下來咱們要來學的擴展法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分庫&lt;/li&gt;
&lt;li&gt;分表&lt;/li&gt;
&lt;li&gt;分庫與分表的問題&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;--&#34;&gt;重要 : 使用前注意事項&lt;/h4&gt;
&lt;p&gt;要使用以下的擴展方法時，先確認你的資料庫是否以下的問題是否有發生。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;問題 1 : 單庫太大，導致硬碟空間不夠囉。&lt;/li&gt;
&lt;li&gt;問題 2 : 單庫寫入量太大，導致每一次新增或更新性能非常的吃緊，感覺隨時都會上天堂。&lt;/li&gt;
&lt;li&gt;問題 3 : 單表資料量太太，導致每一次操作時都非常的慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有以上事情發生才開始往接下來的擴展走。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;沒事真的別用它們&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;heading1&#34;&gt;分庫&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;它可以解決
問題 1 : 單庫太大，導致硬碟空間不夠囉
與
問題 2 : 單庫寫入量太大，導致每一次新增或更新性能非常的吃緊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先第一個要介紹的就是分庫，它的基本定義如下 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;將一個大大的資料庫，依據『 規則 』拆分成小的資料庫&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中上述說的規則，在傳統上可以分為以下幾種 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;垂直切分 : 根據『 業務 』來拆分成多個小資料庫 ( 圖 1 所示 )。&lt;/li&gt;
&lt;li&gt;水平切分 : 根據『 特性 』來拆分成多個小資料庫，例如地區 ( 圖 2 所示 )。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191011/20089358NiVxczyhHQ.png&#34; alt=&#34;&#34;&gt;
圖 1 : 垂直切分範例&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191011/20089358jdmFWBMEIZ.png&#34; alt=&#34;&#34;&gt;
圖 2 : 水平切分範例&lt;/p&gt;
&lt;p&gt;這個方案基本上在業界應該算是非常常見的方案，尤其是以業務的垂直切分這個方案，整體而言還是有不少的優點，如下幾個 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;減少單庫的性能壓力&lt;/li&gt;
&lt;li&gt;減少備份復原的時間&lt;/li&gt;
&lt;li&gt;增加維護性，例如下修某個資料庫，不會影響到所有的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;業界的確很常使用這個方案，它們會根據業務需求來分成多個庫，可是上面不是建議沒必要，不要這樣搞嗎 ? 嗯對沒錯，但是如果是下面這種情況下，那的確可以切分 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假設在業務擴展初出，所有資料都寫到同一個資料庫中，但後其長大後，就將不同『 單位業務 』的資料分不同資料庫，它們彼此間很獨立，非常少會一起使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這種情況下，我覺得切分合理，而且這很常見。就算是咱們某個資料庫中還是有一堆奇奇怪怪不知道是幹啥的表，或是其它業務的表，這些都是一間公司從 0 至 1+ 時都會有的過程。&lt;/p&gt;
&lt;p&gt;但如果是一堆需要共要在一起的業務，硬是要把他切分成不同資料庫，那我想打爆那個提出這樣切的人的頭。&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;分表&lt;/h2&gt;
&lt;p&gt;這種方法可以解決以下的問題 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它可以解決問題 3 : 單表資料量太太，導致每一次操作時都非常的慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;簡單它們的概念都 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;將一張很大的表，根據『 key 』來分成小張的表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它本質上是應用層自已手動實現，根據規則將一個表，分成多個表，這表可能在同一台機器上，或是不同機器上，應用層 sql 代碼需修改。&lt;/p&gt;
&lt;h4 id=&#34;heading3&#34;&gt;開始前的小提醒&lt;/h4&gt;
&lt;p&gt;分表這種擴展法是用在單表太大的情境。&lt;/p&gt;
&lt;p&gt;假設你們的系統是聊天室這種類型的系統，然後你們會將用戶說的每一句話儲存在某一張表，那你們遲早會碰到表太大，影響查詢這種問題的。&lt;/p&gt;
&lt;p&gt;不過先說一下，&lt;strong&gt;並不是一定要用這種方法來處理此情境&lt;/strong&gt;，像以咱們公司是這樣處理的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根據業務規則，來定義資料表中要儲多久的資料，例如 3 個月左右。&lt;/li&gt;
&lt;li&gt;將 3 個月之前的資料全部打包壓縮丟到 aws s3 或啥的。&lt;/li&gt;
&lt;li&gt;寫一個每天的排程，來定時的砍資料與移資料。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果真的有需要去 s3 找資料，你也可以用 aws athena 去查詢資料的，雖然有點貴，但是久久才用一次，沒毛病。&lt;/p&gt;
&lt;p&gt;上述是題外話，假設咱們真的都需要儲放在資料表中，那咱們就只能選擇『 分表與分區表 』這個方案囉。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不過說句真心話，沒必要真的不要用它，因此之後會很多問題。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;拉回分表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分表的基本概念就是如下，咱們假設以 id 為 key，將這張表拆成如下圖 3 所示。分區表下篇文章會說明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191011/20089358R5Urg1zKv1.png&#34; alt=&#34;&#34;&gt;
圖 3 : 分表範例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;問個問題，分表有需要分到不同的機器嗎 ? 例如下圖 4 所示呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除非，你的單表真的大到，就算進行分表後，單機仍然無法負荷它的資料量，那這樣才可以考慮，不然雷會很多，因為這就代表分庫 + 分表的問題你都需要一同考慮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191011/20089358yWS6t38SZ7.png&#34; alt=&#34;&#34;&gt;
圖 4 : 分表不同機器圖&lt;/p&gt;
&lt;h3 id=&#34;-&#34;&gt;要使用什麼當切分鍵 ?&lt;/h3&gt;
&lt;p&gt;分片（ Sharding ）就是咱們要用什麼規則來去分割資料的意思。以我們這裡來看就是咱們要用什麼欄位，來去分割資料。&lt;/p&gt;
&lt;p&gt;先說一下，我們會很難到完美的分片，一個完美的分片可以讓我們做到以下的事情 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以平均將查詢操作，分配到每一張表。&lt;/li&gt;
&lt;li&gt;可以平均的將新增、更新等操作，分配到每一張表上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;咱們很難找到一個完美的選擇，但是可以先定一個最低的標準選項 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;高基數欄位，這是最低標準&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;為啥 ? 因為這樣才好分割，你想想如果選擇性別男與女來當分割，那這樣你不是只能分成兩份嗎 ? 如果又滿了，你要如何處理 ?&lt;/p&gt;
&lt;p&gt;然後這裡列一下一些常見的分片欄位選項 :&lt;/p&gt;
&lt;h4 id=&#34;-1--&#34;&gt;選擇 1 : 升序特性欄位&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;『 自動產生編號 』 或是 『 日期 』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根據 id 或日期來分區的這種都算是升序特性欄位。以 id 為例，它們的分割方式為 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id_1_1000 : 儲放 id 編號 1 至 1000 的資料
id_1001_2000 : 儲放 id 編號 1001 至 2000 的資料
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是這事實上不能說是好選項，主要的原因在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;操作會壓在一張表上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因為通常新的資料者是會放在同一張表，所以大部份的操作都會壓往他身上。&lt;/p&gt;
&lt;h4 id=&#34;-2--hash--id&#34;&gt;選擇 2 : Hash 編號 Id&lt;/h4&gt;
&lt;p&gt;根據 id + hash 來進行切分，假設咱們有個 hash 函數如下 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hashId = id % 10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這種做法比上述的直接編號來分割還優質點，因為它可以平均的分散到不同的表上。先說一下上述只是 hash 的簡單範例，實際上不一定是用上述方式分割。&lt;/p&gt;
&lt;h4 id=&#34;-3--&#34;&gt;選擇 3 : 隨機特性的欄位&lt;/h4&gt;
&lt;p&gt;像是一些沒有規則的欄位，例如信箱或是一些亂數編號這種，這種欄位分片可以平均的分散到每一張表，但是比較大的問題在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查詢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由於分配是隨機的，所以查詢時不知道要去那張表找，所以只能一個一個慢慢找。&lt;/p&gt;
&lt;h4 id=&#34;-4--&#34;&gt;選擇 4 : 組合型的欄位&lt;/h4&gt;
&lt;p&gt;假設咱們有個資料表是專門存放聊天訊息的，有以下欄位 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id, type , text, user_id, created_at

type : 它有 5 種類型 ( 可能是表示不同的服務 )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那這時如果我們只選擇 type，會發現它的基數太小，怎麼分就可能只有五張表，這樣還是會碰到貧頸的。&lt;/p&gt;
&lt;p&gt;但這時咱們可以轉個想，如果一次用兩個欄位呢 ?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ type, created_at }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如咱們可以根據 type 與 created_at 來當分片欄位組合，這樣的話資料表會分為如下圖 5 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191011/200893584euxx7QrV6.png&#34; alt=&#34;&#34;&gt;
圖 5 : 組合型範例&lt;/p&gt;
&lt;p&gt;這樣就有幾種好處 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查詢方便，如果要查某種類型的，只要去那種類型的表查就好，如果要查時間，就去該段時間查詢。&lt;/li&gt;
&lt;li&gt;有將壓力分散，雖然 type 基數小，但是我們可以同過細分時間段，來減少壓力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面這個只是組合型的範例，不代表一定要這樣使用，這裡只是要點醒一下 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分片欄位不一定是要一個欄位組成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;heading4&#34;&gt;分表與分庫可能會碰到的問題&lt;/h2&gt;
&lt;h4 id=&#34;-1---&#34;&gt;問題 1 : 事務如何處理呢 ?&lt;/h4&gt;
&lt;p&gt;咱們之前的這兩篇文章中，有談到單機一致性的問題。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10222851&#34;&gt;30-15 之資料庫層的難題 - 單機『 故障 』一致性難題&lt;/a&gt;
&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10223427&#34;&gt;30-16 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 1 )&lt;/a&gt;
&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10223842&#34;&gt;30-17 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 2 )&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而它們都是依賴 mysql 所提供的 redo log 與 undo log 還有鎖之類的功能，來達成事務的 acid 特性。&lt;/p&gt;
&lt;p&gt;那如果這個換成『 多台 』資料庫的話，你要如何處理呢 ?&lt;/p&gt;
&lt;p&gt;這個問題咱們會在之後的文章『 分散式事務 』的主是中來慢慢的談談。&lt;/p&gt;
&lt;h4 id=&#34;-2--join--&#34;&gt;問題 2 : Join 如何處理呢 ?&lt;/h4&gt;
&lt;p&gt;在分庫以後，基本上有以下幾種方法解決 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要用 : 自行在應用層抓一抓你要的資料，然後拼裝超來。&lt;/li&gt;
&lt;li&gt;一點點的反正規化 : 也就是說在設計表時，會多加一些欄位，例如訂單與用戶這樣的組合，有可能會在訂單這個分庫的資訊上，多儲放一些用戶的資訊，這樣就不需要使用到 join。&lt;/li&gt;
&lt;li&gt;統一透過中間件處理 : 有一些中間件軟體會提供多庫 join 的操作，以 mycat 來看它有提供，不過只提供兩層的 join，這個地方在之後 mycat 的文章中會提。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這裡是比較建議分庫後儘量不要用 join，因為坑會有點大，而且你儘然分庫了，你還很常需要 join，那是不是要想想，分庫的規則有問題了呢 ?&lt;/p&gt;
&lt;h4 id=&#34;-3---&#34;&gt;問題 3 : 用戶端要如何處理呢 ?&lt;/h4&gt;
&lt;p&gt;通常咱們在分表以後，都需要自已去指定要去那一張表來處理，但是這樣非常的麻煩，所以我們通常會使用 mysql 中間件來處理，變成如下圖 6 所示，這之後會開一篇文章來介紹中間件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;正常分表後，SQL 指定修改

SELECT * FROM table_2019_01 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191011/20089358cHX1YGhxcW.png&#34; alt=&#34;&#34;&gt;
圖 6 : 中間件。&lt;/p&gt;
&lt;h4 id=&#34;-4---&#34;&gt;問題 4 : 唯一編號如何處理呢 ?&lt;/h4&gt;
&lt;p&gt;在分表或水平分庫以後，你可能還要考慮每一張表的唯一編號要如何產生，正常只有一張表時，咱們可以使用自動產生編號來建立順序的編號，但多張時就不能這樣用，因為會衝突。&lt;/p&gt;
&lt;p&gt;基本上有以下幾種方案 :&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案 1 : UUID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;簡單，但是缺點在於沒順序、空間大，這兩個都會影響性能。&lt;/p&gt;
&lt;p&gt;在順序的編號，在查詢時可能增加不少效率。而 uuid 所佔空間比較大，會影響到所建立的 b+ 樹每個索引節點的大小，進而影響到操作性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案 2 : 自動編號 + 偏移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假設你有 4 張表，那他們的生成編號為 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A 表 : 1,5,9,13
B 表 : 2,6,10,14
C 表 : 3,7,11,15
D 表 : 4,8,12,16
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但缺點就在於不好擴展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案 3 : redis 生成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;redis 有提供一個方法 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;incr&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以使用它來產生全局的順序編號，但缺點就在於需要連 redis 處理，還要考慮它是否活這。&lt;/p&gt;
&lt;h4 id=&#34;-5---&#34;&gt;問題 5 : 分表分頁如何處理呢 ?&lt;/h4&gt;
&lt;p&gt;像咱們在單一表進行分頁時，通常是會下如下的指令，說要拿第 6 至 15 的資料 :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;BY&lt;/span&gt; time &lt;span style=&#34;color:#66d9ef&#34;&gt;LIMIT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是現在一個大表變成如下 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;table = tableA + tableB + tableC
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在分表的情境中，要如何處理呢 ?&lt;/p&gt;
&lt;p&gt;首先假設如果咱們的分表是使用『 區間 』來拆分例如日期，那這種情況下，應該還是到指定的表去尋找就夠了，沒啥毛病。&lt;/p&gt;
&lt;p&gt;但如果是用 hash id 這種來分的表呢 ?&lt;/p&gt;
&lt;p&gt;有人會想說，那就每個表的資料都抓出來，在排序然後再抓取前 n 個值不就好呢 ? 服務會炸裂的，分表的原因就是單表太大，你還要進行排序 ( nlogn ) ?&lt;/p&gt;
&lt;p&gt;說實話，我到還沒碰到分表然後又要分頁的情況，這時只能給點參考文件，目前我覺得寫的最完整的是這一篇文章，這個作者也是我之前有提過的『 架構師之路 』這一系列優質文的筆者，他的文章真的只能說優質上等來評價。&lt;/p&gt;
&lt;p&gt;而至於分表分頁這問題，等未來我在這個問題有更深入的理解後，在開篇文章來談談。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;amp;mid=2651959942&amp;amp;idx=1&amp;amp;sn=e9d3fe111b8a1d44335f798bbb6b9eea&amp;amp;chksm=bd2d075a8a5a8e4cad985b847778aa83056e22931767bb835132c04571b66d5434020fd4147f&amp;amp;scene=21#wechat_redirect&#34;&gt;58沈剑 架构师之路-业界难题-“跨库分页”的四种方案&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章中，咱們討論了另外兩種資料庫層的擴展 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分庫&lt;/li&gt;
&lt;li&gt;分表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上我覺得這兩種都是沒必要，不要用的東西，因為如果你在還沒到性能貧頸時就用這幾招，你會面臨到的問題是一個大大的坑，請注意。&lt;/p&gt;
&lt;p&gt;分庫這種場境，可以解決以下幾個問題 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;問題 1 : 單庫太大，導致硬碟空間不夠囉。&lt;/li&gt;
&lt;li&gt;問題 2 : 單庫寫入量太大，導致每一次新增或更新性能非常的吃緊，感覺隨時都會上天堂。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而分表方面可以解決以下幾個問題 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;問題 3 : 單表資料量太太，導致每一次操作時都非常的慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;雖然可以解決，但是同時也會帶來以下這些鬼問題，請注意。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事務如何處理 ?&lt;/li&gt;
&lt;li&gt;Join 如何處理呢 ?&lt;/li&gt;
&lt;li&gt;用戶端要如何處理呢 ?&lt;/li&gt;
&lt;li&gt;唯一編號如何處理呢 ?&lt;/li&gt;
&lt;li&gt;分表分頁如何處理呢 ?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些問題 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;都是在分庫或分表『 前 』你就要思考好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分了後，才思考，你一定死。&lt;/p&gt;
&lt;h2 id=&#34;heading6&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://database.51cto.com/art/201809/583857.htm&#34;&gt;MySQL分库分表，写得太好了！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/KingCat666/article/details/78324678&#34;&gt;MySql从一窍不通到入门（五）Sharding：分表、分库、分片和分区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/entry/5b5eb7f2e51d4519700f7d3c&#34;&gt;MySQL 分库分表方案，总结的非常好！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/20227757&#34;&gt;MYSQL分表时需要考虑那些问题？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.scienjus.com/database-sharding-review/&#34;&gt;数据库水平分片心得&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/joylee/p/7513038.html&#34;&gt;学会数据库读写分离、分表分库——用Mycat，这一篇就够了！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://haitian299.github.io/2016/05/26/mysql-partitioning/&#34;&gt;［MySQL］MySQL分区与传统的分库分表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/38418707&#34;&gt;mysql 分区的真正作用?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/key-steps-and-likely-problems-of-split-table&#34;&gt;分库分表的几种常见形式以及可能遇到的难&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/62984253&#34;&gt;分库分表时唯一ID如何生成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/duanxz/p/6518846.html&#34;&gt;mysql分区表之一：分区原理和优缺点【转】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/guyue35/article/details/84875476&#34;&gt;业界难题-“跨库分页”的四种方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_34228662/article/details/91466678&#34;&gt;为了解决分库分表后，跨库查询和分页查询的难题，基于CQRS思想，采用es作为查询的存储中心。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5d98389a6fb9a04e1b57e126?utm_source=gold_browser_extension&#34;&gt;不要为了“分库分表”而“分库分表”&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-25之資料庫層的擴展 - 讀寫分離架構</title>
      <link>https://mark-lin.com/posts/20190925/</link>
      <pubDate>Wed, 25 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190925/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/20089358EV7pFhbCuy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;前面的文章我們說明完應用層的分散式架構以後，接下來我們要來思考如果讓『 資料庫層 』做更多的事情。&lt;/p&gt;
&lt;p&gt;在正式開始章節之前，我們先來想想看一件事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;資料庫層可以向應用層一樣加機器，就可以做更多的事情嗎 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答案為是或不是，這個就取決於使用者的能力，因為假設你沒處理好，不但有可能性能下降，而且導致錯誤百出，它不像應用層那麼簡單的主要原因在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它有狀態的，因為它有儲資料，所有會有一致性問題。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;應用層在進行分散式時，基本上都是處於無狀態狀況，所以在進行多台機器時，事實上我們不太需要考慮什麼資料一致的問題，而資料庫則否，當多台時，就要面臨到所謂的資料一致性問題。&lt;/p&gt;
&lt;p&gt;接下來的文章與章節我們將要來細說，資料庫層如何的使用分散式架構來讓它做更多的事情，並且有更高的可用性，以及它接下來要面對的種種問題。&lt;/p&gt;
&lt;p&gt;本篇文章中，咱們將要先來談談，第一種資料庫層的分散式架構方案『 讀寫分離架構 』:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它適用於讀多寫少情況&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章共分為以下幾個章節 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;讀寫分離架構概念&lt;/li&gt;
&lt;li&gt;MySQL 的讀寫分離架構實現&lt;/li&gt;
&lt;li&gt;可能面臨問題探討&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這個分散技術基本上應該是資料庫層分散的第一個起手式，單完成這個架構就已經可以處理不少的事情囉。&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;資料庫層的讀寫分離架構&lt;/h2&gt;
&lt;h3 id=&#34;heading2&#34;&gt;基本架構&lt;/h3&gt;
&lt;p&gt;讀寫分離最簡單的就是所有寫入的都寫入到一台服務，讀取時讀取一台服務，然後你們之間會進行資料同步。&lt;/p&gt;
&lt;p&gt;然後在實務上，咱們通常都是會搭配主從架構 ( master-slave ) 來進行讀寫分離。主從架構本來存在的目的是為了可用，就也是如果 master 壞掉了，咱們還有 slave 有資料。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master : 主要用寫的服務，會與 slave 進行資料同步。&lt;/li&gt;
&lt;li&gt;slave : 主要用來讀的服務&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/20089358ecnpJPA3zZ.png&#34; alt=&#34;&#34;&gt;
圖 2 : master-slave 實現讀寫概念圖&lt;/p&gt;
&lt;h3 id=&#34;heading3&#34;&gt;讀進化型架構&lt;/h3&gt;
&lt;p&gt;之前咱們有提過，現在大部份的系統基本上應該是讀大於寫入，所以如果這時只有一台讀，也是有可能會讓它壓力很大，所以這時會變成如圖 3 所示，加個幾台讀機，這種架構被稱為『 一主多從 』。&lt;/p&gt;
&lt;p&gt;然後這裡有幾個重點，那就是要如何實現圖 3 的『 分配器 』。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/20089358ibZSr9E92V.png&#34; alt=&#34;&#34;&gt;
圖 3 : 讀進化型架構圖&lt;/p&gt;
&lt;p&gt;目前基本上會有以下幾種方案。&lt;/p&gt;
&lt;h4 id=&#34;-1----ex-ha-proxy-&#34;&gt;分配器的選擇 1 - 負載均衡 ( ex. HA Proxy )&lt;/h4&gt;
&lt;p&gt;首先第一個是 haproxy，這個東西可以幫我們實現 mysql 的負載均衡，並且如果其中一台 slave 有問題，haproxy 會幫我們停止分配固障那台。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/200893587KB5idDAJt.png&#34; alt=&#34;&#34;&gt;
圖 4 : haproxy 架構&lt;/p&gt;
&lt;h4 id=&#34;-2--dns---ex-consul-&#34;&gt;分配器的選擇 2 - DNS 均衡 ( ex. Consul )&lt;/h4&gt;
&lt;p&gt;這個也是一個方案，透過 dns 來實現簡單版的負載均衡。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mark-myql-read domain
=&amp;gt; 127.0.0.1:3306
=&amp;gt; 127.0.0.1:3307
=&amp;gt; 128.0.0.1:3308
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;像使用 consul cluster 就是一個常見的方案，流程如下圖 5 所示。不過這裡簡單說一下 consul 不只可以 dns 發現服務，它事實上也有一些負載均衡的功用，有興趣的可以自已去查查。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/20089358SUSBNMI2Qh.png&#34; alt=&#34;&#34;&gt;
圖 5 : consul&lt;/p&gt;
&lt;h4 id=&#34;---slave--master--&#34;&gt;那這裡問個問題 ~ 要如何指定讀 Slave 寫 Master 呢 ?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;通常大部份所使用的操作套件都有資源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以 nodejs 來常使用 mysql orm 套件 sequelize，它可以給你進行如下官方範例的設定，當 read 時可以指定讀 slave 那台，當 write 的可以指定寫入那台。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sequelize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Sequelize&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;database&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;, {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;dialect&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mysql&amp;#39;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;port&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3306&lt;/span&gt;
  &lt;span style=&#34;color:#a6e22e&#34;&gt;replication&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; [
      { &lt;span style=&#34;color:#a6e22e&#34;&gt;host&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;8.8.8.8&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;username&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;read-username&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;password&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;some-password&amp;#39;&lt;/span&gt; },
      { &lt;span style=&#34;color:#a6e22e&#34;&gt;host&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;9.9.9.9&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;username&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;another-username&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;password&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; }
    ],
    &lt;span style=&#34;color:#a6e22e&#34;&gt;write&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;host&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1.1.1.1&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;username&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;write-username&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;password&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;any-password&amp;#39;&lt;/span&gt; }
  },
  &lt;span style=&#34;color:#a6e22e&#34;&gt;pool&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; { &lt;span style=&#34;color:#75715e&#34;&gt;// If you want to override the options used for the read/write pool you can do so here
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;idle&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30000&lt;/span&gt;
  },
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而如果是使用 php laravel 的友人它也有提供相關的設定。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://laravel.com/docs/5.5/database#read-and-write-connections&#34;&gt;Laravel-Read &amp;amp; Write Connections&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;mysql&#39; =&amp;gt; [
    &#39;read&#39; =&amp;gt; [
        &#39;host&#39; =&amp;gt; &#39;192.168.1.1&#39;,
    ],
    &#39;write&#39; =&amp;gt; [
        &#39;host&#39; =&amp;gt; &#39;196.168.1.2&#39;
    ],
],
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根據以上兩種語言套件，事實上咱們真的已經不太需要自已來實現讀寫分離的程式碼了。&lt;/p&gt;
&lt;h2 id=&#34;mysql-&#34;&gt;MySQL 主從架構實現原理&lt;/h2&gt;
&lt;p&gt;mysql 基本上實現主從架構資料交換的過程，如下圖 6 所示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;master 把資料更新寫到 binary log 中。&lt;/li&gt;
&lt;li&gt;slave 將 master 的 binary log 複製到自已的 replay log。&lt;/li&gt;
&lt;li&gt;讀取 replay log，將資料異動進行更新。&lt;/li&gt;
&lt;li&gt;slave 的 sql thread 去 replay log 拉資料來執行 sql。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/200893584JiOTRK0HN.png&#34; alt=&#34;&#34;&gt;
圖 6 : mysql 的主從複製&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 ~&lt;/strong&gt;
mysql 本身沒有支援所謂的 failover 機制，failover 就是當發現 master 掛掉時，會自動將 slave 升級為 master 來接客的自動化機制。&lt;/p&gt;
&lt;p&gt;在 mysql 中需要一些 failover 實現的工具才能使用，例如 MHA ( Master High Availability )、Keepalived、PXC 等，這裡就不多談這些囉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;這裡問個問題 binlog 是什麼呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它記錄了所有 mysql 資料上的改變，也就是說你只要 insert 或 update 都會記錄在 binlog 中。&lt;/p&gt;
&lt;p&gt;但是要注意 binlog 是屬於 mysql 服務層的東西，也就是說不管底層儲存引擎是 inoodb 或 mysiam 啥的，binlog 都是有儲的。&lt;/p&gt;
&lt;p&gt;你可以在 mysql 中指令以下指令，來看到 binlog 的事件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SHOW&lt;/span&gt; binlog events;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那 binlog 可以做什麼用呢 ?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主從複製&lt;/li&gt;
&lt;li&gt;資料回復&lt;/li&gt;
&lt;li&gt;增加備份&lt;/li&gt;
&lt;li&gt;最終一致性 ( 這在之後會說明 )&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading4&#34;&gt;三種複制模式&lt;/h3&gt;
&lt;p&gt;在 mysql 中它有分三種資料從 master 複制到 slave 的模式，至於為什麼有這三個模式，等等下個章節讀寫分離問題那會說。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先說一下這三種模式，會影響到用戶端收到 ack 的時間&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;-1--async-mode------&#34;&gt;複制模式 1 : Async Mode ( 性能優 ) ( 預設 )&lt;/h4&gt;
&lt;p&gt;預設模式，流程如下圖 7 所示，重點在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;master 寫到 binlog 後就回 ack 給 client&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/20089358VYOWxjdPLR.png&#34; alt=&#34;&#34;&gt;
圖 7 : async Mode 模式&lt;/p&gt;
&lt;h4 id=&#34;-2--semisync-mode---&#34;&gt;複制模式 2 : Semi-sync Mode ( 性能中 )&lt;/h4&gt;
&lt;p&gt;其中一台 slave 寫到 replay log 後，就會回 ack，如下圖 8 所示。這個模式是使用 GTID 所實現，只有在 mysql 5.7+ 以上才支援，這種模式的重點在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;寫到其中一台 slave 的 replay log 後，master 才會回 ack 給 client。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/20089358NhIqrsOu3l.png&#34; alt=&#34;&#34;&gt;
圖 8 : semi-sync Mode 模式&lt;/p&gt;
&lt;h4 id=&#34;-3-sync-mode---&#34;&gt;複制模式 3. Sync Mode ( 性能差 )&lt;/h4&gt;
&lt;p&gt;如下圖 9 所示。這種模式性能最差，但是可以保證所有用戶都讀到相同的資料。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有 slave 都將資料寫到 replay log 後，master 才會回 ack 給 client，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/200893588X3Tq8gQFv.png&#34; alt=&#34;&#34;&gt;
圖 9 : sync Mode 模式&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;讀寫分離可能面臨問題探討&lt;/h2&gt;
&lt;p&gt;這種架構可能會碰到什麼問題呢 ?&lt;/p&gt;
&lt;h3 id=&#34;-1--&#34;&gt;問題 1 . 主從資料不一致問題&lt;/h3&gt;
&lt;p&gt;假設咱們有個業務操作如下 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更新 x 資料&lt;/li&gt;
&lt;li&gt;讀取 x 資料&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如下面這張圖 10 所示，當操作 1 執行更新 x 後，執行操作 2 讀取，如果這時還沒主資料庫資料還沒同步到從資料庫，那操作 2 就會讀到舊的資料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/20089358Fm7oZTdhc6.png&#34; alt=&#34;&#34;&gt;
圖 10 : 讀取時可能碰到的問題&lt;/p&gt;
&lt;p&gt;通常碰到這問題只有以下幾種解法。&lt;/p&gt;
&lt;h4 id=&#34;-1---mysql-sync-model&#34;&gt;解法 1 : 開啟 mysql sync model&lt;/h4&gt;
&lt;p&gt;也就是說所有的寫入或更新，都需要等到複製完，才能回用戶 ack。但這個性能耗損很嚴重呢。不過還有一種折衷方案就是改成用上述複制模式 2 semi-sync Mode 模式，雖然還是會發生資料不同步的機率，但機率低了不少。&lt;/p&gt;
&lt;h4 id=&#34;-2--&#34;&gt;解法 2 : 用戶端寫入後等幾秒再讀&lt;/h4&gt;
&lt;p&gt;這個方法應該是最常見的手法，我問十個人應該有九個都是用這招。&lt;/p&gt;
&lt;h4 id=&#34;-3--&#34;&gt;解法 3 : 應用層中間件動手腳&lt;/h4&gt;
&lt;p&gt;在一些比較大型的應用上，通常會將架構分成如下 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用戶 -&amp;gt; 應用層服務 -&amp;gt; 應用層中間件 -&amp;gt; 資料庫服務
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中應用層中間件服務，這個不同公司有不同的定義與實作方法，像咱公司這裡裡面又分為兩塊。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;應用層 domain 服務 -&amp;gt; 應用層 model 服務
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 domain 比較偏向商業定義，而 model 偏向資料庫定義，然後這時咱們會針定一些商業上定義需要完全一致性的操作，強制的讓它讀 master。&lt;/p&gt;
&lt;p&gt;這樣的確是有人說，那這樣不就沒有讀寫分離的意義 ? 一半對一半錯，如果只有 10 % 商業服務是需要這種『 完全一致性 』的要求，那也只有 10 % 而以，其它 90 % 還是有讀寫分離。而如果反過 90% 需要的場景，你反而要想那這樣還要搞讀寫分離嗎 ?&lt;/p&gt;
&lt;h3 id=&#34;-2--1&#34;&gt;問題 2 : 讀寫分離模式與緩存服務不一致問題&lt;/h3&gt;
&lt;p&gt;根據咱們下述的緩存策略的文章中，咱們的讀策略為 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先更新 DB 後淘汰緩存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20190919/&#34;&gt;30-19 之資料庫層的優化 - 資料緩存策略&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然後咱們接下來和讀寫分離架構合在一起看一下。然後會發現它有問題。&lt;/p&gt;
&lt;p&gt;這個問題如下圖 11 過程所示，當操作 1 在淘汰完緩存資料後，且在同步從庫前，有一個讀取進來，那這時它會讀取到舊的資料，並且更新到緩存中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那這時緩存就會永遠是『 錯 』的資料 ( 除非人為手動回復 )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/20089358xaxjurBmyA.png&#34; alt=&#34;&#34;&gt;
圖 11 : 讀寫分離架構的緩存不一致性問題&lt;/p&gt;
&lt;h4 id=&#34;-1--1&#34;&gt;解法 1 : 多一次讀取&lt;/h4&gt;
&lt;p&gt;目前查了一下，比較常見的解法如下圖 12 所示，就是在淘汰緩存後，在執行一次讀取，然後強制這次的讀取是讀『 主庫 』，這樣可以有較高的機率回避上述問題。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/20089358Ljc8M0AprH.png&#34; alt=&#34;&#34;&gt;
圖 12 : 不一致性問題解法 1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;為什麼不要將淘汰緩存，改為更新緩存呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因為這樣在併發更新時，可能會產生『 緩存永遠是錯的 』可能性，詳細請參考 30-19 的文章。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果操作 2 的讀取從庫比操作 1 的讀取主庫還前，那不是也有問題嗎 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嗯對的，會出問題沒錯，但只能說機率會比較小點兒。&lt;/p&gt;
&lt;h3 id=&#34;-2--2&#34;&gt;解法 2 : 重複一次操作&lt;/h3&gt;
&lt;p&gt;就是再重複的進行一下更新操作流程，如下圖 13 所示，就算操作 2 讀取時將舊資料更新的緩存後，這個錯誤的操作會被第二次更新時洗掉，除非你真運氣差到兩次都碰上，不然這個出問題的機率應該是非常非常的低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191010/20089358z66xEdyQlB.png&#34; alt=&#34;&#34;&gt;
圖 13 : 不一致問題解法 2&lt;/p&gt;
&lt;h3 id=&#34;-3--binlog-&#34;&gt;可能解法 3 : binlog 訂閱&lt;/h3&gt;
&lt;p&gt;先說一下，我不確定這個方法可不可以解決，這只是提出來參考兩下的。&lt;/p&gt;
&lt;p&gt;目前網路上有提供一些工具，它可以監控 binlog 的變化，來更新緩存服務，例如阿里八八開發的這個工具。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/alibaba/canal&#34;&gt;canal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是有沒有什麼雷我就不知道了，之後應該會來深入的研究兩下。&lt;/p&gt;
&lt;h2 id=&#34;heading6&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章咱們探討了資料庫擴展的第一個起手式 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;讀寫分離架構&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然後在 mysql 中基本上它是以主從架構來實現，然後它實現兩台資料庫資料同步的方法主要是依賴於 binlog 上，而其中它的整個複制的模式，也影響了用戶收到回應時間速度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;複制模式 1 : Async Mode ( 性能優 ) ( 預設 )&lt;/li&gt;
&lt;li&gt;複制模式 2 : Semi-sync Mode ( 性能中 )&lt;/li&gt;
&lt;li&gt;複制模式 3. Sync Mode ( 性能差 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最後咱們討論了讀寫分離的以下兩個問題 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主從資料不一致問題&lt;/li&gt;
&lt;li&gt;讀寫分離模式與緩存服務不一致問題&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述兩個問題說實話，都沒完美解，這或許就是追求性能的路上必然之路。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一致性難題&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這也是為啥會建議，沒必要，真的別搞分散式，你真的會被一致性難題搞的心力交瘁，如果沒問題，你先想想有沒有可能能事實上量很小到產生不了問題呢 ?&lt;/p&gt;
&lt;h2 id=&#34;heading7&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/19719997&#34;&gt;MySQL 对于千万级的大表要怎么优化？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/entry/58f9fb295c497d0058ee2db7&#34;&gt;MySQL 读写分离技术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/33504555&#34;&gt;腾讯工程师带你深入解析 MySQL binlog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mysql.taobao.org/monthly/2015/05/10/&#34;&gt;MySQL · 答疑解惑 · binlog 位点刷新策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mysql.taobao.org/monthly/2015/05/&#34;&gt;数据库内核月报 － 2015 / 05&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/68226751&#34;&gt;MySQL binlog应用场景与原理深度剖析！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://arganzheng.life/mysql-ha-solution.html&#34;&gt;MySQL高可用性方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/50597960?edition=yidianzixun&amp;amp;utm_source=yidianzixun&amp;amp;yidian_docid=0KelGY6s&amp;amp;yidian_s=&amp;amp;yidian_appid=s3rd_op397&#34;&gt;深度探索MySQL主从复制原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/mysql-tools/wiki/Semi-Sync-Replication-Design&#34;&gt;Semi Sync Replication Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/550045&#34;&gt;使用canal进行mysql数据同步到Redis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-17 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 2 )</title>
      <link>https://mark-lin.com/posts/20190917/</link>
      <pubDate>Tue, 17 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190917/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/200893583XNdu76MIf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;上一章節咱們學習到了，在並行情況下 mysql 可能會發生什麼樣的資料不一致問題，並且也學習到了這些問題它又是如何解決。&lt;/p&gt;
&lt;p&gt;雖然 innodb 已經儘可能的解決上述這些問題，但是如果要完全解決，性能代價太大，因此後來有了一些折衷方案，這個東西就叫做 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事務隔離級別&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下來本篇文章將要談談這東西，並且整理一下 innodb 預設的一些鎖的設定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 的折衷解法 - 事務隔離級別&lt;/li&gt;
&lt;li&gt;預設 RR 級別 - 鎖的操作總結&lt;/li&gt;
&lt;li&gt;死鎖的小分析&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mysql---&#34;&gt;MySQL 的折衷解法 - 事務隔離級別&lt;/h2&gt;
&lt;p&gt;資料庫在並行運行時，通常會發生以下幾種問題，並且也探討過這幾種問題的解法 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新不一致 : 鎖&lt;/li&gt;
&lt;li&gt;髒讀、不可重複讀 : mvcc&lt;/li&gt;
&lt;li&gt;幻讀 : mvcc + next-key locking ( 有一些幻讀情境無解 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在 innodb 事實上可以『 完全簡單 』的處理上面幾種現象，解決方法如下圖 5 所示，也就是同一個時間，只能執行同一個事務，如下圖所示。也就是把發生問題的根本原因『 並行 』給移除。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191002/20089358u3mS3nHFla.png&#34; alt=&#34;&#34;&gt;
圖 1 : 一致性的根本解法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但這會嚴重的影響到效能的問題，因此才有了『 隔離層級 』這東西。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;隔離層級可以讓你決定需要處理到什麼層級的一致性問題&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是說上面四個問題，它可以讓你根據性能的要求，來決定你要處理幾個問題，處理的越多代表性能越差，處理越少個則代表性能越好，但反之不一致性機率更高。&lt;/p&gt;
&lt;h3 id=&#34;heading1&#34;&gt;事務隔離級別&lt;/h3&gt;
&lt;p&gt;mysql 總共提供以下四個層級，不過比較準確的說，這是所有資料庫共有的層級，性能從高至低排序，而反之資料一致性性由低至高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read Uncommitted ( RU )&lt;/li&gt;
&lt;li&gt;Read Committed ( RC )&lt;/li&gt;
&lt;li&gt;Repeatable Read ( RR ) ( 預設 )&lt;/li&gt;
&lt;li&gt;Serializable&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它們可以解決的難題如下列表，其中有個地方要注意一下，那就是 RR 級別的幻影讀解決，在 innodb 只能算是部份解決，不能說完解，上一章節幻讀情境 3 就是無法解。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;更新不一致&lt;/th&gt;
&lt;th&gt;髒讀&lt;/th&gt;
&lt;th&gt;不可重複讀&lt;/th&gt;
&lt;th&gt;幻影讀&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;read uncommitted&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;read committed&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;repeatable read&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v or ?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;serializable&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 1 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在大部份的資料庫世界中，都有用這個事務隔離級別來處理以上幾個難題，但比較不同的在於 mysql 預設是使用 repeatable read ( RR ) 來當預設，而其它資料庫例如 orcale、ms sql server 是使用 read committed ( RC ) 來當預設。&lt;/p&gt;
&lt;p&gt;會有這樣的差別在於，RC 級別所會碰到的『不可重複讀』問題事實上還算可以接受。因為它是讀到已經 commit 的資料。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 2 ~&lt;/strong&gt;
你可以執行以下 sql 來看看你系統的隔離層級&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SHOW VARIABLES LIKE &#39;%transaction_isolation%&#39;;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;~ 小知識 3 ~&lt;/strong&gt;
你可以執行以下指令來修改隔離級別，但是你要很明確的知道，如果降低或增加級別可能會產生的風險。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SET SESSION TRANSACTION ISOLATION LEVEL {level};

Ex.
SET SESSION TRANSACTION ISOLATION LEVEL read committed;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;-rr---&#34;&gt;預設 RR 級別 - 鎖的操作總結&lt;/h2&gt;
&lt;p&gt;innodb 基本上它的預設為 repeatable read (RR)，咱們要在這裡總結一下，在這個級別的所有操作預設是會如何處理，如何的上鎖。&lt;/p&gt;
&lt;h3 id=&#34;-1--&#34;&gt;小總結 1 : 基本操作加鎖總結&lt;/h3&gt;
&lt;h4 id=&#34;select-&#34;&gt;Select 重點&lt;/h4&gt;
&lt;p&gt;select 有三個重點要記得 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select 預設不會加上任何鎖。&lt;/li&gt;
&lt;li&gt;select 時，它會使用快照讀，也就是說會讀取事務開始前的最新一個 commit 版本，即時其它事務有上鎖，它仍然不會被卡住，而會讀取舊版本資料 ( 備 1 )。&lt;/li&gt;
&lt;li&gt;select 不會讀取到另一個事務『 已 commit 』或是『 未 commit 』的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中解釋一下第二點，如下圖 2 所示，事務 b 的 select 操作都不會被卡住，原因在於有 mvcc 機制，它讀取時都會讀，事務開始前的最新一個版本。&lt;/p&gt;
&lt;p&gt;那有人會問，事務 a 不是在 update 時會上鎖嗎 ? 那不是應該不能有人讀嗎 ? nono ~ 不是的&lt;/p&gt;
&lt;p&gt;它上是有上鎖，它上的鎖是所謂的『 排它鎖 』，它不是指上了就不讓人讀，而是上了，別人無法在加鎖，而由於 select 本身不加任何鎖，所以 ok 可以讀。等等後面有這鎖更詳細的說明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191002/20089358v9u8YvmwRz.png&#34; alt=&#34;&#34;&gt;
圖 2 : select 在 rr 級別不會卡&lt;/p&gt;
&lt;h4 id=&#34;updateinsertdelete-&#34;&gt;Update、Insert、Delete 重點&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;預設在進行上述操作時，如果有使用『 索引 』，會上『 行 』鎖，沒有則上『 表 』鎖。&lt;/li&gt;
&lt;li&gt;預設這些操作會上『 排它鎖 』，等等下面有解釋。&lt;/li&gt;
&lt;li&gt;這些操作都會更新 mvcc 的版本號，也就是每次執行時，會將修改的變成最新版本。&lt;/li&gt;
&lt;li&gt;在 RR 級別它們都是『 當前讀 』，也就是會讀取最新版本的資訊。&lt;/li&gt;
&lt;li&gt;有範圍的操作會上範圍鎖。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;~ 小備註 1 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述操作看起來和 select 沒啥關係，但實際上是會隱性的用到 select，例如上述當前讀操作的 update 或 delete 它們實際上會用 select 先去找找要修改的欄位在不在，而這時它用的就是『 當前讀 』，也就是直接取得最新版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小備註 2 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;關於上述提到的『 mvcc 』與『 當前讀 』什麼的可以連到前一篇文章來看看，傳送門如下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10223427&#34;&gt;30-16 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 1 )&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;-2--select-&#34;&gt;總結 2 : Select 手動加鎖的總結&lt;/h3&gt;
&lt;p&gt;上面是基本 select 的行為，它預設不上鎖。&lt;/p&gt;
&lt;p&gt;但是 mysql 有提供兩種方法可以給我們手動在 select 上鎖。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select xxx lock in share mode ( 共享鎖 )&lt;/li&gt;
&lt;li&gt;select xxx for update ( 排它鎖 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中要注意，它們兩個上的鎖是不同的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享鎖 ( 讀鎖、S 鎖 ) : 不允許其它事務進行修改，且其它事務可以上『 共享鎖 』。&lt;/li&gt;
&lt;li&gt;排它鎖 ( 寫鎖、X 鎖 ) : 不允許其它事務進行修改，且其它事務不能上鎖 ( 排它或共享 )。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共享鎖當執行以下範例時會被卡住 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- 範例 1 --

事務 A
(1) SELECT * FROM user WHERE  age = 20 LOCK IN SHARE MODEL; ( 上共享鎖 )
事務 B
(2) UPDATE user SET name = &#39;mark&#39; WHERE age = 20; ( 想加排它鎖，會失敗卡住 )

-- 範例 2 --

事務 A
(1) SELECT * FROM user WHERE age = 20 LOCK IN SHARE MODEL; ( 上共享鎖 )
事務 B
(2) SELECT * FROM user WHERE age = 20 FOR UPDATE; ( 想加排它鎖，會失敗卡住 )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而當上排它鎖時，以下幾個範例會被卡住。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
-- 範例 1 --
事務 A
(1) SELECT * FROM user WHERE age = 20 FOR UPDATE ( 上排它鎖 );
事務 B
(2) UPDATE user SET name = &#39;mark&#39; WHERE age = 20; ( 想加排它鎖，會失敗卡住 )

-- 範例 2 --
事務 A
(1) SELECT * FROM user WHERE age = 20 FOR UPDATE ( 上排它鎖 );
事務 B
(2) SELECT * FROM user WHERE age = 20 FOR UPDATE; ( 想加排它鎖，會失敗卡住 )

-- 範例 3 --
事務 A
(1) SELECT * FROM user WHERE age = 20 FOR UPDATE ( 上排它鎖) ;
事務 B
(2) SELECT * FROM user WHERE age = 20 LOCK IN SHARE MODEL; ( 想加共享鎖，會失敗卡住 )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根據上幾個範例可以整理出下述這張表，它的 ok 表示可以上鎖成功。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;排它&lt;/th&gt;
&lt;th&gt;共享&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;排它&lt;/td&gt;
&lt;td&gt;失敗&lt;/td&gt;
&lt;td&gt;失敗&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;共享&lt;/td&gt;
&lt;td&gt;失敗&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注意事項&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最後手動加鎖有個注意事項，如果是查詢條件為範圍的如下範例，那它的鎖會變成範圍的，也就是會不會只鎖單行，而會鎖某個範圍的行數。( next-key locking 上篇有說 )。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM user WHERE age &amp;gt; 20 FOR UPDATE;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;-3--&#34;&gt;總結 3 : 表鎖與意向鎖的總結&lt;/h3&gt;
&lt;p&gt;上面有提到，如果有一段操作沒有命中索引，那它就會變成表鎖，例如下面範例 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE user SET name = &#39;mark&#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同時上面還是有提到，如果在進行 update 時會針對『 行 』上『 排它鎖 』，但是這種情況會變成將『 表 』上『 排它鎖 』。&lt;/p&gt;
&lt;p&gt;但是這裡有一個問題，那就是如果這張表要上『 排它鎖 』，那前提就是這張表裡面『 不能有上排它鎖的行 』，對吧 ? 不可能會在已經上排它鎖的，在上一次吧 ?&lt;/p&gt;
&lt;p&gt;所以在上鎖前，可能就會去那張表一行一行慢慢找有沒有上鎖，但是用小腦袋想想，你覺得有可能這樣做嗎 ? 一行一行慢慢找，會找到天荒地老的。&lt;/p&gt;
&lt;p&gt;也因為這個問題，所以就有了所謂的『 意向鎖 』機制。&lt;/p&gt;
&lt;p&gt;它的上鎖機制如下 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;當在表中的某一行上了鎖 ( 排它或共享 )。&lt;/li&gt;
&lt;li&gt;在表上加『 意向鎖 』。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然後當要上表鎖時它的運行如下 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;去表上看看有沒有『 意向鎖 』。&lt;/li&gt;
&lt;li&gt;有，就代表表內某一行有上鎖，所以無法上表鎖，卡住。&lt;/li&gt;
&lt;li&gt;無，上表鎖。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;heading2&#34;&gt;死鎖的小分析&lt;/h2&gt;
&lt;p&gt;接下來咱們要來簡單的談談『 死鎖 』的問題，它的定義如下 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;兩個事務或以下，因爭搶『 鎖 』資源，而產生的『 相互 』等待行為。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;白話文就是，我在等你完成，你也在等我完成，結果兩個人都等到天荒地老。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 ~&lt;/strong&gt;
死鎖只會出現在 RR 級別以下，如果是在 serializable 級別是不會發生的，因為它就是一個一個完成，它們要搶啥呢 ?&lt;/p&gt;
&lt;h3 id=&#34;heading3&#34;&gt;死鎖的情況範例&lt;/h3&gt;
&lt;p&gt;下述為最明顯的例子，事務 A 與 事務 B 的更新操作都在等對方釋方鎖，不過在 innodb 中碰到這種死鎖時，它會在事務 A 的更新 ( 最後更新 ) 的操作，會產生錯誤訊息，並且會進行回滾，所以嚴格來說不會一直鎖到天荒地老。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191002/200893581GmNLUtZIn.png&#34; alt=&#34;&#34;&gt;
圖 3 : 死鎖範例&lt;/p&gt;
&lt;p&gt;順到說一下，如果真的碰到這種死鎖錯誤訊息時，可以執行以下執令來看看詳細的狀況，來理解這個死鎖是如何產生的，雖然說會 rollback，但也代表這個操作是失敗了，所以還是要理解一下原因。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SHOW ENGINE INNODB STATUS
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading4&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章學習了不少會讓人頭昏的東西，咱們來總結一下。&lt;/p&gt;
&lt;h4 id=&#34;heading5&#34;&gt;事務隔離級別&lt;/h4&gt;
&lt;p&gt;基本上有提供以下幾個級別，由上往下，從輕到重，越重的隔離級別性能越差，但相對的一致性問題越少。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;read uncommitted ( RU )&lt;/li&gt;
&lt;li&gt;read committed ( RC )&lt;/li&gt;
&lt;li&gt;repeatable read ( RR ) ( 預設 )&lt;/li&gt;
&lt;li&gt;serializable&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;-rr-&#34;&gt;預設 RR 級別的操作總結&lt;/h4&gt;
&lt;p&gt;這裡基本上還是請拉到上面看，然後這裡的學習重點就是，你要很清楚的知道，不同的操作指令，在 RR 實際上它是上了什麼鎖，懂了這些基本上就很夠了，因此這樣基本上你就有很高的機率可以避開一直等待鎖所浪費的時間。&lt;/p&gt;
&lt;h4 id=&#34;heading6&#34;&gt;一些死鎖的探討與分析&lt;/h4&gt;
&lt;p&gt;這裡簡單的學習一些可能會碰到死鎖的場景，但大部份的情況碰到都會 rollback，但實嚴謹一點還是要去查查死鎖原因是什麼。&lt;/p&gt;
&lt;h4 id=&#34;acid-&#34;&gt;ACID 的小關連&lt;/h4&gt;
&lt;p&gt;最後一致性的難題在這個章節就差不多結束了，而到了這裡事實上咱們就全部理解了 mysql innodb 它是如何實現事務的 ACID。&lt;/p&gt;
&lt;p&gt;而本章節與上章節所介紹的併發一致性問題與解法，ACID 中的實現 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔離性 Isolation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而包含在 30-15 的文章所提到固障問題的兩個事務特性 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性 Atomic&lt;/li&gt;
&lt;li&gt;持久性 Durability&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這三個完成，才能符合 ACID 的最後一個特性 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性 consistency&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以事實上咱們可以說 ACID 四個特性關係如下 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一致性 = 原子性 + 持久性 + 隔離性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要完成後面三個，才能說這個事務有一致性的特性。&lt;/p&gt;
&lt;h3 id=&#34;heading7&#34;&gt;最後的心得&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20190915/&#34;&gt;30-15 之資料庫層的難題 - 單機『 故障 』一致性難題&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20190916/&#34;&gt;30-16 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 1 )&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;30-17 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 2 ) ( 本篇文章 )&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;從以上三篇文章探討一致性的難題文章，事實上已經可以理解，併發事實上是非常複雜與難處理的事情，它所產生的資料不一致性的情境非常多種，而如果這個情境又提升到分散式系統或資料庫上的話，其難度真的非常高非常高。&lt;/p&gt;
&lt;p&gt;這裡良心的建議 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;真的不要有事沒事為了『 性能 』而『 分散式 』，單機併發不一致性的情境都搞不清楚的情況，升到分散式資料庫會死的很慘，如果還沒死，那也有可能是因為你性能事實上根本不需要到『 分散式 』。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;heading8&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/70701037&#34;&gt;MYSQL事务和隔离级别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/33189897&#34;&gt;常用的分布式事务解决方案介绍有多少种？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/52098102&#34;&gt;MySQL事务ACID实现详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/66676020&#34;&gt;MySQL探秘(七):InnoDB行锁算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-16 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 1 )</title>
      <link>https://mark-lin.com/posts/20190916/</link>
      <pubDate>Mon, 16 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190916/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/200893583XNdu76MIf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;本篇文章中，咱們要說說另一種資料不一致性產生的場景，那就是 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;『 並行 』產生的不一致性難題&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上並行所產生的不一致性難題，可以分為以下幾種類型 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新不一致&lt;/li&gt;
&lt;li&gt;髒讀&lt;/li&gt;
&lt;li&gt;不可重讀&lt;/li&gt;
&lt;li&gt;幻讀&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇將會分為以下幾個章節來談談這幾個難題 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新不一致難題與解法 - 鎖&lt;/li&gt;
&lt;li&gt;髒讀與不可重讀難題與解法 - MVCC&lt;/li&gt;
&lt;li&gt;幻讀難題與解法 - MVCC + Next-Lock 鎖&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;--&#34;&gt;更新不一致難題與解法 - 鎖&lt;/h2&gt;
&lt;p&gt;這種情境如下圖 1 所示，a 與 b 兩個事務進行更新操作後，事務 a 再看看自已操作的結果，發現自已的更新消失了。這種情境被稱為『 更新不一致問題 』&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191001/20089358EusE2oGPCM.png&#34; alt=&#34;&#34;&gt;
圖 1 : 更新不一致問題&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那這種情境 innodb 它是如何處理呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它使用鎖來處理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 innodb 的預設，它會對要『 update、delete 』的『 行加鎖排他鎖 』，不過比較嚴格定義應該是說 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它會對有用到『 索引 』的『 行 』加『 排他鎖 』，不然會退化成『 表 』鎖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先來說一下，所謂的排他鎖定義如下 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;排它鎖 ( X 鎖、寫鎖 ) 它保證同一個時刻，只有上鎖的那個事務可以進行修改，其它事務都無法在上鎖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然後咱們接這來看看使用鎖來處理更新不一致問題的流程。當有兩個事務運行更新時，它會變成如下圖這樣，當事務 A 要更新 account 時，它會被上個排它鎖，而這時事務 B 只能等到事務 A commit 後，才能修改在 commit，因為排它鎖就是不能在上鎖，所以事務 b 如果想在上個排它鎖是不行的 ( update 會上排它鎖 ) 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191001/20089358stsiWKwcPW.png&#34; alt=&#34;&#34;&gt;
圖 2 : 使用鎖解決更新不一致問題&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 1 ~&lt;/strong&gt;
鎖這個概念在任何只要有併行概念的地方都會看到，包含我們前面提到的多線程，更廣範的說，只要在電腦科學上，鎖這個東西無所不在。寫過 java 的友人應該很有感。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 2 ~&lt;/strong&gt;
select 正常來說是什麼鎖都沒加，正常時。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小備註 ~&lt;/strong&gt;
鎖的詳細知識下一篇文章中會更詳細說明。&lt;/p&gt;
&lt;h3 id=&#34;heading1&#34;&gt;實務上的更新不一致問題&lt;/h3&gt;
&lt;p&gt;在實務上咱們有時後會發生下述的情境 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事務 A 抓取 X 貨物數量。&lt;/li&gt;
&lt;li&gt;事務 B 抓取 X 貨物數量。&lt;/li&gt;
&lt;li&gt;用戶 A 將 X 貨物數量 - 1000 後，更新資料庫。&lt;/li&gt;
&lt;li&gt;用戶 B 將 X 貨物數量 - 2000 後，更新資料庫。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;轉成成 sql 來看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;事務 A

BEGIN;
SELECT count INTO @count FROM product WHERE id = x;
...
UPDATE count SET count = @count - 1000 WHERE id = x;
COMMIT;


事務 B
BEGIN;
SELECT count INTO @count FROM product WHERE id = x;
...
UPDATE count SET count = @count - 2000 WHERE id = x;
COMMIT;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不處理會發生什麼事情呢 ? 那就是事務 a 與 b 更新完後，結果是錯誤。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;count 預設 3000

預期情境 : 
事務 a -&amp;gt; 事務 b -&amp;gt; 結果 count = 0

出問題情境 :
事務 a
       -&amp;gt; 結果 count = 1000 ( 因為 a、b 都抓到 3000 後在減，而 a 比 b 快完成 )
事務 b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這種情況要怎麼如何處理呢 ? 由於中間還有一些業務處理，需要改改修修 select 出來的 count，而上面也有提到，正常的情況下 select 是不加鎖的，因此這時就有以下解法 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;for update 強制將 select 操作加上『 排它鎖 』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;將 select 指令改成如下 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT count INTO @count FROM product WHERE id = x FOR UPDATE
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就可以強制在這行上面加『 排他鎖 』，這樣事務 b 就只能等到這個鎖被釋放才能進行更新，這樣就可以確保在同一個時間，只有事務 a 可以進行更新。&lt;/p&gt;
&lt;p&gt;還有別忘了，如果你沒有使用到索引，這個也會變成表鎖。&lt;/p&gt;
&lt;h2 id=&#34;--mvcc&#34;&gt;髒讀與不可重讀難題與解法 - MVCC&lt;/h2&gt;
&lt;h4 id=&#34;heading2&#34;&gt;髒讀情境&lt;/h4&gt;
&lt;p&gt;這種情境如下圖 3 所示，a 事務進行更新，然後 b 事務再進行抓取欄位，但是 a 事務最後回滾，導致 b 事務抓到的資料是有問題的。這種情境被稱為『 髒讀問題 』&lt;/p&gt;
&lt;p&gt;髒讀簡單的定義為 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A 事務可能會讀取到 B 事務『 未提交 』的資料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191001/20089358Ivx5wWFFxf.png&#34; alt=&#34;&#34;&gt;
圖 3 : 髒讀情境&lt;/p&gt;
&lt;h4 id=&#34;heading3&#34;&gt;不可重複讀情境&lt;/h4&gt;
&lt;p&gt;不可重複讀這個問題本質在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A 事務可能會讀取到 B 事務『 已提交 』的資料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191001/20089358nXj0ilyZBJ.png&#34; alt=&#34;&#34;&gt;
圖 4 : 不可重複讀情境&lt;/p&gt;
&lt;h3 id=&#34;heading4&#34;&gt;傳統有性能問題解法&lt;/h3&gt;
&lt;p&gt;當 a 事務要讀取某行時，會將它上鎖，直到 a 事務提交後，b 事務才能處理，這樣正常來說，的確不會發生 a 事務可能讀取到 b 事務已提交的資料，因為同一個時間，只有一個事務能讀那行。&lt;/p&gt;
&lt;p&gt;這樣來看不論是髒讀或不可重讀問題，的確是都可以解。&lt;/p&gt;
&lt;p&gt;但是上述這種機制的缺點就在於性能，因為要一個等一個。所以後來就誕生出另一種機制，就是所謂的
『 MVCC (Multi-Version Concurrency Control) 』。&lt;/p&gt;
&lt;h3 id=&#34;-mvcc--multiversion-concurrency-control-&#34;&gt;性能較優的解法 MVCC ( Multi-Version Concurrency Control )&lt;/h3&gt;
&lt;p&gt;它的白話文為 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;對資料庫的何任修改與提交都不會覆蓋掉原本的資料，而是會產生不同的版本分支。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MVCC 實際上是通常在每一行記錄後面保存兩個『 隱藏列 』來實現，這兩列保存以下的事項 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行的創建時間 ( 它存的不是實際時間，而是有時間順序性的版號 )&lt;/li&gt;
&lt;li&gt;行的過期或刪除時間 ( 同上為有時間順序性的版號 )。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在這個裡可以簡單的想成這種概念。當 a 事務讀取 x 行時，不用上鎖，而是讀取 x 行的 v1 版本，而就算後來事務 b 來更新 x 行時，它修改後會新增個 v2 版本，這樣就不會和事務 a 打架。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MVCC 的精華就在於使用版本來代替鎖來處理並行問題&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而上面有提到版本問題，而這個版本問題大部份都是讀取時來決定要選什麼版本，而這時根據選擇版本方法又分為以下兩個 :&lt;/p&gt;
&lt;h4 id=&#34;heading5&#34;&gt;快照讀與當前讀&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;快照讀 : 取得事務開始前的最新的版本的行。&lt;/li&gt;
&lt;li&gt;當前讀 : 取得最新的版本的行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;快照讀操作如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;當前讀操作如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select xxx lock in share mode&lt;/li&gt;
&lt;li&gt;select xxx for update&lt;/li&gt;
&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述兩個雖然都是以 select 為基本情境，但實際上在某些操作中，實際上是會隱性的用到 select，例如上述當前讀操作的 update 或 delete 它們實際上會用 select 先去找找要修改的欄位在不在，而這時它用的就是『 當前讀 』，也就是直接取得最新版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意 RC 與 RR 的版本會有不同的取法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;隔離級別下一篇文章中，會詳細的說明，這裡先簡單談一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read Committed ( RC ) : 事務總是讀取最近一次 commit 的版本 ( 接近當前讀的概念，但差別在於有沒有 commit )。&lt;/li&gt;
&lt;li&gt;Repeatable Read ( RR ) : 事務總是讀取『 當前事務 』開始前，最後一次 commit 的版本 ( 快照讀 )。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;--mvcc--nextlock-&#34;&gt;幻讀難題與解法 - MVCC + Next-Lock 鎖&lt;/h2&gt;
&lt;p&gt;mysql 官網對幻讀的定義如下 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;只要在一個事務中，第二次的 select 多出一行就算幻讀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html&#34;&gt;傳送門&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;幻讀這個東西嚴格來說有不少種情境，咱們來看看以下三種。&lt;/p&gt;
&lt;h3 id=&#34;-1--&#34;&gt;幻讀情境 1 : 範例查詢不一致性問題&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191001/20089358rk9NI0SrCu.png&#34; alt=&#34;&#34;&gt;
圖 7 : 幻讀情境 1 問題&lt;/p&gt;
&lt;p&gt;如上圖 7 所示，事務 b 會讀取到事務 a insert 時增加的資料，導致兩次 select 出來的結果不同。&lt;/p&gt;
&lt;p&gt;這種情況的幻讀也可以用上面提到的 mvcc 來解決。&lt;/p&gt;
&lt;p&gt;咱們知道 mvcc 會給任何修改的東西一個版號，insert 操作也相同，而上面也有提到，這個版本號有時間順序性，所以事務 b 的 select 只會找尋版本號時間順序是在事務 b 開始前的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191001/20089358rH8Glo54eA.png&#34; alt=&#34;&#34;&gt;
圖 8 : 幻讀情境 1 使用 mvcc 解法&lt;/p&gt;
&lt;h3 id=&#34;-2--for-update-&#34;&gt;幻讀情境 2 : for update 問題&lt;/h3&gt;
&lt;p&gt;這種情況比較特別，它有用到咱們之前所提到的兩個上鎖方法，這兩個特別之處在於，一但使用它，就會變成所謂的『 當前讀 』，也就是會讀取最新版號。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select xxx lock in share mode&lt;/li&gt;
&lt;li&gt;select xxx for update&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;圖 9 這種情況下，會變成 select for update 會讀到現在的最新版本，那這是就又會出現幻讀的現像，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191001/200893589BhYrctzeB.png&#34; alt=&#34;&#34;&gt;
圖 9 : 幻讀情境 2&lt;/p&gt;
&lt;p&gt;所以這種情況 2 解法又要使用所一種鎖來解決，也就是所謂的『 next-key locking 』機制，也就是說他會上鎖範圍，如下圖 10 所示，它會上鎖 (-oo, 5)，所以當你實際運行時，會發現，在執行第一個綠色 insert 時會成功，而之後的兩個卡住直到事務 b commit 才能正常的 insert。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191001/20089358Qb8orcPgYh.png&#34; alt=&#34;&#34;&gt;
圖 10 : 幻讀情境 2 使用 next-key 鎖&lt;/p&gt;
&lt;h3 id=&#34;-3--&#34;&gt;幻讀情境 3 : 無解&lt;/h3&gt;
&lt;p&gt;接下來說的幻讀情境目前是無解的情況，如下圖 11 所示。&lt;/p&gt;
&lt;p&gt;問題出在於事務 b 更新時，會讓 c 那個 select 操作讀取到最新的版本，因為上面在 mvcc 有提到，當進行 update 操作時會對那行變成『 當前讀 』，也就是讀最新的資料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191001/20089358SIoS2M48cd.png&#34; alt=&#34;&#34;&gt;
圖 11 : 幻讀情境 3 無解情況&lt;/p&gt;
&lt;h2 id=&#34;heading6&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;在這篇文章中，咱們學習到了 innodb 是如何的解決咱們上述文章中所提到的並行不一致問題的處理。其中並行不一致性又分以下幾個問題 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新不一致 : 使用鎖來解決。&lt;/li&gt;
&lt;li&gt;髒讀 : 使用 mvcc 解決。&lt;/li&gt;
&lt;li&gt;不可重讀 : 使用 mvcc 解決。&lt;/li&gt;
&lt;li&gt;幻讀 : 使用 mvcc + next-key 鎖 來解決 ( 但無法完全解如幻讀情境 3 )。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;順到說一下，你看看單機的不一致性問題就已經那麼的複雜了，分散式會變什麼樣子呢 ?&lt;/p&gt;
&lt;h2 id=&#34;heading7&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/sun8112133/article/details/89853755&#34;&gt;MySQL事务之丢失更新问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/claram/article/details/54023216&#34;&gt;数据库：Mysql中“select &amp;hellip; for update”排他锁分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/rjzheng/p/9950951.html&#34;&gt;【原创】惊！史上最全的select加锁分析(Mysql)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/73078137&#34;&gt;MVCC解决了什么问题？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/263820564/answer/289269082&#34;&gt;MySQL 是如何实现四大隔离级别的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Yhzhtk/note/issues/42&#34;&gt;Innodb 中 RR 隔离级别能否防止幻读？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/51190905&#34;&gt;以后别再说你不懂MySQL中的「幻读」了&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/crazylqy/p/7689447.html&#34;&gt;初步理解MySQL的gap锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.itread01.com/content/1545614493.html&#34;&gt;MySQL InnoDB鎖機制分享&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.meituan.com/2014/08/20/innodb-lock.html&#34;&gt;Innodb中的事务隔离级别和锁的关系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-15 之資料庫層的難題 - 單機『 故障 』一致性難題</title>
      <link>https://mark-lin.com/posts/20190915/</link>
      <pubDate>Sun, 15 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190915/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/200893583XNdu76MIf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;前面幾篇文章中，咱們理解完了 mysql 的索引概念與原理，並且理解了在 mysql 中一個查詢的速度與否取決於索引與表的設計。接下來咱們要來理解一些會拖性能後腿的東西。&lt;/p&gt;
&lt;p&gt;這個會性能後腿的東西就是 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一致性難題&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在追求高性能的路上，通常一定會面臨到資料一致性問題，而產生的原因通常可簡單的分為以下來個來源 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;故障&lt;/li&gt;
&lt;li&gt;併發&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來本篇文章，咱們來看看 mysql 它是如何處理『 故障 』所引發的一致性問題。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不一致資料產生原因。&lt;/li&gt;
&lt;li&gt;MySQL 的解法。&lt;/li&gt;
&lt;li&gt;ACID 的小關連。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading1&#34;&gt;不一致資料產生原因&lt;/h2&gt;
&lt;h3 id=&#34;-1--&#34;&gt;原因 1 : 某項操作故障&lt;/h3&gt;
&lt;p&gt;假設咱們要將 a 帳戶的 1000 元轉到 b 帳戶去，但這時如果在處理 b 帳戶加錢時出錯了，那整個結果就錯誤了，如下圖 1 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/20089358bzdYTcWXVB.png&#34; alt=&#34;&#34;&gt;
圖 1 : 故障導致資料不一致性&lt;/p&gt;
&lt;p&gt;在圖 1 中正確的 b 帳戶應該是 1000 元，但是因為加錢失敗了，所以 b 帳戶變成 0 元，這就是產生了『 資料不一致性 』。&lt;/p&gt;
&lt;h3 id=&#34;-2--&#34;&gt;原因 2 : 單機故障&lt;/h3&gt;
&lt;p&gt;第二個產生的原因要先來理解一下，所謂的『 通常 』寫入硬碟的原理。&lt;/p&gt;
&lt;p&gt;假設咱們有一個 insert 的指令，要將資料寫入到資料庫中，然後資料庫要將它寫到硬碟中，那它的運行過程如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;將資料寫入到內核的緩存區。&lt;/li&gt;
&lt;li&gt;返回 ok 的回應給資料庫。&lt;/li&gt;
&lt;li&gt;內核再將它寫到硬碟。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/20089358urpli4PJDz.png&#34; alt=&#34;&#34;&gt;
圖 2 : 作業系統寫入硬碟原理。&lt;/p&gt;
&lt;p&gt;明眼人應該有看出問題在那，那就是假如在寫到硬碟前，機器掛掉了，那由記憶體開的內核緩衝區中的資料不是就消失了 ? 如下圖 3 所示，那剛剛那筆寫入的指令，不就事實上是失敗的了 ?&lt;/p&gt;
&lt;p&gt;假設這情境在銀行，當用戶存了一百萬進去，然後銀行說成功，但是當去看看帳戶領錢時，卻發現沒有那筆錢時，用你的小腦袋想想，用戶有沒有可能拿刀出來呢 ? 當然不會大家都是文明人，頂多拿個球棒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/20089358v7bUvpv87o.png&#34; alt=&#34;&#34;&gt;
圖 3 : 機器故障導致內核緩衝區資料遺失&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本上應該是有人會問，為什麼不是寫到硬碟在回 ok 呢 ? 嗯作業系統的確有提供 fsync 這方法，它可以直接寫入到硬碟，但是如果每一次操作都是需要修改硬碟，那會耗費非常多的時間，所以通常很多情況下是只有寫入到內核緩衝區中，等待一段時間後在一起寫入到硬碟。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/fdatasync.2.html&#34;&gt;linux-fsync&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mysql-innodb-&#34;&gt;MySQL InnoDB 的解法&lt;/h2&gt;
&lt;h3 id=&#34;-1-&#34;&gt;原因 1 的解法&lt;/h3&gt;
&lt;p&gt;首先它定義了一個叫『 事務 transaction 』的操作單位。&lt;/p&gt;
&lt;p&gt;假設某件事情需要以下兩個指令才能完成 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刪除 A&lt;/li&gt;
&lt;li&gt;更新 B&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那資料庫會將這兩個操作包裝成一個『 事務 』。&lt;/p&gt;
&lt;p&gt;而這個事務只有兩種結果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這事務裡的指令『 全部完成 』。&lt;/li&gt;
&lt;li&gt;這事務裡的指令『 全部都未完成 』。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;delete(10) // 帳戶減少 10 元
add(10) // 帳戶增加 10 元

包裝成事務

begin transaction 
delete(10) // 帳戶減少 10 元
add(10) // 帳戶增加 10 元
transaction commit
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;-mysql--&#34;&gt;那 MySQL 如果實現上述的兩種結果呢 ?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;它主要的實現是使用 undo log。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是當你 insert 一條資料時，就會在 undo log 中，新增一條 delete 指令，而當你 update 一條資訊時，就會在 undo log 中，新增一條 update 回原資料指令。&lt;/p&gt;
&lt;p&gt;當事務失敗時後，就可以利用 undo log，來將資料回復到原本的模樣，如下圖 4 所示，當在紅色區塊要將 b 帳戶加錢時，但是機器故障或是啥的失敗，導致這個事務沒有進行 commit，那這時就會使用 undo log 來將未 commit 的 undo log 給回復。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/20089358cN1fEatbSb.png&#34; alt=&#34;&#34;&gt;
圖 4 : 事務失敗回滾&lt;/p&gt;
&lt;p&gt;而正常運行圖如下，當一個事務有正確的進行 commit 已後，就會將該 undo log 下一個已經 commit 的 tag，然後就算系統重啟，它發現這個 undo log 已經 commited 了，它也就不會回滾它了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/20089358I2ubnnbEr3.png&#34; alt=&#34;&#34;&gt;
圖 5 : 事務正常處理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小備註 ~&lt;/strong&gt;
這裡只是淺淡一下 undo log，它事實上還有很多東西可以說，包含 undo log 的管理等，有興趣的友人可以查查。&lt;/p&gt;
&lt;h4 id=&#34;php-&#34;&gt;PHP 的使用小範例&lt;/h4&gt;
&lt;p&gt;這裡簡單的拿個程式碼小範例來給一些初學者看看，應該會比較有感覺。&lt;/p&gt;
&lt;p&gt;下面為 php 範例，從 laravel 官網直接拿來的小範例，簡單一個 transaction 就是一個操作單位，這個單位裡面的指令，要嘛全部完成，要嘛全部不做，不二價。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;DB::beginTransaction();
DB::table(&amp;#39;users&amp;#39;)-&amp;gt;update([&amp;#39;votes&amp;#39; =&amp;gt; 1]);
DB::table(&amp;#39;posts&amp;#39;)-&amp;gt;delete();
DB::commit();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;-2-&#34;&gt;原因 2 的解法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;redo log 機制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上有人一定會問說，為什麼它是寫到內核緩存後，就直接回傳 ok 的回應呢 ? 不能直接改成寫完硬碟後在回 ok 嗎 ?&lt;/p&gt;
&lt;p&gt;對 ! 答案是可以，但是有問題。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那就是會太慢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假設我們每一個指令，都要進行所謂的 fsync ( 就是直接寫到硬碟的方法 )，那會效能會非常的差。&lt;/p&gt;
&lt;p&gt;因此 mysql innodb 使用 redo log 來建立一套，可以保證寫入，且性能又不會影響到太多的機制。&lt;/p&gt;
&lt;h4 id=&#34;redo-log-&#34;&gt;Redo Log 流程&lt;/h4&gt;
&lt;p&gt;假設咱們有一段的事務流程如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A = 1000, B = 0

1. 開始事務 T
2. Update A account = 0  (A 帳戶修改為 0 元)
3. Update B account = 1000 (B 帳戶修改為 1000 元)
4. 事務 commit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下來看看在運行這一段事務時，它會如何的儲放 redo log 與使用它。如下面流程，基本上每一個操作都是會寫入到 redo log 緩存中，而不是實際上將修改的資料，寫入到硬碟中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Redo log 角度 ( 編號對應於上方操作 )

1. 記錄事務 T 開始到 redo log 緩存。
2. 記錄要修改 A 的 page 到 redo log 緩存。
3. 記錄要修改 B 的 page 到 redo log 緩存。
4. 將 redo log 緩存使用 fsync 寫入到硬碟。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;~ 小知識 1 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;redo log 是儲你修改了那一個 page，而 undo log 是你對那一個資料表的欄位進行了什麼修改。通常會稱 redo log 為物理日誌，而 undo log 為邏輯日誌。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 2 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;page 是 innodb 的硬碟操作的最小單位，它的預設大小為 16 kb。而這個 page 會在 mysql 的緩衝區暫存住。&lt;/p&gt;
&lt;p&gt;上面是針對事務所產生的 redo log 流程，然後咱們來看一下完整的將資料寫到硬碟的流程如下:&lt;/p&gt;
&lt;h4 id=&#34;heading2&#34;&gt;完整將資料寫到硬碟的流程&lt;/h4&gt;
&lt;p&gt;下圖為完整的將資料寫到硬碟的流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用戶發送請求 mysql 執行一段事務。&lt;/li&gt;
&lt;li&gt;mysql 先將緩存區資料進行修改(你可以想成也就是將緩存取的 a、b 帳戶值修改)。&lt;/li&gt;
&lt;li&gt;將更新 a、b 所修改的 page 操作寫入到 redo log 緩存區。&lt;/li&gt;
&lt;li&gt;等事務執行 commit 時，執行 fsync 將 redo log 寫入到硬碟。&lt;/li&gt;
&lt;li&gt;用戶端收到更新 ok 的回應。&lt;/li&gt;
&lt;li&gt;實際上的將修改的資料，寫入到硬碟中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以從上述的流程知道，用戶收到 ok 只是 redo log 已經寫到硬碟，而不是實際將修改的資料寫到硬碟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/20089358BUwgiuqRyg.png&#34; alt=&#34;&#34;&gt;
圖 6 : 將資料完整寫到硬碟的流程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 ~&lt;/strong&gt;
注意，在 innodb 中，一切都是以 log 為主，也就是說你實際上 insert 資料，不是直接去修改硬碟的 b+ 樹，而是先將這個操作寫入到 log 中，在由一個叫 master thread 來將緩衝區資料丟到硬碟中。&lt;/p&gt;
&lt;p&gt;可是這時有人會問，那如果有人在 master thread 修改前，來讀取資料，那不是也會讀到舊的 ?&lt;/p&gt;
&lt;p&gt;不，不會，因此所有的操作都會到 mysql innodb 的緩衝區先進行處理，也就是 insert 會寫到緩衝區，而讀取時也會先直接到緩存區拿。&lt;/p&gt;
&lt;h4 id=&#34;-fsync--&#34;&gt;那為什麼不要直接將修改數據 fsync 到硬碟 ?&lt;/h4&gt;
&lt;p&gt;為什麼不能改成下圖 7 的流程呢，直接在 commit 時在 fsync 就好，為什麼一定要寫到 redo 後，在處理呢 ? 我當初也有這個鬼疑問。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/20089358QNlgFWqgSj.png&#34; alt=&#34;&#34;&gt;
圖 7 : 馬克疑問圖&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因為慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;慢在兩個地方 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上面有提到 innodb 的硬碟最小操作單位是 page，而它預設是 16 kb，而假設上面一個小地方寫改後，就要整頁寫入，浪費社會資源。&lt;/li&gt;
&lt;li&gt;隨機 i/o 問題。你可以將硬碟想成有『 順序 』的一堆有排序的頁 ( 不是指 innodb page )，而我們每一次的修改，都需要先去找到硬碟中某個頁後在去修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而由於 redo log 只是往個檔案進行追加操作，它屬於順序 i/o 與隨機 i/o 相比之下，順序 i/o 較快，所以才會使用 redo log 寫完硬碟來當回應。然後在偷偷的來處理實際資料寫入。&lt;/p&gt;
&lt;h4 id=&#34;redo-log--&#34;&gt;redo log 寫入到硬碟出事怎麼辦 ?&lt;/h4&gt;
&lt;p&gt;莫慌 ! 不影響。&lt;/p&gt;
&lt;p&gt;因為對一個事務來說，預設是要將 redo log 檔寫到硬碟後才回傳 ok，如上圖 5 的流程 5 所示，所以如果 redo log 寫入時失敗了，那就代表這個事務失敗，客戶端就會知道它是失敗的。而不會發生，明明說回應正常，但是下一次去領錢卻發現沒錢的問題。&lt;/p&gt;
&lt;h4 id=&#34;heading3&#34;&gt;如果將實際修改資料寫入硬碟資料時出事怎麼辦　？&lt;/h4&gt;
&lt;p&gt;莫慌 ! 別忘了有 redo log，它記錄好了那個 page 要修改，用它就可以復活。&lt;/p&gt;
&lt;h2 id=&#34;acid-&#34;&gt;ACID 的小關連&lt;/h2&gt;
&lt;p&gt;基本上熟悉資料庫的人都會知道，我上述的兩個問題，就事務的特性 ACID 中的其中兩個 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性 Atomic ( 資料不一致原因 1 )&lt;/li&gt;
&lt;li&gt;持久性 Durability ( 資料不一致原因問題 2 )&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;-atomic&#34;&gt;原子性 Atomic&lt;/h3&gt;
&lt;p&gt;就是事務的運行只有兩個結果 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全部執行&lt;/li&gt;
&lt;li&gt;全部不執行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在 mysql innodb 的實現就是使用 undo log。&lt;/p&gt;
&lt;h3 id=&#34;-durability&#34;&gt;持久性 Durability&lt;/h3&gt;
&lt;p&gt;這個特性主要是說 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;當事務執行 commit 時，對系統的影響是永久的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就如上述原因 2 一樣，如果是用正常的 write ( 寫到緩衝區後就回應 ok )，那就不能滿足持久性。&lt;/p&gt;
&lt;p&gt;而 mysql innodb 的實現基於兩個重點在於『 redo log 』加『 fsync 』。&lt;/p&gt;
&lt;p&gt;而不單獨使用 fsync 是因為性能考量。&lt;/p&gt;
&lt;h4 id=&#34;--&#34;&gt;特殊用法 : 在追求極端性能情況，可考慮犧牲持久性&lt;/h4&gt;
&lt;p&gt;在 mysql innodb 事實上有提供一個設定，可以讓我們犧牲持久性，來大量的提供效能，但是要不要使用請自已判斷。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;innodb_flush_log_at_trx_commit&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它有三個參數設定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 : 事務提交時，不會 fsync，而是讓 master thread 每 1 秒鐘執行一次 fsync，將 log 儲到硬碟，但是這種問題會出在，機器或服務掛了，可能會損失 1 秒的資料。&lt;/li&gt;
&lt;li&gt;1 : 事務提交時，會 fsync 一次，將 log 儲放硬碟 ( 這是預設，就是我們上圖 6 的模式 )。&lt;/li&gt;
&lt;li&gt;2 : 事務提交時，將只寫入到 redo log 緩衝區的資料，寫到內核緩衝區，但是這種問題會出在系統掛掉時，在內核衝區的資料會死，而 mysql 服務掛了會沒事。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 mysql 技術內幕 innodb 這本書中，作者有測試過以上三這的效能差異，如下。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;innodb_flush_log_at_trx_commit&lt;/th&gt;
&lt;th&gt;插入 50 萬行資料花費時間&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;13.90 sec&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1(預設)&lt;/td&gt;
&lt;td&gt;1 m 52.11 sec&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;23.73 sec&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;從上面結果可知，只要調整成 0 或 2 時，執行花費時間效能提升非常的多，因為這兩個參數不會一直寫到硬碟中。但是調整後就是不包證 ACID 的一致性，這就是開發者要自行權衡的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 ~&lt;/strong&gt;
注意一下你看這個參數為 innodb_flush_log_at_trx_commit，然後有些人可能會想到 linux 所提供的方法 fflush，這個和上述說的 fsync 不太一樣喔。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fsync : 將資料實際上的寫入到硬碟中。&lt;/li&gt;
&lt;li&gt;fflush : 將資料寫入到內核緩衝區。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man2/fdatasync.2.html&#34;&gt;linux-fsync&lt;/a&gt;
&lt;a href=&#34;http://man7.org/linux/man-pages/man3/fflush.3.html&#34;&gt;linux-fflush&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading4&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章中咱們說說單機故障時，可能會碰到的數據不一致性問題，並且咱們理解了 mysql 它是如何解決這兩個事情。&lt;/p&gt;
&lt;p&gt;當初在研究這個主題的時後，看了不少文章發現，它們都是先介紹事務，然後在介紹 ACID，然後才開始說明什麼是 undo 或 redo，但是我覺得這樣不太好讓人理解。&lt;/p&gt;
&lt;p&gt;主要的原因在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一定是先有問題，才有解決工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果不先理解問題是什麼，而真接去看解決工具，你確定你找到的是正確的工具嗎，又或是你可以正確理解它的解法嗎 ?&lt;/p&gt;
&lt;p&gt;不過這只是咱自已的想法，沒啥對與錯。&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/35574452&#34;&gt;undo log与redo log原理分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/65438009&#34;&gt;一文解析：MySQL事务ACID原理让你面试不再害怕&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/31346392&#34;&gt;如何理解数据库事务中的一致性的概念？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/48327345&#34;&gt;一文了解InnoDB事务实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/entry/5ba0a254e51d450e735e4a1f&#34;&gt;详细分析MySQL事务日志(redo log和undo log)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://draveness.me/database-concurrency-control&#34;&gt;浅谈数据库并发控制 - 锁和 MVCC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/4e3edbedb9a8&#34;&gt;五分钟搞清楚MySQL事务隔离级别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html&#34;&gt;官網-redo log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codertw.com/%E8%B3%87%E6%96%99%E5%BA%AB/21464/&#34;&gt;Innodb中的buffer poll和redo undo log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000017888478&#34;&gt;浅析MySQL事务中的redo与undo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-14 之資料庫層的優化 - 表的設計</title>
      <link>https://mark-lin.com/posts/20190914/</link>
      <pubDate>Sat, 14 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190914/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190926/20089358ZPcBZlbJcf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;本篇文章中咱們將要從『 表 』的角度來儘可能的優化性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表設計的幾個小建議&lt;/li&gt;
&lt;li&gt;正規與非正規的小戰爭&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading1&#34;&gt;表設計的幾個小建議&lt;/h2&gt;
&lt;p&gt;這個章節會給一些建立表時的小建議，雖然這裡優化的點不多，但是每一個地方都做到好，才是專業。&lt;/p&gt;
&lt;h3 id=&#34;-1--------&#34;&gt;建議 1 : 選擇適當的欄位類型 - 字串 ( 性能 + )&lt;/h3&gt;
&lt;p&gt;基本上在 mysql 中有一下文字類型的選擇，適當的選擇類型，可以省下不少資源 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;char&lt;/li&gt;
&lt;li&gt;varchar&lt;/li&gt;
&lt;li&gt;text&lt;/li&gt;
&lt;li&gt;blob&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;char-vs-varchar&#34;&gt;char vs varchar&lt;/h4&gt;
&lt;p&gt;char 的特點 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大 255 byte&lt;/li&gt;
&lt;li&gt;不管如何就是使用指定的空間 ex. char(4) 就是就算只有 1 個字元，就是花費 4 byte。&lt;/li&gt;
&lt;li&gt;用 char 需要處理空白。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;varchar 特色 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存幾個字就是需花費 n+1 個 byte。 Ex. varchar(4) 假設你儲 1 個字，那就是花費 1 + 1 = 2 byte。&lt;/li&gt;
&lt;li&gt;65535 為最大，實際為 65532。&lt;/li&gt;
&lt;li&gt;當 varchar 大於一定字數時，會自動轉成 text。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;varchar (255+) 轉成 tinytext
varchar (500+) 轉成 text
varchar (20000+) 轉成 mediumtext
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下表為 char 與 varchar 的實際存儲空間比較。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;char(4)&lt;/th&gt;
&lt;th&gt;花費空間&lt;/th&gt;
&lt;th&gt;varchar(4)&lt;/th&gt;
&lt;th&gt;花費空間&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&#39;&amp;rsquo;&lt;/td&gt;
&lt;td&gt;&amp;ldquo;白白&amp;rdquo;&lt;/td&gt;
&lt;td&gt;4 bytes&lt;/td&gt;
&lt;td&gt;&#39;&amp;rsquo;&lt;/td&gt;
&lt;td&gt;1 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lsquo;ab&amp;rsquo;&lt;/td&gt;
&lt;td&gt;&amp;lsquo;ab白白&amp;rsquo;&lt;/td&gt;
&lt;td&gt;4 bytes&lt;/td&gt;
&lt;td&gt;&amp;lsquo;ab&amp;rsquo;&lt;/td&gt;
&lt;td&gt;3 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lsquo;abcd&amp;rsquo;&lt;/td&gt;
&lt;td&gt;&amp;lsquo;abcd&amp;rsquo;&lt;/td&gt;
&lt;td&gt;4 bytes&lt;/td&gt;
&lt;td&gt;&amp;lsquo;abcd&amp;rsquo;&lt;/td&gt;
&lt;td&gt;5 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lsquo;abcdefgh&amp;rsquo;&lt;/td&gt;
&lt;td&gt;&amp;lsquo;abcd&amp;rsquo;&lt;/td&gt;
&lt;td&gt;4 bytes&lt;/td&gt;
&lt;td&gt;&amp;lsquo;abcd&amp;rsquo;&lt;/td&gt;
&lt;td&gt;5 bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表格來源: &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.6/en/char.html&#34;&gt;MySQL 5.6 Reference Manual&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意一下，上面中的白代表為空白的意思，因為 markdown table 在轉換時，有些轉換器會將空白移除，所以上表以白替代。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那什麼時後選 char 什麼時後選 varchar 呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比較簡單的選擇基準為 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;變動、長、不常更新 =&amp;gt; 選 varchar，&lt;/li&gt;
&lt;li&gt;固定、短、常更新 =&amp;gt; 選 char。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;char 適合常更新的原因在於它比較沒有碎片化的問題，因為它長度是固定的。&lt;/p&gt;
&lt;h4 id=&#34;text-vs-blob&#34;&gt;text vs blob&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;text: 可儲 0 ~ 65536 字元，儲文字。&lt;/li&gt;
&lt;li&gt;blob: 可儲 0 ~ 65536 字元，儲二進位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這兩個基本上都是用來儲大量文字的東西，但是看了不少篇的文章，它們都建議儘可能的不要使用它，不過我覺得比較準備一點的說法在於，不要在表內，存太長的字串 ( 包含 varchar )，真的要的話建另一張表來儲。&lt;/p&gt;
&lt;p&gt;原因在於，它可能會多使用一些空間與 i/o 來處理，在前幾篇文章中，咱們知道一張表會使用 pk 來建立 b+ 樹，然後最下面的節點才能儲放每一行的資料，但是 text 的內容是例外，它不會儲在那一行，而會另外開空間來儲。&lt;/p&gt;
&lt;h3 id=&#34;-2-------&#34;&gt;建議 2. 選擇適當的欄位類型 - 數字 ( 性能 + )&lt;/h3&gt;
&lt;p&gt;在 mysql 中所提供的整數數字類型如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tinyint: -128 ~ 127 (1 bytes)&lt;/li&gt;
&lt;li&gt;smallint: -32768 ~ 32767 (2 bytes)&lt;/li&gt;
&lt;li&gt;mediumint: -8388608 ~ 8388607 (3 bytes)&lt;/li&gt;
&lt;li&gt;int: -2147483648 ~ 2147483647 (4 bytes )&lt;/li&gt;
&lt;li&gt;bigint: -2^63 ~ 2^63-1 (8 bytes)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而它所提供的浮點數字型(也就是有小數點)如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;float: -3.402823466E+38 ~ 3.402823466E+38 (4 bytes)&lt;/li&gt;
&lt;li&gt;double: -1.7976931348623157E+308 ~ 1.7976931348623157E+308 (8 bytes)&lt;/li&gt;
&lt;li&gt;decimal: ~ -1E+66 ~ ~ 1E+66 (它比較特別，上述兩個是近似值，而它是完全精準值，每 9 個數字 4 bytes)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;數字的選擇基本就是以下兩個準則 :&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;選擇適合的大小，能用 int 就不要用 bigint。&lt;/li&gt;
&lt;li&gt;選擇適合的類型，例如錢錢請用 decimal。&lt;/li&gt;
&lt;li&gt;選擇使用 unsigned，它的功用就是就儲放負數的空間全移到正數位置，也就是說可儲放空間 * 2。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;簡單說以下 unsigned。假設我們在 tinyint (-128 ~ 128) 設 unsigned，就代表此欄位變成可以儲 (0 ~ 256) 多了一倍的空間。像編號這種就很適合。&lt;/p&gt;
&lt;h3 id=&#34;-3-------or---&#34;&gt;建議 3. 選擇適當的欄位類型 - 日期 ( 性能 + or 維護性 + )&lt;/h3&gt;
&lt;p&gt;日期基本上有以下三種選擇 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;datetime: 以 &amp;lsquo;YYYY-MM-DD HH:MM:SS&amp;rsquo; 格式儲放(8 bytes)。&lt;/li&gt;
&lt;li&gt;timestamp: 以 timestamp 格式儲放 (但它只到 2038 年) 4 bytes。&lt;/li&gt;
&lt;li&gt;unsigned int: 將 timestamp 格式儲成 int 格式 (4 bytes)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;datetime&#34;&gt;datetime&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;以 &amp;lsquo;YYYY-MM-DD HH:MM:SS&amp;rsquo; 格式。&lt;/li&gt;
&lt;li&gt;跨時區不適用，因為它只儲當地時間。&lt;/li&gt;
&lt;li&gt;佔 8 bytes。&lt;/li&gt;
&lt;li&gt;時間可儲到世界末日。&lt;/li&gt;
&lt;li&gt;可直接使用預設時間(現在)。&lt;/li&gt;
&lt;li&gt;可讀性高(你看一眼就知道時間)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;timestamp&#34;&gt;timestamp&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;以 UTC timestamp 格式儲放。&lt;/li&gt;
&lt;li&gt;適用於時區轉換。&lt;/li&gt;
&lt;li&gt;排序與索引效率優於 datetime。&lt;/li&gt;
&lt;li&gt;佔 4 bytes。&lt;/li&gt;
&lt;li&gt;時間可儲到 2038 年。&lt;/li&gt;
&lt;li&gt;mysql 提供不少可操作它的函數。&lt;/li&gt;
&lt;li&gt;可直接使用預設時間(現在)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;unsigned-int&#34;&gt;unsigned int&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;以 UTC timestamp 格式儲成 unsigned int 欄位&lt;/li&gt;
&lt;li&gt;佔 4 bytes&lt;/li&gt;
&lt;li&gt;適用於時區轉換。&lt;/li&gt;
&lt;li&gt;排序與索引效率優於 datetime。&lt;/li&gt;
&lt;li&gt;時間大概可儲到 2106 年。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;-&#34;&gt;選那個呢 ?&lt;/h4&gt;
&lt;p&gt;基本上第一個還是先看你的需求，如果是有跨時間儲資料庫情況，那 datetime 可以移掉了，因為它是直接儲你 local 的時間。&lt;/p&gt;
&lt;p&gt;在假設沒時區的問題下，要選那個呢 ?&lt;/p&gt;
&lt;p&gt;目前我是比較建議用 unsigned int，但這真的沒有什麼標準答案。我會選擇的原因如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unsigned int 嚴格來說可以解 2038 問題，債不要留給子孫 (100 年後的就先別管)。&lt;/li&gt;
&lt;li&gt;unsigned int 在 mysql 沒辦法給它預設值，但事實上不少 ORM 都有提供 (sql 魔人請別嘴我)。&lt;/li&gt;
&lt;li&gt;mysql 提供的 timestamp 函數，我真不常用到它，基本上大部份的轉換，我都選擇在應用層處理，別讓資料庫做太多事。&lt;/li&gt;
&lt;li&gt;性能較好點兒與 datetime 相比。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在選擇時，我還會考慮公司的規範，因為假設公司內一個資料庫儲 datetime、一個儲 timestamp，那你想想應用層的程式會長什麼樣子 ?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 備註參考用 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本上有對 mysql 進行深入研究的，大概都有讀過這個書&lt;a href=&#34;https://www.books.com.tw/products/CN10991137&#34;&gt;高性能 MySQL&lt;/a&gt;，它裡面是建議別用 int 來儲放日期，它說沒什麼好處。但是它沒說理由，所以我就先不理它。&lt;/p&gt;
&lt;h3 id=&#34;-4---pk---&#34;&gt;建議 4 : 請別選擇太長值當 PK ( 性能+ )&lt;/h3&gt;
&lt;p&gt;在索引那篇文章中，咱們有提到在 innodb 中，每一張表都會建立 clustered Index b+ 樹，而它是根據以下準則來決定這顆樹的索引值。&lt;/p&gt;
&lt;p&gt;它的選擇如下 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;primary key ( PK )。&lt;/li&gt;
&lt;li&gt;如果沒有 pk 則選擇一個非空的 unique 索引來當 pk。&lt;/li&gt;
&lt;li&gt;如果還是沒有，innodb 會自動產生一個隱藏的欄位來建立。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;沒有必要的話，請直接使用 auto increment 的 id 編號當 pk，儘可能不要用一些 guid 或啥長長的東東來當 pk。&lt;/p&gt;
&lt;p&gt;主要的原因在於，這真的會影響性能。&lt;/p&gt;
&lt;p&gt;前面幾篇文章說過，在 innodb 裡，它會使用 pk 來建立一個 b+ 樹的索引結構，如下圖，除了最小面的節點有實際上存行資料外，其它的都是放 pk 索引值 :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190929/20089358AhIPHUQdsP.png&#34; alt=&#34;&#34;&gt;
圖 1 : clustered Index b+&lt;/p&gt;
&lt;p&gt;問題就出在其它儲 pk 索引值的那些節點，如下圖紅色區塊，一個紅色區塊裡面會包含索引用的節點，假設我們一個區塊限定為 4 kb，下圖咱們每個索引節點大小為 2 kb，所以可以儲兩個，但是如果索引節點大小變為 4 kb 的話，你覺得會如何 ?&lt;/p&gt;
&lt;p&gt;它會變成只能儲一個，這也代表區塊變多，也代表 i/o 要更多次。&lt;/p&gt;
&lt;p&gt;這也是為什麼不建議用太長值當 pk，因為太長值代表它需要多花點空間來儲，這導致它會增加區塊的數量，最後導致 i/o 次數更多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190929/200893581eAsrIT9v7.png&#34; alt=&#34;&#34;&gt;
圖 2 : 索引值太大問題&lt;/p&gt;
&lt;h3 id=&#34;-5------&#34;&gt;建議 5 : 新增一些特殊用欄位 ( 維護性 + )&lt;/h3&gt;
&lt;h4 id=&#34;-1--&#34;&gt;特殊欄位 1 : 邏輯刪除欄位&lt;/h4&gt;
&lt;p&gt;在某些重要的表上，可以新增一個欄位來代表它是否被『 移除 』，但這裡不是只真的移除，只是給它下個 tag，這種好處在於預防萬一。目前應該有不少公司是這樣搞的。&lt;/p&gt;
&lt;h4 id=&#34;-2--&#34;&gt;特殊欄位 2 : 建立、修改時間欄位&lt;/h4&gt;
&lt;p&gt;而這個就是會在每個表新增『建立』與『修改』的時間欄位，雖然會耗用一些資源，但是這樣真的有助於於 debug 用。像當你發現某一行改了，然後你有了修改時間，那這時你就可以用這時間去查查應用層一些 log 它到底做了什麼事情，真的好用真心不騙。&lt;/p&gt;
&lt;p&gt;有時後多儲點東西減少點性能，增加維護性事實上未來也可以省不少錢錢。&lt;/p&gt;
&lt;h3 id=&#34;-6---null----&#34;&gt;建議 6 : 儘量的不允需 NULL ( 性能 + )&lt;/h3&gt;
&lt;p&gt;基本上有兩個問題 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;儲 null 耗的空間比一般的還多。&lt;/li&gt;
&lt;li&gt;count 有可能會出現 bug。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;索引欄位　{name} 

假設資料為:
{&#39;mark&#39;,18}
{ null, 17}


SELECT count(*) FROM user;  =&amp;gt; 2 筆
SELECT count(name) FROM user; =&amp;gt; 1 筆
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最後簡單說一下，null 事實上不太會影響到索引查詢，你只要在索引欄位下的是 is null 這種語法，那都會打中索引，不會變全掃。而如果你會變全掃，基本上不是 null 的關係，而是你下的 sql 關係。&lt;/p&gt;
&lt;h3 id=&#34;-6------&#34;&gt;建議 6 : 最後一點請註解 ( 維護性 + )&lt;/h3&gt;
&lt;p&gt;當你看到資料表裡面一堆欄位的註解是空的時，你會哭的，尤其是在看不懂欄位名的情況且你主管叫你去應用層看程式碼來推時，你真會哭到想拿起刀。咱真有看過。&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;正規化與反正規的小戰爭&lt;/h2&gt;
&lt;p&gt;正規與反正規是兩種資料儲放的型式，比較簡單且白話文的分法為 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正規化 : 分層多張表儲放。&lt;/li&gt;
&lt;li&gt;反正規化 : 全部都儲在一張表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;咱們簡單的來看一下範例。&lt;/p&gt;
&lt;p&gt;假設咱們要儲放部門人員資訊。&lt;/p&gt;
&lt;h4 id=&#34;heading3&#34;&gt;正規化所建立的表&lt;/h4&gt;
&lt;p&gt;交易單 table&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;trade_id&lt;/th&gt;
&lt;th&gt;user_id&lt;/th&gt;
&lt;th&gt;volume&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;002&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;003&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;交易人 table&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;age&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;mark&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;002&lt;/td&gt;
&lt;td&gt;jiro&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;003&lt;/td&gt;
&lt;td&gt;ian&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;heading4&#34;&gt;反正規化所建立的表&lt;/h4&gt;
&lt;p&gt;而反正化則只會建立一張票，如下，交易人的資料會放在同一張裡面。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;volume&lt;/th&gt;
&lt;th&gt;user_id&lt;/th&gt;
&lt;th&gt;user_name&lt;/th&gt;
&lt;th&gt;user_age&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;001&lt;/td&gt;
&lt;td&gt;mark&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;002&lt;/td&gt;
&lt;td&gt;jiro&lt;/td&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;003&lt;/td&gt;
&lt;td&gt;ian&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;heading5&#34;&gt;正規化與反正規化的比較&lt;/h3&gt;
&lt;p&gt;正規化的特點如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新操作一定優於反正規化。&lt;/li&gt;
&lt;li&gt;較少重複的數據。&lt;/li&gt;
&lt;li&gt;每個表較小，比較容易使用緩存池。&lt;/li&gt;
&lt;li&gt;某一些操作比較方便。( 例如在非正規化要取得所群組資訊，那就一定要用 group，而在正規化可能就是一張票資訊 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反正規化:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查詢操作優於正規化，因為不用 join，而且也可以更簡單的設計索引策略。&lt;/li&gt;
&lt;li&gt;但更新會很麻煩，而且還要考慮競爭的問題 ( 這之後的章節會說 )。&lt;/li&gt;
&lt;li&gt;表可能會很大，不適合未來擴展與分家。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;-1&#34;&gt;選那個呢 ?&lt;/h4&gt;
&lt;p&gt;先說一下兩種模式的主軸 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反正規化: 追求最高效率的查詢。&lt;/li&gt;
&lt;li&gt;正規化 : 追求穩定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上可以的話請選正規化，原因在於穩定，除非你很有自信，系統現在至未來都會很少更新需求，並且你也知道更新時可能會有那些雷，不然的話，還是請選正規化。&lt;/p&gt;
&lt;h3 id=&#34;-2&#34;&gt;何謂合格或好的正規化呢 ?&lt;/h3&gt;
&lt;p&gt;基本上就是所謂的『 第 n 正規化型式 』，基本上咱覺得到第三層就夠了。&lt;/p&gt;
&lt;p&gt;然後這裡詳細的正規化型式可以去看筆者以前寫的文章應該就夠了，雖然是 3 年前寫的，但是回過頭看還是覺得寫的算清楚。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://marklin-blog.logdown.com/posts/1394159-mongodb-30-17-design-the-formal-war-with-anti-normalization&#34;&gt;30-17之MongoDB的設計&amp;mdash;正規與反正規化的戰爭&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading6&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章我稍微簡單的整理一些，咱們平常開發時，要建立一個表時的需要注意事項，並且也順到的探談了一下正規化與反正化規化的問題。&lt;/p&gt;
&lt;p&gt;不過這些準則上，不全然是為了性能的準則，有一些是會為了維護性而增加的一些東西，這 30 天的文章主題是『 從 0 至 1 儘可能的建立好的系統 ( 性能 ) 』，然後主題是性能，但別忘了我們的目的是好的系統。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一個好的性統的要點是『 平衡 』喔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;heading7&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/32382274&#34;&gt;浅谈MySQL表结构设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzI2NDU3OTg5Nw==&amp;amp;mid=2247483799&amp;amp;idx=1&amp;amp;sn=4d1f45ab7d5bc9655a8fef2601171e52&amp;amp;chksm=eaab3fc1dddcb6d794dde2ee8e71a56a9b71fdc207efc033c56d1b53c7dc05b096e7cbc3482b&amp;amp;scene=21#wechat_redirect&#34;&gt;MySQL表设计踩过的坑！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/7029127/using-mysqls-timestamp-vs-storing-timestamps-directly&#34;&gt;stackover-Using MySQL&#39;s TIMESTAMP vs storing timestamps directly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gpshumano.blogs.dri.pt/2009/07/06/mysql-datetime-vs-timestamp-vs-int-performance-and-benchmarking-with-myisam/&#34;&gt;MySQL DATETIME vs TIMESTAMP vs INT performance and benchmarking with MyISAM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/4594229/mysql-integer-vs-datetime-index&#34;&gt;MySQL Integer vs DateTime index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://n.sfs.tw/content/index/10266&#34;&gt;[Mysql] 資料型態int, float, double, text, char, varchar, blob大小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wubx.net/varchar-vs-text/&#34;&gt;varchar和text说不清的那些事&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-13 之資料庫層的優化 - 索引設計與雷區</title>
      <link>https://mark-lin.com/posts/20190913/</link>
      <pubDate>Fri, 13 Sep 2019 20:12:39 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190913/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190926/20089358ZPcBZlbJcf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;前面兩篇文章中，咱們已經學習完索引的核心觀念以後，接下來咱們學學在使用時有那些的優質的方法與注意事項。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10221111&#34;&gt;30-11 之資料庫層的核心 - 索引結構演化論 B+樹&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10221572&#34;&gt;30-12 之資料庫層的核心 - MySQL 的索引實現&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章分為以下幾個章節 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引的重要小觀念&lt;/li&gt;
&lt;li&gt;索引的設計流程&lt;/li&gt;
&lt;li&gt;索引的使用注意事項&lt;/li&gt;
&lt;li&gt;SQL 地雷區&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading1&#34;&gt;索引的重要小觀念&lt;/h2&gt;
&lt;h4 id=&#34;-1--&#34;&gt;觀念 1 : 不是索引越多越好&lt;/h4&gt;
&lt;p&gt;索引不是聖杯，它是雙刃刀，用的好上天堂，用不好下地獄。基本上資料庫的索引幾乎可以影響一個系統的 50% 以上的性能。&lt;/p&gt;
&lt;p&gt;索引可以加快查詢速度，但注意它是以空間換取時間。&lt;/p&gt;
&lt;p&gt;基本上它使用的資源如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每個索引都會建立一顆 b+ 樹。&lt;/li&gt;
&lt;li&gt;每次新增、更新資料時都會改變 b+ 樹。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以當你索引越多時，你所需要的記憶體與維護索引的 cpu 運算就需要越多。&lt;/p&gt;
&lt;h4 id=&#34;-2--explain--sql-&#34;&gt;觀念 2. 懂的使用 Explain 來分析你的 SQL 索引性能解析&lt;/h4&gt;
&lt;p&gt;explain 這個指令可以讓你知道你下的 sql 語句是否有命中索引。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXPLAIN SELECT * FROM user_no WHERE name = &#39;mark&#39;;

=====================================================

          id: 1
  select_type: SIMPLE
        table: user
   partitions: NULL
         type: const
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 8
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上範例的 type 與 key 這兩個欄位，它有很明確的說明使用到 pk，也就是直接使用 clustered Index 索引樹來找資料。&lt;/p&gt;
&lt;p&gt;詳細的欄位說明建議看以下兩篇，我覺得它已經說明的很清楚了，這裡你只要知道，explain 可以幫助你解析 sql 的性能，然後你根據結果，來進行你的索引或 sql 改善。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000008131735&#34;&gt;MySQL 性能优化神器 Explain 使用分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5d60bac76fb9a06b0703c7ff?utm_source=gold_browser_extension#heading-9&#34;&gt;Mysql关键字Explain 性能优化神器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;-3-&#34;&gt;觀念 3. 索引不是建了就會使用&lt;/h4&gt;
&lt;p&gt;在 mysql 的世界 ( 其中資料庫我不確定 )，不是建了索引，且下的 query 正常就會一定會使用。&lt;/p&gt;
&lt;p&gt;例如咱們有以下的索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;table : user
field: name, sex
index: {sex}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後你執行下面的 sql :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM user WHERE sex = 0 ( 0 代表女生 )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那這時會不會用索引呢 ?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;答案是不一定，如果大部份的值都是女生，那 mysql 會用全掃，如果大部份值為男生，那 mysql 會用索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;heading2&#34;&gt;索引的設計流程&lt;/h2&gt;
&lt;h4 id=&#34;step-1-&#34;&gt;Step 1. 先根據需求，來判斷可能需要建索引的欄位&lt;/h4&gt;
&lt;p&gt;首先第一件事情就是定義需求或是預測，來決定那些欄位『 可能 』需要建立索引，等有候選欄位後在進行下一個步驟。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;找出那些欄位較常需要拿來 query&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;step-2-&#34;&gt;Step 2. 看看候選欄位的基數大小&lt;/h4&gt;
&lt;p&gt;基數就是指這個欄位的值的可能性。&lt;/p&gt;
&lt;p&gt;像假設某個欄位是存性別，也就是說只有『 男 』與『 女 』，那就代表這個欄位基數很小，這時就不建議建立索引。&lt;/p&gt;
&lt;p&gt;為什麼呢 ?&lt;/p&gt;
&lt;p&gt;因為如果建了，mysql 也不太會使用。你想想，一個欄位只有男與女兩種，那這時你要找女的，你覺得全掃一個一個找比較快，還是先用索引找出所有女的 pk，然後再去 clustered Index 抓資料呢 ?&lt;/p&gt;
&lt;p&gt;可以看看下圖 1 所示，很明顯用全掃反而會比較快，所以這時 mysql 會直接選用全掃，所以你建立的索引會完全用不到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190928/20089358OKVtAMi6O9.png&#34; alt=&#34;&#34;&gt;
圖 1 : 全掃與索引在基數小時的比較圖&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;備註:&lt;/strong&gt;
在系統建立開始預測預期基數事實上不一定很準備，除非是一些很明顯用意的欄位，例如性別這種，不然大部份的情況預測可能都會有誤差，因此這裡建議在一定的固定時間，來分析一下資料庫裡的索引資料，計算一些實際上的基數，來決定要不要補索引，或是移除索引。&lt;/p&gt;
&lt;p&gt;咱們通常可以使用以下指令，來在已運行的資料庫中，來看看某個欄位的基數大概是多大 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT COUNT(DISTINCT {field}/COUNT(*))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假設咱們有 1000 筆資料，然後這個欄位是性別欄位，那它的數字應該為 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2/1000 = 0.002
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這個數值越接近 1，代表越有建立索引的價值。&lt;/p&gt;
&lt;h4 id=&#34;step-3-&#34;&gt;Step 3. 決定使用的索引類型&lt;/h4&gt;
&lt;p&gt;基本上就是以下三種選擇 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般索引(覆蓋索引) : 在一些常用單獨 query，如果常常需要與其它欄位一起查詢，可考慮建連合索引。&lt;/li&gt;
&lt;li&gt;連合索引 : 常常需要與其它欄位一起查詢，適合建立。但是要注意先後順序，基本最常查詢的與基數高的適合放最左邊。&lt;/li&gt;
&lt;li&gt;前綴索引 : 這種大致上用在如果要針對某段文字進行前綴搜尋的情況。&lt;/li&gt;
&lt;li&gt;唯一索引 : 這種適合在此欄位放貨物編號或啥這種編號的，它可以順到幫你檢查是不是唯一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading3&#34;&gt;索引的使用注意事項&lt;/h2&gt;
&lt;h3 id=&#34;-1--1&#34;&gt;注意事項 1 : 連合索引的欄位順序&lt;/h3&gt;
&lt;p&gt;假設咱們有一個連合索引如下，由三個欄位 a、b、c 組合而成，而事實上在使用時，咱們可以將它想成有下以三種組合，當然這不代表他有存放三顆樹。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{a, b, c}
＝
{a}
{a,b}
{a,b,c}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後根據三序的組合，使用上有個準則。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有用到最左邊的欄位的才能使用連合索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上面連合索引範例為例，下面為使用的 sql 是否會用到索引的情境。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM Table WHERE a = ? ( good 索引 )
SELECT * FROM Table WHERE a = ? AND b = ? ( good 索引 )
SELECT * FROM Table WHERE b = ? AND a = ? ( good 索引 )


SELECT * FROM Table WHERE b = ? ( bad 全掃 )
SELECT * FROM Table WHERE c = ? ( bad 全掃 )
SELECT * FROM Table WHERE b = ? AND c = ? ( bad 全掃 )
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;-2--&#34;&gt;注意事項 2 : 儘可能使用索引的排序&lt;/h3&gt;
&lt;p&gt;首先有個重點要記得，如下圖 2 使用『 年齡 』所建立的索引 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;索引本身就是有排序的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190928/200893585Kfk3yVuqY.png&#34; alt=&#34;&#34;&gt;
圖 2 : 以年齡建立的索引&lt;/p&gt;
&lt;p&gt;這也代表如果要進行排序，儘可能的直接使用它，而不要讓資料庫另外開空間，來排序它。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;索引欄位: { age }

SELECT * FROM user WHERE age &amp;lt;= 30 ORDER BY age; ( good 索引 )

SELECT * FROM user WHERE age &amp;lt;= 30 ORDER BY name; ( bad using filesort )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中上述範例中 bad 的 filesort 就是代表 mysql 需要另外使用記憶體來排序，這可以在 explain 時看到。&lt;/p&gt;
&lt;h4 id=&#34;-&#34;&gt;那連合索引呢 ?&lt;/h4&gt;
&lt;p&gt;它也有排序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;連合索引是以最左邊的欄位排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以假設你有一個索引為 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ age, name }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那它預設就會以 age 來排序，如下圖 3 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190928/200893588gbWXljjJD.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;圖 3 : 連合索引排序&lt;/p&gt;
&lt;h3 id=&#34;-3--&#34;&gt;注意事項 3 : 有時太多索引，反而會讓優化器混亂&lt;/h3&gt;
&lt;p&gt;簡單的說，你有以下三欄位，a、b、c 然後請不要想說讓性能好一點，來個所有組合的索引。這樣不但多化了不少空間建 b+ 樹，而且還會讓 mysql 優化器選錯索引。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a、b、c
a、c、c
b、c、a
b、a、c
c、a、b
c、b、a
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這個問題，主要是從下面這篇文章得知，而且自已測試了以下，還真的是這樣，詳細的實際過程與結果，請連到下面的連結自已去看看。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.im/post/5d6881d4f265da03ab426341&#34;&gt;这句简单的sql，如何加索引？颠覆了我多年的认知&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;sql-&#34;&gt;SQL 地雷區&lt;/h2&gt;
&lt;h4 id=&#34;-1-----not-&#34;&gt;雷區 1 : 使用 != 、 &amp;lt;&amp;gt;、NOT 查詢會變全掃&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM user WHERE age != 20 ( bad 全掃 )
SELECT * FROM user WHERE age &amp;lt;&amp;gt; 20 ( bad 全掃 )
SELECT * FROM user WHERE age NOT IN(20) ( bad 全掃 )
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;-2---like-&#34;&gt;雷區 2 : 用 like 有索引也會變全掃&lt;/h4&gt;
&lt;p&gt;如果在 name 有建立索引，那有下面這種 sql 會變全掃。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM user WHERE name like &#39;%-Mark&#39; ( bad 全掃 )
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;-3----or-&#34;&gt;雷區 3 :  誤用 or 時會變全掃&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;索引欄位: {age}

SELECT * FROM user WHERE age = 18 OR name = &#39;C-Ian&#39;; ( bad 全掃 )

索引欄位: {age},{name} 

SELECT * FROM user WHERE age = 18 OR name = &#39;C-Ian&#39;; ( good 索引 )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是如果是用 and 則反之。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;索引欄位: {age}

SELECT * FROM user WHERE age = 18 AND name = &#39;C-Ian&#39;; ( good 索引 )
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;-4--where-&#34;&gt;雷區 4. 在 WHERE 欄位進行運算&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;索引欄位: {age}

SELECT * FROM user WHERE age/2 = 18; ( bad 全掃 )

SELECT * FROM user WHERE age = 18*2; ( good 索引 )
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;-5--&#34;&gt;雷區 5 : 使用一些函數&lt;/h4&gt;
&lt;p&gt;下面簡單以 rand() 這方法來說明，當你使用它時，它就是一定跑全掃&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM test.user where age &amp;gt;= RAND(); ( bad 全掃 )
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;-6--select--from&#34;&gt;雷區 6 : SELECT * FROM&lt;/h4&gt;
&lt;p&gt;因為這樣可能會讓你所建立的『 覆蓋索引 』失效，導致要先至 secondary index 查找再去。
clustered Index 抓資料。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;索引欄位: {name}

SELECT * FROM user; ( bad 會走 secondary index 再至 clustered Index )

SELECT name FROM user; ( good 只會走 secondary index )
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;-7---order-by-rand&#34;&gt;雷區 7 : 使用 ORDER BY RAND()&lt;/h4&gt;
&lt;p&gt;當你確定資料量非常小的情況下使用還行，但是資料量大時，你資料庫一定會倒。如果真的要做請把資料拉到應用層在做，資料庫真的非常的忙。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM test.user where age &amp;lt;= 18 ORDER BY RAND(); ( bad 會需要耗費空間排序 )
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading4&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;本篇文章中咱們學習到了一些設計優質索引的方法與流程，並且也簡單的列出一些雷區，關於這邊的雷區，順到來提一下 『 ORM 』這個東西。&lt;/p&gt;
&lt;p&gt;orm 基本上是一個將資料庫操作封裝成 model 化的技術，簡單的說你要查詢某樣東西那會如下操作 ，比較白話文就是你不需要自已寫 sql。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// SQL
SELECt * FROM user WHERE age = 18;

// ORM (以 laravel eloquent model 為範例)

$user = User::where(&#39;age&#39;, 18)-&amp;gt;get();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;當你使用了 orm 後就不在需要寫 sql，而是以 model 的角度來操作它，這樣的好處如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;資料庫以 model 型式抽像出來，也就是說如果你換資料庫了，也不太需要怕 ( 不過實際上不太會發生，這個好處是虛名…… 我真的一直這樣覺得 )。&lt;/li&gt;
&lt;li&gt;資料庫版本升級導致某些 sql 不支援或啥時，你應用層基本算應該就是升級一下 ORM 套件就可處理。&lt;/li&gt;
&lt;li&gt;最重要的一點，避免人為的雷包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而缺點就在於，你需要多耗費資源運算來處理。&lt;/p&gt;
&lt;p&gt;不過我事實上是屬於佔在 orm 這一派的人，雖然這 30 天的文章是以高性能為主。&lt;/p&gt;
&lt;p&gt;主要的原因有幾點 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;台灣吃性能吃到連 orm 這塊都不敢用，好像還真沒啥看過……。&lt;/li&gt;
&lt;li&gt;orm 吃一點性能沒錯，但是我通常相信會有性能貧頸的專案，通常不是因為用了 orm 的問題……。&lt;/li&gt;
&lt;li&gt;可以避免人為寫出雷 sql，我覺得可以減少不少的維護成本 ( Time is Money )。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果以追求高性能系統來看，的確是以 sql 為主沒錯，但是高性能不代表是一個好的系統，好的系統是需要平衡的，而我們要學會平衡的其中一個條件也就是理解何謂高性能 ( 對這是繞圈子 )。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;好的系統是需要平衡的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最後說一下，雖然哥追求高性能，但是我是個願意為了減少雷包風險，而犧牲點性能的人。因為維護成本真的高，尤其公司越大，維護成本越高，如果整間公司都是追求高性能而不管維護性，我只能保祐後人的身體健康。&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000007445807&#34;&gt;MySQL InnoDB索引介绍及优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000008131735&#34;&gt;MySQL 性能优化神器 Explain 使用分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/53868847&#34;&gt;MySQL 索引及查询优化总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000015416513&#34;&gt;Mysql联合索引最左匹配原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html&#34;&gt;8.2.1.3 Index Merge Optimization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5d6881d4f265da03ab426341&#34;&gt;这句简单的sql，如何加索引？颠覆了我多年的认知&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.itread01.com/content/1543336922.html&#34;&gt;mysql 索引建立與使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>