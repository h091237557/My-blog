<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IT 鐵人賽 2016 on 拿鐵派的馬克 Blog</title>
    <link>https://mark-lin.com/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD-2016/</link>
    <description>Recent content in IT 鐵人賽 2016 on 拿鐵派的馬克 Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <managingEditor>h091237557@gmail.com (marklin)</managingEditor>
    <webMaster>h091237557@gmail.com (marklin)</webMaster>
    <lastBuildDate>Fri, 30 Sep 2016 19:51:35 +0800</lastBuildDate>
    
        <atom:link href="https://mark-lin.com/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD-2016/index.xml" rel="self" type="application/rss+xml" />
    


    <item>
      <title>30-30之MongoDB三十天的學習之旅</title>
      <link>https://mark-lin.com/posts/20160930/</link>
      <pubDate>Fri, 30 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160930/</guid>
      <description>不知不覺~漫長的鐵人賽就進入了尾聲，當初會參加鐵人賽也只是因為，沒參加過 ~ 來試試看，而且也剛好我今年的時間比較多點兒，話說回來，為什麼我會選MongoDB來當題目呢?事實上也只是因為我自已無聊在做的專案，有把mongoDB拿來用，所以就想說認真的來研究一下mongoDB ~
我們簡單的總結一下我們這三十天學了那些東西。
首先最基本的一定是一個資料庫的CRUD，這階段就像玩天堂時的說話島一樣，你要打打哥布林。
 30-3之新手村CRUD&amp;mdash;新增 30-4之新手村CRUD&amp;mdash;新增之Bulk與新增效能測試 30-5之新手村CRUD&amp;mdash;更新 30-6之新手村CRUD&amp;mdash;更新之陣列欄位 30-7之新手村CRUD&amp;mdash;刪除 30-8之新手村CRUD&amp;mdash;搜尋之find與搜尋操作符號 30-9之新手村CRUD&amp;mdash;搜尋之陣列欄位與regex 30-10之新手村CRUD&amp;mdash;搜尋之Cursor運用與搜尋原理  然後在基礎的新手村畢業以後，你就可以坐船前往大陸，不過下船的地方在那我有點忘了。 接下來我們要學習的事情就是，要如何的使我們搜尋速度更快速。
 30-11之索引(1)&amp;mdash;索引的哩哩扣扣 30-12之索引(2)&amp;mdash;複合索引的坑 30-13之索引(3)&amp;mdash;比較特別的索引使用  在我們了解了如何將搜尋速度提升更快後，我們就可以來研究如何使用mongodb來進行資料分析，這個階段就像是龍之谷吧……年代有點久遠有點快忘了。
 30-14之聚合(1)&amp;mdash;Aggregate Framework的哩哩扣扣 30-15之聚合(2)&amp;mdash;Pipeline武器庫 30-16之聚合(3)&amp;mdash;潮潮的MapReduce  可是分析完後，我們發覺有些地方效能還不是不太好，明明索引那些都處理好囉 ? 這時我們只能往架構方面來尋找問題囉。
 30-17之MongoDB的設計&amp;mdash;正規與反正規化的戰爭  在以上的東西都已經學習的差不多時，這時我們就要來驗證一下，我們是否真的有學習進腦袋裡，這時最簡單的驗證方法，就是自已想個題目，然後從0 → 1 自已建立看看。順到一題0 → 1這本書真的不錯看。
 30-18之運用研究&amp;mdash;PO文模擬情境(1) 30-19之運用研究&amp;mdash;PO文模擬情境(2) 30-20之運用研究&amp;mdash;PO文情境模擬(3)  在驗證完以上的東西都學習會後，我們可以往分散式的東西進行學習囉，這邊應該就是傲慢之塔的等級囉。
 30-21之MongoDB的副本集 replica set(1) 30-22之MongoDB的副本集 replica set(2)&amp;mdash;使用Docker建立MongoDB Cluster 30-23之分片Sharding(1)&amp;mdash;Hello Sharding 30-24之分片Sharding(2)&amp;mdash;Chunk的札事 30-25之分片Sharding(3)&amp;mdash;片鍵的選擇  然後接下來的最後一部份也是驗證你上面的東西有沒有學會。
 30-26之運用研究&amp;mdash;股價應用模擬(1) 30-27之運用研究&amp;mdash;股價應用模擬(2) 30-28之運用研究&amp;mdash;股價應用模擬(3)  事實上到這邊應該就可以結束了，但我事實上有忘記一個主題，所以補充在最後面。
 30-29之補充&amp;mdash;忘了講的事務操作   最後忘了講幾句感言的話，事實上我很感謝上天，還能給予我可以參加30天鐵人賽的腦袋與體力，2016年應該是我目前的人生轉哲最大的年度，我生了一場重病，我得的病就是你們腦袋中最不想得的病排行板前三名， ~ 啊喲啊喲 ~ 小的才2開頭而以 ~ 啊喲啊喲 ~ 得這病是真的失去不少東西，而且治療過程，有時後我會想，似乎上天堂好像會輕鬆點兒，上一句只是完笑，得這鬼病也只有一條路，面對現實就對囉~</description>
    </item>
    
    <item>
      <title>30-29之MongoDB--- 事務操作的空虛感</title>
      <link>https://mark-lin.com/posts/20160929/</link>
      <pubDate>Thu, 29 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160929/</guid>
      <description>本篇文章是用來補充一下，前面忘了講的觀念，記得在第一篇時，我們有提過下面這句話。
 MongoDB 不支持事務操作
 但事實上這段話有很多觀念要來說明說明，不然很難讓人了解事務操作是啥，所以我們這篇要用來補充一下這個主題。
~ 事務操作是啥鬼 ~ 咱們首先先來了解一下，事務是啥?根據wiki的定義。
 資料庫事務是資料庫管理系統執行過程中的一個邏輯單位，由一個有限的資料庫操作序列構成。
 這邊用白話文來簡單說明一下，事實操作你可以把他想成一個工作流程，例如煮菜，你首先要先洗菜、切菜、丟到鍋子、加調味料，『煮菜』這名詞就是一個事務，它裡面包含了剛剛說明的流程。
我們轉回的在資料庫中的事務，假設我們是個證券商，我們收到使用者的下單通知，那我們資料庫會著麼進行? 我們下面來試試列出該事務操作過程。其中我們有兩個資料表accounts為使用者的帳戶資料、第二個為orders下單資料，呃對了先不管交割日這鬼，也就是付錢日。
 首先我們會先在orders新增一筆訂單。 再到accounts針對該使用者的帳戶進行扣款。  那如果發生錯誤時，事務會著麼處理?
根據以上的例子，我們拿來繼續使用，假設我們在第二個步驟，準備要扣款時，系統突然gg了，那要著麼樣?在一些資料庫中，當整個事務提交給資料庫時，它會保證這整個事務要嘛全部完成，要嘛全部沒完成。
也就是說，如果我們第二個步驟掛掉時，我們一開始在orders新增的一筆訂單會取消，會保持整個事務的完整性，不會只完成一半。
最後這邊我們來看一下事務操作的四個特性ACID，來腦補一下，以下內容為wiki，並且自已寫寫說明。
 原子性（Atomicity） : 要麼全執行、要麼全取消，沒得商量。 一致性（Consistency）: 這個是指在事務開始與結束後，資料庫的完整性約束沒有被破壞。 隔離性（Isolation）: 多個事務執行時，任一個事務不會影響到其它的事務。 持久性（Durability）: 代表即時停電或啥，事務一旦提交後，則持久化保存在資料庫中。  ~ MongoDB 不支援事務 ~ 對mongodb不支援事務，但它還是有支援一些符合各別特性的操作，總共有三個。
1. 在單個 document 上有提供原子性操作 findAndModify mongodb有提供單個document，操作，也就是說如果你要針對該document進行更新，要麼全部更新完成，不然就全部不更新，我們簡單用個範例來說明如何設計成，符合原子性的功能。
我們把上面的例子拿下來用。
 假設我們是個證券商，我們收到使用者的下單通知，那我們資料庫會著麼進行? 我們下面來試試列出該事務操作過程。其中我們有兩個資料表accounts為使用者的帳戶資料、第二個為orders下單資料，呃對了先不管交割日這鬼，也就是付錢日。
 但注意一點，如果我們是建立將accounts與orders分成兩個collection來建立，那我們就沒辦法使用mongodb所提供的原子性操作，因為就變為多document的操作。
所以我們需要將它修改為都存放在同一個collection，沒錯也就是進行反正規化，資料大概會變成這樣。
{ &amp;#34;user&amp;#34; : &amp;#34;mark&amp;#34; , balance : 10000 , orders : [ { &amp;#34;id&amp;#34; : 1 , &amp;#34;total&amp;#34; : 1000 , &amp;#34;date&amp;#34; : &amp;#34;20160101&amp;#34; }, { &amp;#34;id&amp;#34; : 2 , &amp;#34;total&amp;#34; : 2000 , &amp;#34;date&amp;#34; : &amp;#34;20160103&amp;#34;} ] } 然後我們進行交易時，我們需要先檢查balance確定是否有足的錢，然後在新增一筆下單到orders欄位中，最後才修改balance，而我們這時需要用到findAndModify ，它可以確保這筆交易的，在確定完balance後，不會有其它線程來更新它的balance。</description>
    </item>
    
    <item>
      <title>30-28之MongoDB運用研究---股價應用模擬(3)</title>
      <link>https://mark-lin.com/posts/20160928/</link>
      <pubDate>Wed, 28 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160928/</guid>
      <description>上一篇研究簡單的說明完，股價分析的運用操作後，接下來我們這篇文章將要說明一些程式交易的東西，不過雖然說是程式交易，但事實上也只是簡單的計算出技術分析指標然後產生出買賣時間點，要說是程式交易好像也不太算兒……。
~ 二哈的需求分析 ~ 今天咱們的二哈和我說，啊鳴~ 最近我想搞搞程式交易 ~ 幫我一下，然後我問他你想做啥，他竟然回，我也不知道也 ~ 我只是聽說那很潮、很容易賺錢 ~ 幫我咱 ~咱們是好哥吧，然後我一直在笑他你傻了啊，最後他就用出這種表情。
雖然很想和他說~你何不食屎忽 ~ 但想到要愛護動物就想是幫他想一下。
回到正題，說到程式交易我們先看一下智庫的定義。
 　程式交易在英文中叫做Program Trading, 就是將自己的金融操作方式，用很明確的方式去定義和描述，且遵守紀律的按照所設定的規則去執行交易。
 上面只是定義，不過我簡單的說明一下我的認知，就是『寫個策略計算出買賣點，然後叫電腦乖乖的進行交易』。
網路上以及論文都有提供一些策略，你可以自已去試試看，不過會不會賺錢小的我就不知道了，順到幫我老師打廣告一下，如果對金融應用感興趣的可以看看他寫的書，傳送門在此。
好再一次回來正題，那我們在這邊就簡單的講幾個策略……真的很簡單，因為我模擬的資料只有k線別忘囉。
 二哈可以利用30天移動平均線與當日開盤價進行買點與賣點的計算。 二哈可以用五天期的平均成交量低於十天前的五天期平均成交量的 75%這策略來進行交易。  就來這兩個吧~
~ 實作 ~ 二哈可以利用30天移動平均線與當日開盤價進行買點與賣點的計算 首先咱們先來完成這個需求，在投資股票時，有個東西你在看k線時，幾乎所有的開盤軟體都會提供，它就是移動平均線，其中它又有十天線、月線、季線、年線、二年線等，簡單來說，十天線就是用前十天的平均來計算出來的一條件，非常的Easy。
然後我們來看看我們的月線也就是30天期線的產生，首先先看看最外面有個變數temp，它是一個陣列，用來存放30天的開盤價，為了用來計算平均數用的，但有點注意，如果只是在外面宣告個var temp = []這樣在mongodb的mapreduce函數是無法使用的。
那要著麼使用呢 ? 拉下面一點會看到有個參數物件，其中的scope就是讓我們可以使用全域變數 temp 。
temp看完後在來看看我們的主體mapreduce，但在執行mapreduce之前，我們會先進行query，將code為8111的尋找出來，這邊有個金句要注意一下。
 盡可能的在進行資料分析時，先將不需要的資料篩選剔除掉，這是個黃金法則。
 var temp =[]; var result = db.stocks.mapReduce( function(){ if(temp.length &amp;lt; 30){ temp.push(this.open); emit(this.date,0); }else{ temp.splice(0,1); temp.push(this.open) var sum =0, avg =0, tempCount = temp.</description>
    </item>
    
    <item>
      <title>30-27之MongoDB運用研究---股價應用模擬(2)</title>
      <link>https://mark-lin.com/posts/20160927/</link>
      <pubDate>Tue, 27 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160927/</guid>
      <description>上一篇文章中，我們已經說明完基本的架構以及索引和分片的選擇，接下來我們就要實際的來使用資料來進行一些分析，能用搜尋時就用搜尋，不能用搜尋時就改用 aggreagate framework，然後如果再不能的話則用 mapreduce。
~ 二哈的分析需求 ~ 這二貨根本沒有想需求，只是想說來分析一下，但分析啥也沒說，然後還要我們幫他想一下，然後還用這種表情看我，一臉用這種事情還用問我的表情。
然後我們只能乖乖的幫他想幾個。
 二哈最基本應該會輸入股價代碼，然後輸出該股票的全部資料。 二哈想尋找出該股票某段區間的資料。 二哈想找出當日交易最熱絡的股票。 二哈想找出某日價格波動最高的股票。  那我們先開始吧。
~ 索引與片鍵的建立 ~ 呃對了，雖然上一篇文章中，我們已經將索引與片鍵選出來了，分別為
索引 : { &amp;quot;date&amp;quot; : 1 , &amp;quot;code&amp;quot; : 1 }
片鍵 : { &amp;quot;code&amp;quot; : 1 }
但咱們突然想到一件事，你要建立的片鍵，必須要有索引，當我們的索引是複合索引，這樣我們還可以使用{ &amp;quot;code&amp;quot; : 1 }來建立嗎? 我們來試試。
db.stocks.ensureIndex({ &amp;#34;date&amp;#34; : 1 , &amp;#34;code&amp;#34; : 1 }) sh.enableSharding(&amp;#34;test&amp;#34;) sh.shardCollection(&amp;#34;test.stocks&amp;#34;,{&amp;#34;code&amp;#34;:1}) 結果如下，看來是不行。
那要著麼辦呢?這時我們有三個辦法。
 再增加一個code索引。 選擇 { &amp;quot;date&amp;quot; : 1 }與{ &amp;quot;code&amp;quot; : 1}當索引。 片鍵修改為{ &amp;quot;date&amp;quot; : 1 , &amp;quot;code&amp;quot; : 1 }。  要選那個呢，首先先來說說第一個，增加一個索引，缺點就在於需要更多的空間，而且這索引搜尋時幾乎不太用到，因為幾乎被原本的 { &amp;quot;date&amp;quot; : 1 , &amp;quot;code&amp;quot; : 1 }可取代。</description>
    </item>
    
    <item>
      <title>30-26之MongoDB運用研究---股價應用模擬(1)</title>
      <link>https://mark-lin.com/posts/20160926/</link>
      <pubDate>Mon, 26 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160926/</guid>
      <description>前面幾篇文章我們說明完了分片的運用後，我們接下來，就來實際的模擬個情景，我們來學習要如何的一步一步完成，咱們選擇的模擬情境為股價應用，現在Fintech幾乎天天在報紙上看到，所以我們就來應景一下，來嘗試這建立看看金融應用。
~ 情景說明 ~ 二哈是一位二貨，他平常就有在進行投資，大部份都是買買股票，但平常都只是直接卷商的平台看看資料，然後就直接投資囉，但是這貨兒每買必輸每賣必虧，然後有一天他聽到天賴之音說『請分析一下』，然後它就決定走上資料分析一途……這貨真的很二
回歸主題，二哈的需求只是分析，所以我們再分析前，我們要先建立好資料，通常能分析的資料量是越大越好，所以我們這邊一定會需要用到分片，並且我們先從最基本的股票資料k線與成交量來建立資料，首先我們的資料結構應該如下。
{ 股價代碼	&amp;quot;code&amp;quot; : 1011, 日期	&amp;quot;date&amp;quot; : 20160101, 開盤價 &amp;quot;open&amp;quot; : 100, 最高價 &amp;quot;height&amp;quot; : 100, 收盤價 &amp;quot;close&amp;quot; : 90, 最低價 &amp;quot;low&amp;quot; : 80, 成交量 &amp;quot;volume&amp;quot; : 1000 } 然後我們來正試開始吧。
~ Step 1. 架構分析 ~ 索引架構思考 首先我們根據以上的資料結構可知，我們該主題目前不太需要考慮到正規化與反正規化的問題，那接下來我們來思考看看索引的問題，但那蠢二哈只想到分析但不知道分析啥，我們來幫他想想。
我們來一條一條列出，我們想到的需求。
 二哈最基本應該會輸入股價代碼，然後輸出該股票的全部資料。 二哈想尋找出該股票某段區間的資料。 二哈想找出當日交易最熱絡的股票。 二哈想找出某日價格波動最高的股票。  細細想一下，大部份的使用情境都一定需要時間，而且是個範圍，然後有時在搭配某個股票，所以我們基本上會針對date和code來考慮建立索引，那要選用那種索引呢，目前有三種選擇我們先列出。
第一種 { &amp;quot;date&amp;quot; : 1 , &amp;quot;code&amp;quot; : 1 } 第二種 { &amp;quot;code&amp;quot; : 1 , &amp;quot;date&amp;quot; : 1 } 第三種 { &amp;quot;code&amp;quot; :1 },{ &amp;quot;date&amp;quot; :1 } 還記得{ &amp;quot;sortKey&amp;quot; : 1 , &amp;quot;queryKey&amp;quot; : 1 }這個複合索引時有提到的東西麻，很常用來排序的請放前面，日期和股價代碼，理論上來說日期會很常用到排序，所以我們第二種索引可以刪除。</description>
    </item>
    
    <item>
      <title>30-25之MongoDB分片Sharding(3)---片鍵的選擇</title>
      <link>https://mark-lin.com/posts/20160925/</link>
      <pubDate>Sun, 25 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160925/</guid>
      <description>上一篇文章我們詳細的說明完分片的機制後，接下來我們就要來詳細的說明片鍵的選擇，片鍵的選擇關係到你的分片執行速度與效能，並且一但建立後，要再修改幾乎是不太可能的，所以請像選老婆一樣，用心的選~
 完美的片鍵定義(這鬼不存在的) 片鍵的種類  ~ 完美的片鍵定義(這鬼不存在) ~ 在我們開始學習片鍵的選擇前，我們要先知道，什麼樣的片鍵是最好的，最理想的，但想也知道最好的東西是不存在的，但我們還是要知道，才能給我們的選擇給個基準。
整體來說完美的片鍵有下面特性
 所有的新增、刪除、更新等寫的操作，都可以平均分配到所有的分片。 所有的搜尋等讀的操作，都可以平均分配到所有的分片。 所有的操作都只會發到相關的分片，例如更新時不會跑去分片內是空的進行更新。  我們先來說說第一個特性，如果沒有該項特性會發生什麼事情，假設我們的cluster有四個分片，我們當然是希望每個分片可以處理25%的事情，但是假設我們做那些寫的操作時(ex.新增)全部都集中在其中一個分片，那你會發覺那個分片會越來越大~越來越大~ ，而且別忘了我們上章節說的chunk分配，它是根據數量來進行分配，不是用大小，因此你的那個分片內的chunk不會分配到其它分片，這樣也就失去你用分片的意義了。
而至於第二點特性，mongos在處理搜尋請求時主要會分成下述兩種的處理方式。
 搜尋時不包含片鍵，則會將搜尋分配到發有的分片，然後合并搜尋結果，再返回給client。 搜尋時包含片鍵，則直接根據片鍵，然後找出要尋找的chunk，向相對的分片發送搜尋請求。  根據上面的說明，我們知道mongos的讀操作過程，然後我們這時在回來思考，如果這時搜尋時都集中在一個分片上，會發生什麼事，首先搜尋時不包含片鍵這種類型影響不大，但另一種就會影響到，因為原本該分散的壓力，反而都集中在一個分片，運氣不好搜尋請求過多，就爆掉了。
而至於第三點，就只是浪費資源囉~
這邊我們大概來整理一下，根據以上三點大概可以拆分成幾個良好片鍵的特性。
 容易分割片鍵 : 容易分割的片鍵可以使mongodb更容易的均衡各分片的資料量，不容易發生過大的分片，基數越大的走容易分割資料。   基數是指系統將資料分成chunk的能力，例如性別欄位就是個低基數的例子，只有男與女。
  高隨機性的片鍵 : 具有越高隨機性的片鍵，他所分割出來的資料越容易均衡，也代表可避免任何一個分片承受過多的壓力。 可以指向單個分片的片鍵 : 越可指向單個分片的片鍵，越能降低搜尋效能壓力，像是隨機型的片鍵就無法做到。  這世界沒有著麼美好的事情，基本上幾乎找不到完全符合上述的條件，所以相對的咱們只能選擇盡可能符合你需要的片鍵，而這時就只能根據你專案的需求來決定，例如說這專案是讀吃比較重還是寫吃比較重，比較最大的搜尋條件，或搜尋時間過久的搜尋，這時都是要考量的。
~ 一些片鍵的種類 ~ 這邊開始我們就要來說明一些片鍵的種類。
升序片鍵 這種類型的片鍵，大部份都是欄位為Date類型或是ObjectId，是種會根據時間來增加欄位，或是根據先後順序進來的欄位。
假如我們使用這種欄位做為片鍵，會發生什麼事情 ? 一開始建立片鍵時你不會看到什麼問題，而是再於你新增時會發生，假設我們有下面的分片cluster。
   shard001 shard002 shard003     {min~2000} {2007~2008} {2014~2016}   {2001~2003} {2009~2010} {2017~max}   {2004~2006} {2011~2013}     然後這時我們要問個問題，我們進行新增時，它會加到那個chunk?</description>
    </item>
    
    <item>
      <title>30-24之MongoDB分片Sharding(2)---Chunk的札事</title>
      <link>https://mark-lin.com/posts/20160924/</link>
      <pubDate>Sat, 24 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160924/</guid>
      <description>在上一篇文章中說明完基本的分片概念後，我們本章節要更深的了解分片內的chunk， 它是每個分片組成的東西，我們這篇將要說明它的拆分與分配機制。
 chunk的分配與拆分。  ~ chunk 的分配與拆分 ~ 在上一篇文章中，我們知道每個分片中都包含了多個chunk，而每chunk中，又包含了某個範圍的document組，我們先簡單來畫個圖複習一下。
然後我們接下來要討論的就是，mongodb是如何拆分chunk和如何將chunk分片到shard裡，首先我們先來看看chunk的拆分。
chunk 的拆分 首先我們先想一下，chunk它本身是一堆document的集合體，大概長降,我們使用上一章節的範例，來看一下chunk的詳細資訊，假設我們都已經分片好了，我們直接看結果。
首先我們需要先移動到一個名為config的資料庫。
use config &amp;gt; switched to db config 然後再執行db.chunks.find().pretty()來看一下，目前只有一個chunk，它目前窩在shard0000，而它的範圍是min ~ max，呃對了忘了說，我們的資料是1萬筆的{&amp;quot;name&amp;quot;:&amp;quot;user&amp;quot;+i}這種物件。
這時我們要問個問題囉，它什麼時後會再分成另一個chunk ?
答案是chunk的大小，mongodb預設chunk最大限制為64MB，當超過時mongos會將它拆分為兩塊chunk，如下圖，此圖為官方圖片。
預設是64MB，當然我們也有辦法修改預設，指令如下，下面32代表為32MB。
use config &amp;gt; switched to db config db.settings.save({&amp;#34;_id&amp;#34; : &amp;#34;chunksize&amp;#34; : &amp;#34;value&amp;#34; : 32}) 但是這邊要修改大小時有幾點要思考一下。
 chunk 越小時可以使分片的可以使分片的資料量更均衡，不會有差距太大的狀況，但缺點就是，因為小所以會常移動chunk，所以mongos壓力會比較重。
 chunk 的拆分實驗 咱們來簡單的測試看看chunk的拆分，首先來建立一些資料，大小約為4188890 byte大概為4mb左右，然後我們的chunk大小預設為1mb，所以理論上應會開拆為3~4個chunk。
var objs = []; for (var i=0;i&amp;lt;100000;i++){ objs.push({&amp;#34;name&amp;#34;:&amp;#34;user&amp;#34;+i}); } db.users.insert(objs); 建好後別忘了執行這兩個指令。
db.users.ensureIndex({&amp;#34;name&amp;#34;:1}) sh.shardCollection(&amp;#34;test.users&amp;#34;,{&amp;#34;name&amp;#34;:1}) 然後我們指行sh.status()來看看結果，呃我淚囉為什麼會拆分為8個……
我們來檢查一下chunk size的設定，如下圖嗯沒錯~是1。
use config db.</description>
    </item>
    
    <item>
      <title>30-23之MongoDB分片Sharding---Hello Sharding</title>
      <link>https://mark-lin.com/posts/20160923/</link>
      <pubDate>Fri, 23 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160923/</guid>
      <description>本篇文章將要說明 mongodb 的分片`，上一章節說明了如何將資料同步到其它台節點上，而本篇文章是將要說明，如何將資料分割到其它台節點，讓我們可以更快速、更多容量空間的來做一些哩哩扣扣的事情。
 分片原理。 分片實作。  ~分片原理~ 分片是啥 ? 它主要的概念就是將collection拆分，將其分散到不同的機器，來分擔單一server的壓力。
咱們先來看看我們平常單一server的mongodb結構，其中mongod就代表我們實際上存放資料的地方，它平常都是指令和client端通信，client就有點像咱們平常用的mongodb shell之類的。
而咱們在來看看，如果用了分片會變啥樣，如下圖，三個mongod都會統一通信到mongos，在和client進行通訊，mongos不存儲任何資料，它就是個路由server，你要什麼資料就發給它，它在去決定去那個mongod裡尋找資料。
那這邊有個問題來囉~這三個mongod要著麼決定誰要存放那些資料 ? 答案是下面標題片鍵~
片鍵 Shard Keys 片鍵是啥 ? 它就是當你要進行分片時，你選定的collection切分的依據，假設我們有下面的資料。
{ &amp;quot;name&amp;quot;:&amp;quot;mark&amp;quot; , &amp;quot;age&amp;quot; :18} { &amp;quot;name&amp;quot;:&amp;quot;steven&amp;quot; , &amp;quot;age&amp;quot; :20} { &amp;quot;name&amp;quot;:&amp;quot;ian&amp;quot; , &amp;quot;age&amp;quot; :20} { &amp;quot;name&amp;quot;:&amp;quot;jack&amp;quot; , &amp;quot;age&amp;quot; :30} { &amp;quot;name&amp;quot;:&amp;quot;stanly&amp;quot; , &amp;quot;age&amp;quot; :31} { &amp;quot;name&amp;quot;:&amp;quot;jiro&amp;quot; , &amp;quot;age&amp;quot; :32} { &amp;quot;name&amp;quot;:&amp;quot;hello&amp;quot; , &amp;quot;age&amp;quot; :41} { &amp;quot;name&amp;quot;:&amp;quot;world&amp;quot; , &amp;quot;age&amp;quot; :52} ... ... { &amp;quot;name&amp;quot;:&amp;quot;ho&amp;quot;,&amp;quot;age&amp;quot; : 100} 它就有可能會分片成這樣，假設咱們拆分為三片，然後我們指定片鍵為age欄位，它就大致上可能會分成這樣，會根據片鍵建立chunk，然後再將這堆chunk分散到這幾個分片中，{min~10}就是一個chunk，就是一組document。</description>
    </item>
    
    <item>
      <title>30-22之MongoDB的副本集 replica set(2)---使用Docker建立MongoDB Cluster</title>
      <link>https://mark-lin.com/posts/20160922/</link>
      <pubDate>Thu, 22 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160922/</guid>
      <description>上篇文章我們已經說明完，如何在本機上建立 mongodb 副本集，而本篇文章，我們將要實際的使用docker來建立有三個節點的副本集，也就是所謂 cluster 。
 開始前的準備 建立架構圖 fight !  ~開始前的準備~ 首先再開始之前你當然要先將docker裝好，可以參考下面這章，但你的docker compose那邊可以不用做到，因為我還沒研究出，如何用docker compose來建立cluster……QQ。
 30-2之使用Docker來建構MongoDB環境
 確定執行docker --version有類似下面的資訊出來就ok囉。
Docker version 1.12.3, build 6b644ec 接下來呢咱們需要下載mongodb image，平常我們都是用docker compose直接執行它都會幫我們偷偷下載好，而現在我們就需要自已下載，指令如下。
docker pull mongo 然後咱們就都準備好囉。
~建立架構圖~ 我們來看看下圖，首先我們會先建立一個cluster取名為my-mongo-cluster，然後裡面有三個mongodb並且對外連接port設為30001、30002、30003，並且這三個的container都可以互相溝通。
~建立流程~ Fight !
step1 將my-mongo-cluster加入到docker network裡 我們先執行看看docker network ls然後會出現下圖的列表。
然後我們再執行下面的指令將新增個network到docker network裡。
docker network create my-mongo-cluster 然後你就可以看到我們將my-mongo-cluster加入至docker network裡。
Step2 建立三個 MongoDB 的 Container，並加入至 my-mongo-cluster 這 network 中 首先來看看指令，然後我們來解釋一下每個指令是啥意思。
 docker run : 就只是執行docker而以。 -p 30001:27017 : 將port:27017暴露出來，為了讓其它mongodb可連接到，而30001則為該container的本機port。 --name mongo1 : 將該container命名為mongo1。 --net my-mongo-cluster  : 將該container加入到my-mongo-cluster這docker network裡面，然它們可以互相通信。 mongo mongod --replSet my-mongo-set : 運行mongod時將該mongo加入到名為my-mongo-set的副本集中。  docker run -p 30001:27017 --name mongo1 --net my-mongo-cluster mongo mongod --replSet my-mongo-set 記好上面這些是要縮成一行來執行，如下。</description>
    </item>
    
    <item>
      <title>30-21之MongoDB的副本集 replica set(1)</title>
      <link>https://mark-lin.com/posts/20160921/</link>
      <pubDate>Wed, 21 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160921/</guid>
      <description>本篇文章將要說明， mongodb 的副本集。嗯~想想一個情況，現在咱們只使用一台 server 來存放資料，我們現在只是測試和開發， GG 囉也只是啊一聲，但如果是正式上線環境呢 ? GG 囉可不是啊一聲就可以解決的，你可能就被老闆不要不要的，很慘的~ 而副本集就是用來解決這問題，事實上也就只是被備份。
 副本集原理 副本集建立(單機版給你好測試)  ~副本集原理~ 首先我們先看看mongodb官網所提供的圖。
上面這張圖，你可以想成這個系統它有三個mongodb，其中primary節點接受所有client端的讀或寫，整個副本集只有一個primary，並且每當有資料新增時，primary會同步到其它兩個secondary。
然後當primary節點GG的話，會變成下面這張圖的結果(一樣來至官網)。
在這裡面，各節點都是通過一個叫心跳請求(heartbeat request)的機制來通信，如果當primary節點如果在10秒內無法和其它節點進行通信，這系統會自動從secondary節點中選取一個當主節點。
~副本集建立~ 在上面大概簡單的了解完它的原理後，我們就實際上的來操作看看，首先我們執行下面指令， 來進行到沒有db的mongodb shell環境。
mongo --nodb 然後通過下面的指令，就可以建立一個副本集，其中nodes : 3代表三個節點，一個primary其它兩個為secondary。
replicaSet = new ReplSetTest({&amp;quot;nodes&amp;quot;:3}) 不過執行完上面這行指令它還沒啟動喔還需要執行下面兩行，startSet為啟動那三個節點的進程，而initiate為設定複制功能。
replicaSet.startSet() replicaSet.initiate() 當執行完上面兩行後，我們就要跳到另一個Shell，然後連接到primary的節點，喲~?那它的port是啥?雖然有些文章中說預設是31000、31001、31002但我的電腦卻不是，所以建議還是在執行startSet時看一下，它應該會輸出下面這張圖的資訊。
嗯看到了吧，通常第一個就是primary，不是的話就試試其它的，然後我們這時就可以執行下面指令進入到它的裡面了。
conn1 = new Mongo(&amp;#34;127.0.0.1:20000&amp;#34;) 接下來我們就可以執行一些指令來看看這個副本集的狀態。
primaryDB = conn1.getDB(&amp;#34;test&amp;#34;) primaryDB.isMaster() 結果如下，其中isMaster這欄位就是說明這節點是primary節點。
~驗證一下有沒有備份到 secondary 節點~ 首先我們先新增一些資料。
var objs = []; for (var i=0;i&amp;lt;10;i++){ objs.push({&amp;#34;name&amp;#34;:&amp;#34;user&amp;#34;+i}); } primaryDB.users.insert(objs); 然後我們這時連到secondary。
conn2 = new Mongo(&amp;#34;127.0.0.1:20001&amp;#34;) 進去後在輸入。
secondaryDB = conn2.</description>
    </item>
    
  </channel>
</rss>