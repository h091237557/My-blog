<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>it 鐵人賽 2018 on 拿鐵派的馬克 Blog</title>
    <link>https://mark-lin.com/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD-2018/</link>
    <description>Recent content in it 鐵人賽 2018 on 拿鐵派的馬克 Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <managingEditor>h091237557@gmail.com (marklin)</managingEditor>
    <webMaster>h091237557@gmail.com (marklin)</webMaster>
    <lastBuildDate>Sun, 30 Sep 2018 19:51:35 +0800</lastBuildDate>
    
        <atom:link href="https://mark-lin.com/tags/it-%E9%90%B5%E4%BA%BA%E8%B3%BD-2018/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>30-30之寫給想入門影音直播開發的 Junior 工程師攻略本</title>
      <link>https://mark-lin.com/posts/20180930/</link>
      <pubDate>Sun, 30 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180930/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;這辛苦的三十天總於結束了，當初原本只是想要理解直播相關協議的東西一下，但是卻發現越來越多奇怪的名詞跑了出來，就算大概的知道 HLS 是要做什麼，但你總是會覺得前後知識好像缺了什麼，別人問你一下沒有 HLS 前是如何處理直播傳輸你大概就會倒了，然後上網查查相關知識，但卻發現總是沒有連貫起來的知識，越看越冒出更多的名詞，這對一名想入門影音直播開發的初學者，真的非常的辛苦。&lt;/p&gt;
&lt;p&gt;因此最後就想說當個好人將這方面的知識都整理成一條線好了，因此就產生了這三十篇的文章。&lt;/p&gt;
&lt;p&gt;這三十天的文章基本上理解完後，要開發出一個直播應用事實上就不是太難的事情了，而且你有了這三十篇的知識你接下來要將直播應用開發的更好，你就也更有本錢去學習更進階的東西囉。&lt;/p&gt;
&lt;p&gt;接下來這篇文章就來總結一下這三十天咱們學習了那些東西。&lt;/p&gt;
&lt;h2 id=&#34;-junior-&#34;&gt;影音直播開發的 Junior 工程師攻略本&lt;/h2&gt;
&lt;p&gt;基本上前二十篇是最基礎的東西，這幾篇文章就在說明，如何將一個人的聲音或影像傳遞給對方。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181016/20089358XW7L8hFZHQ.png&#34; alt=&#34;&#34;&gt;!&lt;/p&gt;
&lt;h3 id=&#34;heading1&#34;&gt;聲音與影像的採集、編碼與封裝&lt;/h3&gt;
&lt;p&gt;首先這五篇文章我們學習了聲音與影像是如何的儲放在電腦裡面，並且因為原始的聲音與影像太大，所以我們需要使用編碼來進行壓縮，最後就準備需要將聲音與影像進行封裝，為了可以讓別人一打開來知道要如何處理這一段聲音或影像編碼。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180902/&#34;&gt;30-02之聲音的採集與原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180903/&#34;&gt;30-03之聲音的編碼與壓縮&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180904/&#34;&gt;30-04之影像的採集與原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180905/&#34;&gt;30-05之影像的編碼與壓縮&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180906/&#34;&gt;30-06之聲音與影像的封裝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來的兩篇文章，咱們就使用 WebRTC 的一些東西，來實作如何的採集聲音與影像，並且最後將它封裝成一個檔案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180907/&#34;&gt;30-07之Web 如何進行語音與影像採集 ?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180908/&#34;&gt;30-08之 WebRTC 採集的詳細說明與聲音的加工&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading2&#34;&gt;聲音與影像的傳輸&lt;/h3&gt;
&lt;p&gt;咱們已經可以將聲音與影像封裝後，就可以開始傳輸給遠方的某個人。&lt;/p&gt;
&lt;p&gt;我們一開始先探討讓對方收到聲音與影像的方法有那些。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180909/&#34;&gt;30-09之別人要如何聽到我的聲音呢 ?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來花了幾篇文章來理解網路傳輸協議。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180910/&#34;&gt;30-10之通訊協議的基本常識&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180911/&#34;&gt;30-11之 TCP 與 UDP 協議&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180912/&#34;&gt;30-12之 RTP/RTCP 傳輸協議&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180913/&#34;&gt;30-13之 RTSP 傳輸協議&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180914/&#34;&gt;30-14之 RTMP 傳輸協議&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180915/&#34;&gt;30-15之 HLS 傳輸協議&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180916/&#34;&gt;30-16之 HTTP-FLV 傳輸協議&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180917/&#34;&gt;30-17之 MPEG-DASH 傳輸協議&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180918/&#34;&gt;30-18之影音傳輸協議總整理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在理解完上面幾篇文章以後，我們應該是可以將聲音與影像傳輸給遠方的某個人。&lt;/p&gt;
&lt;h3 id=&#34;heading3&#34;&gt;聲音與影像的拆封&lt;/h3&gt;
&lt;p&gt;某個人透過網路傳輸協議收到了這一段聲音與影像以後，我們接下來就是要將聲音與影像直出，事實上它的過程就是與上面的採集、編碼、封裝相反的過程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180919/&#34;&gt;30-19 之收到聲音後要如何的播出呢 ? ( FFMpeg )&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading4&#34;&gt;直播與點直的實作&lt;/h3&gt;
&lt;p&gt;基本概念學習完後，接下來就來進行一些實際上的實作。&lt;/p&gt;
&lt;p&gt;下面幾篇文章中，我們簡單的實作了直播與點播的功能，並且探討了最簡單版本的問題，並且在使用 CDN 加以的改善，事實上到了這裡，大部份就是一般直播與點播平台的雛形。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180920/&#34;&gt;30-20之如何建立像 KKTV 一樣的點播功能呢 ?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180921/&#34;&gt;30-21之如何建立的像 17 一樣的直播功能呢 ?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180922/&#34;&gt;30-22之點播與直播可動版問題探討&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180923/&#34;&gt;30-23之 CDN 的說話島 ( AWS CloudFront CDN 實作 )&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180924/&#34;&gt;30-24之直播與點播可動版的改良 ( 正式版 )&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading5&#34;&gt;進階&lt;/h3&gt;
&lt;p&gt;最後的幾篇文章，就來探討一些更進階的東西，那就是連麥直播互動，這個應用幾乎算是影音直播開發的一到高牆，沒有上面幾篇基礎文章的觀念，那是非常難完成的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180925/&#34;&gt;30-25之直播連麥的挑戰與方案 ( P2P )&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180926/&#34;&gt;30-26之 WebRTC 的 P2P 即時通信與小範例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180927/&#34;&gt;30-27之 WebRTC 的 Signaling Server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180928/&#34;&gt;30-28之 WebRTC 連線前傳 - 為什麼 P2P 連線很麻煩 ? ( NAT )&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180929/&#34;&gt;30-29之 WebRTC 的 P2P 打洞術 ( ICE )&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這裡順到說一下 WebRTC 並不一定是連麥直播的最佳解，但是它裡面所使用的概念，我覺得可以幫助我們導到最佳解，因此這裡才將它拿出來探討。&lt;/p&gt;
&lt;h3 id=&#34;heading6&#34;&gt;最後希望這一系列的文章，可以幫助到想學習影音直播開發的工程師們，節省更多的時間。&lt;/h3&gt;
&lt;h3 id=&#34;-&#34;&gt;結束拉 !!!&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>30-29之 WebRTC 的 P2P 打洞術 ( ICE )</title>
      <link>https://mark-lin.com/posts/20180929/</link>
      <pubDate>Sat, 29 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180929/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;上一篇文章中，咱們已經理解了為什麼 P2P 連線如此的困難，接下來這篇文章咱們將要學習：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WebRTC 是如何進行打洞與連線呢 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;webrtc--ice&#34;&gt;WebRTC 的打洞流程 ICE&lt;/h2&gt;
&lt;p&gt;WebRTC 它主要使用一個名為&lt;code&gt;ICE&lt;/code&gt; ( Interactive Connectivity Establishment ) 的框架來進行打洞，它內部整合了 STUN 與 TURN 協議，下面簡單的說明一下這兩個協議。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STUN&lt;/code&gt; ( Session Traversal Utilities for NAT ) 中文為 NAT 對談穿透應用程式，它的最主要用處就是幫助在 NAT 內的用戶找到可以連到它的位置。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc3489&#34;&gt;STUN-RFC3489&lt;/a&gt;
&lt;a href=&#34;https://tools.ietf.org/html/rfc5389&#34;&gt;STUN-RFC5389&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TURN&lt;/code&gt; ( Traversal Using Relay NAT )，它也是一種穿透 NAT 的一樣協議，不過它是使用中繼的方式來進行，通常都是 STUN 的候選位置都無法連線時，才會使用它。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc5766&#34;&gt;TURN-RFC5766&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;webrtc-&#34;&gt;WebRTC 連線流程&lt;/h3&gt;
&lt;p&gt;假設目前要連線的雙方情況如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A 內網位置：192.168.1.1:5555
B 內網位置：10.10.1.1:7777
A 外網位置(經過 NAT 轉換)：310.110.1.1:9000
B 外網位置(經過 NAT 轉換)：210.210.1.1:7000
TURN Server：111.111.111.111
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下圖為示意圖。表示雙方去外部連 Server 時對外的的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181113/20089358jucEGcOLeY.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下來咱們就開始進行 ICE 打洞流程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A 想和 B 進行 P2P 連線&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;step1--a--stun-server-&#34;&gt;Step1. 用戶 A 準備發起請求前，先至 STUN Server 收集候選位置。&lt;/h3&gt;
&lt;p&gt;在向 Signaling Server 建立連線請求前前，會先去 STUN Server 收集本機用戶 A 的&lt;code&gt;候選位置&lt;/code&gt;，這個位置就是用來給別人可以連到我的位置。&lt;/p&gt;
&lt;p&gt;其中候選位置如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主機候選項：如果本機在 NAT 裡面，則為私有位置(192.168.1.1:5555)。&lt;/li&gt;
&lt;li&gt;STUN 反射候選項：如果本機在 NAT 裡面，則為最外層 NAT 的外網位置。(310.110.1.1:9000)&lt;/li&gt;
&lt;li&gt;對等反射候選項：這是在進行檢查候選項連線期間發現新的才會有。&lt;/li&gt;
&lt;li&gt;中繼後候項：就是 TURN Server 位置。(111.111.111.111)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181113/20089358dkXJ33lujB.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;step2--a--signaling-server--a--sdp&#34;&gt;Step2. 用戶 A 向 Signaling Server 提交 A 的 SDP&lt;/h3&gt;
&lt;p&gt;上面收集完以候選位置以後 A 就會向 Signaling Server 請求和 B 進行連線，並且附加包含 A 的候選位置的 SDP 給 Server。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181113/20089358uZ6br6Jn3C.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;step3--b--signaling-server--stun-server-&#34;&gt;Step3. 用戶 B 收到 Signaling Server 請求後，也至 STUN Server 收集候選位置&lt;/h3&gt;
&lt;p&gt;用戶 B 從 Signaling Server  收到 A 的連線請求與 SDP 後，也前往 STUN 收集 B 自已的候選位置，為了讓 用戶 A 可以連自已。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181113/20089358zYrlyHsYlA.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;step4--b--signaling-server-&#34;&gt;Step4. 用戶 B 回覆 Signaling Server 答應請求&lt;/h3&gt;
&lt;p&gt;用戶 B 取得完自已的候選位置後，它會將這些資訊包含在 SDP 內，回覆給 Signaling Server，然後 Server 在將 B 的 SDP 回覆給用戶 A 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這時雙方都有了對方的候選位置了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181113/20089358fifTOPoqEn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;step5--sdp-&#34;&gt;Step5. 雙方開始使用 SDP 內的候選位置嘗試連線。&lt;/h3&gt;
&lt;p&gt;然後這時雙方 ICE 就會開始使用後選位置來進行嘗試連線。&lt;/p&gt;
&lt;p&gt;這裡有件事情要注意：&lt;/p&gt;
&lt;h4 id=&#34;ice-&#34;&gt;ICE 會根據下圖的順序來嘗試&lt;/h4&gt;
&lt;p&gt;ICE 會先從本機候選位開始來嘗試，因為如果嘗試成功了，就代表雙方在同一個 NAT 後面，這樣就會直接的使用這個本機候選位來進行 P2P 連線，因為這樣是效能最好的&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181113/20089358dHnIVW525h.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;step61--p2p-&#34;&gt;Step6-1. 嘗試成功，開始進行 P2P 連線。&lt;/h3&gt;
&lt;p&gt;如果其中一個有成功，那就會開始進行 P2P 連線，然後就可以開始傳送聲音囉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181113/20089358J0odRGWh0S.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;step62--turn---p2p-&#34;&gt;Step6-2. 嘗試失敗，轉成使用 TURN 開始進行中介連線 (這時就不是 P2P 了)&lt;/h3&gt;
&lt;p&gt;但如果前三個都失敗了，那就只能選擇備案，那就是使用 TURN Server 那進行中繼連線了，但這樣的確就不算是 P2P 連線了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181113/20089358RjpcmlOvXI.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-turn-&#34;&gt;通常需要用到 TURN 的原因&lt;/h4&gt;
&lt;p&gt;通常需要用到 TURN Server 來進行的原因在於：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;雙方其中一邊是使用 Symmetric NAT，也就是所謂的對稱形 NAT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最主要的問題就是，這種對稱形的 NAT 它所配置的 PORT 會變。&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;本篇文章中咱們學到了 WebRTC 的 P2P 打洞技術 ICE，它是一個包含了 STUN 與 TURN 的 NAT 打洞框架，某些情況下，ICE 幾乎可以說是 100 % 的打洞率，因為它最後還有一個 TURN，但是如果真的需要到使用 TURN 的話那就不是 P2P 連線了，這種時後在連麥直播時就會出問題了。&lt;/p&gt;
&lt;p&gt;至於有沒有什麼解決方法呢 ? 目前還真想不到呢 ~ 這之後在來研究吧 ~&lt;/p&gt;
&lt;h4 id=&#34;heading2&#34;&gt;備註&lt;/h4&gt;
&lt;p&gt;上面的一些圖片中 IP 有用到 310 的那個，那是錯的，範例應該只到 255，不過我懶的改了，反正只是範例。&lt;/p&gt;
&lt;h2 id=&#34;heading3&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.gtwang.org/web-development/webrtc-peer-connection/&#34;&gt;WebRTC 入門教學（二）：以 RTCPeerConnection 建立 Peer-to-peer 連線&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rainzhaojy/blogs/issues/4&#34;&gt;WebRTC下的网络连接: STUN, TURN, ICE, TCP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/002c06b48b98?utm_campaign=maleskine&amp;amp;utm_content=note&amp;amp;utm_medium=seo_notes&amp;amp;utm_source=recommendation&#34;&gt;[转]STUN/TURN/ICE协议在P2P SIP中的应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-28之 WebRTC 連線前傳 - 為什麼 P2P 連線很麻煩 ? ( NAT )</title>
      <link>https://mark-lin.com/posts/20180928/</link>
      <pubDate>Fri, 28 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180928/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;在開始說明 WebRTC 如何建立 P2P 連線前，咱們要先理解一件事情，那就是 WebRTC 要使用非常多的 P2P 連線技術，那位啥它需要使用如此多的技術呢 ? 那就是本篇文章要探討的主題：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;為什麼 P2P 連線很麻煩呢 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因為如果你理解了這個問題，你就會知道為什麼 WebRTC 要使用怎麼多的技術來進行 P2P 連線囉，這也是為什麼我們會先說明這篇文章。&lt;/p&gt;
&lt;p&gt;本篇文章的問題，為什麼 P2P 的連線會很麻煩呢 ? 最主要的問題在於：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NAT 與防火牆的存在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此本篇文章將針對這兩個東西來理解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NAT 與防火牆是啥 ?&lt;/li&gt;
&lt;li&gt;NAT 的運作原理。&lt;/li&gt;
&lt;li&gt;為什麼有了 NAT 後 P2P 會很麻煩 ?&lt;/li&gt;
&lt;li&gt;NAT 的分類。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nat--&#34;&gt;NAT 與防火牆是啥 ?&lt;/h2&gt;
&lt;h3 id=&#34;nat&#34;&gt;NAT&lt;/h3&gt;
&lt;p&gt;NAT (Network Address Translation) 中文就做網路位置轉換，它是用來將私網 IP 轉換成公網 IP 的技術。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181112/20089358uIvytHQF4j.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-nat-&#34;&gt;為啥會有 NAT ?&lt;/h4&gt;
&lt;p&gt;先說說它的起源。&lt;/p&gt;
&lt;p&gt;在咱們世界裡有個叫 IPV4 的地址規則，由於它數量稀少，不可能讓每一台電腦都有一個地址，因此就有了以下的解法如下圖，就是每個家庭或公司只有一組地址，然後公司內的電腦就使用這位置來上網。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181112/20089358LoYXoAE97j.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中常用的私有 IP 段為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10.0.0.0 ~ 10.255.255.255&lt;/li&gt;
&lt;li&gt;172.16.0.0 ~ 172.31.255.255&lt;/li&gt;
&lt;li&gt;192.168.0.0 ~ 192.168.255.255&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這樣的確就可以解決 IPV4 位置不足的問題，那這裡問個問題。&lt;/p&gt;
&lt;h4 id=&#34;-ip--&#34;&gt;那這樣私有 IP 要如何連到外面上網呢 ?&lt;/h4&gt;
&lt;p&gt;因為假設一台外網的 Server 收到一個從 192.168.0.1 來的請求，那他在回覆時要送給誰呢 ? 說不定在那台 Server 所在的網路中也有一個 192.168.0.1，那這樣回覆就會送錯人囉。&lt;/p&gt;
&lt;p&gt;而這就是 NAT 最主要的功能，將內網的 IP 對應到外網的 IP。&lt;/p&gt;
&lt;h3 id=&#34;heading1&#34;&gt;防火牆&lt;/h3&gt;
&lt;p&gt;防火牆基本上所處的位置如下圖，它就是外網與內網的守門員，它最主要職則就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;決定誰可以通過我 (防火牆)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181112/2008935889mzadtVYm.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading2&#34;&gt;兩者差異&lt;/h3&gt;
&lt;p&gt;基本上你會發現防火牆所在的位置與 NAT 所在的位置很相似，但是記好他們兩個的職則不太一樣：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NAT：負責外網 IP 與 內網 IP 的映射。&lt;/li&gt;
&lt;li&gt;防火牆：負責維護內網的安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不過現在很多情況下 NAT 事實上會包含了一些防火牆在做的事情，所以接下來我們就專心的來研究 NAT。&lt;/p&gt;
&lt;h2 id=&#34;nat-&#34;&gt;NAT 的運作原理&lt;/h2&gt;
&lt;p&gt;接下來這章節我們來詳細的理解一下 NAT 的實際運作原理。&lt;/p&gt;
&lt;p&gt;假設：&lt;/p&gt;
&lt;p&gt;A 在馬克公司內，想連到外部網站 B&lt;/p&gt;
&lt;p&gt;A 的 IP：192.168.1.1
B 的 IP : 210.110.1.1
馬克公司 IP：310.110.1.1&lt;/p&gt;
&lt;p&gt;NAT 對映表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;內網 IP&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;外網 IP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;192.168.1.1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;310.110.1.1:9000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;192.168.1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;310.110.1.1:9001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;192.168.1.3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;310.110.1.1:9002&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;那這樣連線流程如下圖。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A (192.168.1.1) 的封包抵達 NAT。&lt;/li&gt;
&lt;li&gt;NAT 將封包內的 source ip 修改成 310.110.1.1:9000 (根據對映表)。&lt;/li&gt;
&lt;li&gt;NAT 將 A 的封包(310.110.1.1:9000) 發送到 B (210.110.1.1)。&lt;/li&gt;
&lt;li&gt;B (210.110.1.1) 的回應抵達 NAT。&lt;/li&gt;
&lt;li&gt;NAT 將 B 發的封包根據對映表，來決定此幫包該發給誰。&lt;/li&gt;
&lt;li&gt;NAT 將 B 的封包發送到 A (192.168.1.1)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181112/20089358HCusgn8TNn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;-nat--p2p--&#34;&gt;為什麼有了 NAT 後 P2P 會很麻煩 ?&lt;/h2&gt;
&lt;p&gt;為什麼有了 NAT 後 P2P 連線會很麻煩 ?&lt;/p&gt;
&lt;p&gt;最主要的原因在於：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NAT 不允許外網主機直接訪問內網&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;當然這不是完全不行，假設如果你要在內網中架台 Server 給外部使用，那的確可以特別設置讓外部的人可以連線進來。&lt;/p&gt;
&lt;p&gt;但是正常來說大部份都是無法直接連進來的，如果可以就代表你公司內部的電腦被外人看光光，但是 P2P 連線就是需要雙方都可以主動建立連線，這也是為什麼要建立 P2P 連線會很麻煩的關係。&lt;/p&gt;
&lt;p&gt;還有另一個原因在於，就算你知道了對方的 IP 與 Port 以後，你要進行連線還是一定要經過 NAT 這時如果你不在 NAT 的允許進來名單裡面，那你就一定進不來的。&lt;/p&gt;
&lt;h2 id=&#34;nat-1&#34;&gt;NAT 的分類&lt;/h2&gt;
&lt;p&gt;NAT 事實上有分很多類型，如果要學習 NAT 穿洞技術，那第一個條件就是要先了解你要穿的洞是什麼類型，這樣才能做相對應對策略，其本上分為以下四種類型&lt;/p&gt;
&lt;h3 id=&#34;full-cone-nat&#34;&gt;Full Cone NAT&lt;/h3&gt;
&lt;p&gt;當內部主機(Aip, Aport)被 NAT 映射外部(Eip, Eport)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有之後 A 出去的請求都會轉換成(Eip, Eport)&lt;/li&gt;
&lt;li&gt;所有外部主機發送(Eip, Eport)的都會轉換成(Aip, Aport)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;restricted-cone-nat&#34;&gt;Restricted Cone NAT&lt;/h3&gt;
&lt;p&gt;當內部主機(Aip, Aport)被 NAT 映射外部(Eip, Eport)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有之後 A 出去的請求都會轉換成(Eip, Eport)&lt;/li&gt;
&lt;li&gt;所有外部主機發送(Eip, Eport)的都會轉換成(Aip, Aport)&lt;/li&gt;
&lt;li&gt;但可以設定限制的外部主機，也就是只有它發進來的才可以轉為(Aip, Aport)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;port-restricted-cone-nat&#34;&gt;Port Restricted Cone NAT&lt;/h3&gt;
&lt;p&gt;當內部主機(Aip, Aport)被 NAT 映射外部(Eip, Eport)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有之後 A 出去的請求都會轉換成(Eip, Eport)&lt;/li&gt;
&lt;li&gt;所有外部主機發送(Eip, Eport)的都會轉換成(Aip, Aport)&lt;/li&gt;
&lt;li&gt;但可以設定限制的外部主機與 Port，也就是只有它(ip 與 port)發進來的才可以轉為(Aip, Aport)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;symmetric-nat---p2p--&#34;&gt;Symmetric NAT ( 無法進行 P2P 串透 )&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A 出去針對某個『特定』的位置的請求才會轉換成(Eip, Eport)，不然 NAT 都會轉成不同的 Port。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這裡的意思是指，假設內網 A 傳給封包給外網 B，那 NAT 會分配 Port 50000。而如果 A 要傳給 C 那 NAT 會分配 Port 50001。&lt;/p&gt;
&lt;p&gt;這種類型的 NAT 是無法實現 P2P 的，最主要的問題就在於它的 Port 會變。&lt;/p&gt;
&lt;h4 id=&#34;heading3&#34;&gt;備註：&lt;/h4&gt;
&lt;p&gt;在 Mobile 端如果使用 Wifi 來上網的大部份都是屬於前三種類型的，所以可以實現 P2P 穿透，而使用 3G 或 4G 的就是屬於 Symmetric NAT，所以它無法進行 P2P 穿透。(這未來會開篇文章來探討)&lt;/p&gt;
&lt;h2 id=&#34;heading4&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;本篇文章中，咱們理解了為什麼要建立 P2P 連線很麻煩的原因，最主要就是 NAT 的問題，因此我們下一文章就要來說明 WebRTC 是如何來穿透 NAT 這東東。&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.52im.net/thread-50-1-1.html&#34;&gt;P2P技术详解(一)：NAT详解——详细原理、P2P简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.nccu.edu.tw/~lien/Writing/NGN/firewall.htm&#34;&gt;穿越防火牆技術&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://linux.vbird.org/linux_server/0250simple_firewall/0320nat.php&#34;&gt;鳥哥的 Linux-NAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/30269820&#34;&gt;知乎-请问目前可否实现手机上的NAT穿透，建立P2P链接？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/84e8c78ca61d&#34;&gt;ICE协议下NAT穿越的实现（STUN&amp;amp;TURN）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-27之 WebRTC 的 Signaling Server</title>
      <link>https://mark-lin.com/posts/20180927/</link>
      <pubDate>Thu, 27 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180927/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;上一篇文章中，咱們已經學習完了 WebRTC 的一些基本知識，接下來咱們要針對 Signaling Server 這東東來做做一些比較深的的探討。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Signaling Server 要做的事情。&lt;/li&gt;
&lt;li&gt;WebRTC 與 SDP。&lt;/li&gt;
&lt;li&gt;Signaling Server的實作選擇。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;signaling-server-&#34;&gt;Signaling Server 要做的事情&lt;/h2&gt;
&lt;p&gt;在上一篇文章，我們大概知道了 Signaling Server 要做的事情，它要做的就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在建立 WebRTC 時，讓不認識的雙方可以相互的認識 (也就是知道對方的位置)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;順到說一下 WebRTC 並沒有定議 Signaling Server 的標準。&lt;/p&gt;
&lt;h4 id=&#34;-signaling--&#34;&gt;那 Signaling 是如何讓雙方知道對方的位置呢 ?&lt;/h4&gt;
&lt;p&gt;Signaling 是如何讓雙方認識呢 ?&lt;/p&gt;
&lt;p&gt;它就像是一個交友仲介商，每當某位用戶要進行聯誼時，用戶會提交一份履歷，這裡面就寫這他家在那，然後有配對到時，就會將這份履歷交給配對者，然後配對者如果覺得可以認識看看，他也會提供一份履歷給 Signaling Server，這樣雙向就可以進行面談了，其中已 Signaling 角度而言，履歷就是指 SDP。&lt;/p&gt;
&lt;h4 id=&#34;-sdp-&#34;&gt;什麼是 SDP ?&lt;/h4&gt;
&lt;p&gt;下章節在說。&lt;/p&gt;
&lt;h4 id=&#34;-webrtc--signaling-server--&#34;&gt;為啥 WebRTC 不建立 Signaling Server 的標準呢 ?&lt;/h4&gt;
&lt;p&gt;因為事實上要讓兩個瀏覽器能進行溝通，可以不需要 Signaling Server，如果你知道對方在那的情況下，在筆者的『&lt;a href=&#34;https://mark-lin.com/posts/20180910/&#34;&gt;30-10之通訊協議的基本常識&lt;/a&gt;』這篇文章中有提到，假設你知道了對方的 port 就代表你可以找到對方電腦內某個應用程式的位置，而你知道了 ip 那就代表你知道對方在那，所以這時你事實上就可以與對方溝通。&lt;/p&gt;
&lt;h2 id=&#34;webrtc--sdp&#34;&gt;WebRTC 與 SDP&lt;/h2&gt;
&lt;p&gt;SDP (Session Description Protocol) 中文叫會話描述協議，在一段會話建立起來前，咱們需要一些建立這會話雙方的資訊，假設 A 與 B 要建立會話，所以這時 A 會發送一個 SDP 給 Signaling，內容包含了 A 的地址、媒體類型、傳輸協議、媒體格式等或是一些它所在的時區資訊，然後 Signaling 會將 A 發送的 SDP 給 B，這樣雙方就知道如何建立連線了。&lt;/p&gt;
&lt;p&gt;下圖為 WebRTC 加上 SDP 後建立連線的流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用戶 A 向 Server 發送進行會話，內容包含 A 的 SDP。&lt;/li&gt;
&lt;li&gt;Server 將會話 SDP A 請求發送給用戶 B。&lt;/li&gt;
&lt;li&gt;用戶 B 向 Server 進行應答，並回應 B 的 SDP。&lt;/li&gt;
&lt;li&gt;Server 向用戶 A 發送 用戶 B 的 SDP。&lt;/li&gt;
&lt;li&gt;A、B 雙方使用 SDP 開始建立連線。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181111/20089358Va51RZj26R.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;sdp-&#34;&gt;SDP 格式描述&lt;/h3&gt;
&lt;p&gt;一般 SDP 分為三個部份組成。下圖為官網範例，然後咱們簡單的理解一下每個參數。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v = 協議版本&lt;/li&gt;
&lt;li&gt;o = 發起者的 SDP 編號與位置&lt;/li&gt;
&lt;li&gt;s = 會話名稱 (可空白)&lt;/li&gt;
&lt;li&gt;c = 連線資訊 (如果包含在媒體中可以不需要)&lt;/li&gt;
&lt;li&gt;t = 會話活動時間&lt;/li&gt;
&lt;li&gt;m = 媒體名稱與傳輸位置。&lt;/li&gt;
&lt;li&gt;a = 媒體的屬性 (就通常是描述 m 所指的媒體屬性)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中有個參數要說明一下，那就是&lt;code&gt;m&lt;/code&gt;，它在上面的說明為娛體的名稱為傳輸位置，但那是以官網的英文翻譯過來的，實際上它包含四個參數，分別：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;媒體類型：範例為 audio&lt;/li&gt;
&lt;li&gt;發送媒體流的 port：範例為 49170&lt;/li&gt;
&lt;li&gt;傳輸協議：RTP&lt;/li&gt;
&lt;li&gt;媒體 payload 類型：下面範例你看到三個數字 0、8、97，它們分別代表對應的類型 PCMU、PCMA、iLBC，這也對應了下面&lt;code&gt;a&lt;/code&gt;的那三個編碼。&lt;a href=&#34;https://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml&#34;&gt;更多類弄請參考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[Offer]

      v=0
      o=alice 2890844526 2890844526 IN IP4 host.atlanta.example.com
      s=
      c=IN IP4 host.atlanta.example.com
      t=0 0
      m=audio 49170 RTP/AVP 0 8 97
      a=rtpmap:0 PCMU/8000
      a=rtpmap:8 PCMA/8000
      a=rtpmap:97 iLBC/8000
      m=video 51372 RTP/AVP 31 32
      a=rtpmap:31 H261/90000
      a=rtpmap:32 MPV/90000
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[Answer]

      v=0
      o=bob 2808844564 2808844564 IN IP4 host.biloxi.example.com
      s=
      c=IN IP4 host.biloxi.example.com
      t=0 0
      m=audio 49174 RTP/AVP 0
      a=rtpmap:0 PCMU/8000
      m=video 49170 RTP/AVP 32
      a=rtpmap:32 MPV/90000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SDP 的詳細說明請參考『&lt;a href=&#34;https://tools.ietf.org/html/rfc4317&#34;&gt;RFC4317-Session Description Protocol (SDP)&lt;/a&gt;』&lt;/p&gt;
&lt;h2 id=&#34;signaling-server-1&#34;&gt;Signaling Server 的實作選擇&lt;/h2&gt;
&lt;p&gt;由於 WebRTC 並沒有定議我們要如何實作 Signaling Server 因此這裡將說明比較常見的兩種做法。&lt;/p&gt;
&lt;h3 id=&#34;http&#34;&gt;HTTP&lt;/h3&gt;
&lt;p&gt;這個方案的基本流程如下：&lt;/p&gt;
&lt;p&gt;假設用戶 A 與 B 要進行會話&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A 與 B 分別至 Http 取得畫面，並且雙方都會使用 polling 來定時拉取 Signaling Server 看看有沒有人要和某方進行會話&lt;/li&gt;
&lt;li&gt;A 發送會話請求，並附加 A 的 SDP。&lt;/li&gt;
&lt;li&gt;B Polling 到有會話請求。&lt;/li&gt;
&lt;li&gt;B 回覆會話請求，並附加 B 的 SDP。&lt;/li&gt;
&lt;li&gt;A Polling 到 B 的會話回覆。&lt;/li&gt;
&lt;li&gt;雙方開始建立連線。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這裡主要使用的技術就是基本的 HTTP，並且使用 Polling 機制來定期的探訪 Signaling Server。&lt;/p&gt;
&lt;h3 id=&#34;websocket&#34;&gt;WebSocket&lt;/h3&gt;
&lt;p&gt;WebSocket 它允許瀏覽器與 Server 建立一個雙向的溝通連線，就也就可以不需要使用 Polling 來定期的探訪 Signaling Server，而是只是它有收到會話請求，就會自動的推到某個用戶的瀏覽器。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用戶 A 向 Server 發送進行會話，內容包含 A 的 SDP。&lt;/li&gt;
&lt;li&gt;Server 將會話 SDP A 請求使用 WebSocket 發送給用戶 B。&lt;/li&gt;
&lt;li&gt;用戶 B 向 Server 進行應答，並回應 B 的 SDP。&lt;/li&gt;
&lt;li&gt;Server 使用 WebSocket 向用戶 A 發送 用戶 B 的 SDP。&lt;/li&gt;
&lt;li&gt;A、B 雙方使用 SDP 開始建立連線。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;備註：
前一篇文章『&lt;a href=&#34;https://mark-lin.com/posts/20180926/&#34;&gt;30-26之 WebRTC 的 P2P 即時通信與小範例&lt;/a&gt;』範例使用的 peer 套件，就是使用 WebSocket 方案來進行。&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;本篇文章中咱們學習 WebRTC 要進行 P2P 連線的其中一個要角 Signaling Server，接下來我們就要開來說明 WebRTC 如何進行連線，不過在開始學習他如何進行連線前，咱們要先學習一下，一些傳統上 P2P 連線的相關問題。&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://hank5000.github.io/blog/2017/03/31/webrtc-lian-jie-qian-jiao-hu-shi-zuo/&#34;&gt;實做Signaling Server與WebRTC 連接前之交互流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u011256637/article/details/74421318&#34;&gt;WebRTC 中的 SDP 协议&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-26之 WebRTC 的 P2P 即時通信與小範例</title>
      <link>https://mark-lin.com/posts/20180926/</link>
      <pubDate>Wed, 26 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180926/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;在很前面的文章中，咱們有簡單的介紹如何使用 WebRTC 來採集聲音與影像，但那時只是很簡單的介紹一下而以，所以接下來的幾篇文章，咱們將要來深入的了解 WebRTC。&lt;/p&gt;
&lt;p&gt;這篇文章將要介紹幾個 WebRTC 的基概念，大約分成以下幾個章節:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WebRTC 的誕生與內部架構。&lt;/li&gt;
&lt;li&gt;WebRTC 所支援的語音視編碼與傳輸協議。&lt;/li&gt;
&lt;li&gt;WebRTC 提供的基本 P2P 功能。&lt;/li&gt;
&lt;li&gt;WebRTC 的簡單通訊實作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;webrtc-&#34;&gt;WebRTC 的誕生與內部架構&lt;/h2&gt;
&lt;p&gt;首先在 Web 通信的世界中，基本上都是所謂的 C/S 架構，也就是所謂的 client 與 server 架構，通常 client 要取資料時就是發送一個請求給 server 然後它會回傳資料回去，其中 ajax 的出現讓我們更能以少量的資源來取得資料，在這階段時都部份都是單向溝通，也就是 client 請求 server。&lt;/p&gt;
&lt;p&gt;而在二階段能，人們開始有種需求，例如股票報價網站，人們希望可以看到當有股價變動時，網頁可以也同時更動，這時如果用上面那種模式，那就只能 client 定時的去 server 拿資料，也就是咱們所謂的&lt;code&gt;輪詢&lt;/code&gt;，但這種方法很明顯的非常的浪費資源，你可以呼叫 server 十次，但只有一次才真的有新的資料。而這時&lt;code&gt;webSocket&lt;/code&gt;就用來解決這向事情，它提供了雙向溝通功能，server 就可以透過它，來將資料推給 client。&lt;/p&gt;
&lt;p&gt;基本上以上已經解決了 client 與 server 的雙向互動，但這時人們又在想，假設我是做個一對一的聊天工具，那為什麼還需要 server 呢? 不能直接 client 與 client 進行溝通就好呢 ? WebRTC 就是可以幫助我們完成的工具，它就是用來專門處理瀏覽器與瀏覽器之間的即時溝通。&lt;/p&gt;
&lt;p&gt;備註：雖然說是 cleint 與 client 直接進行溝通，但不是說不需要 server，後面會說明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WebRTC 的存在目的，就是為了讓瀏覽器不需要認何 plugin 就可以快速的開發出 P2P 語音或視頻對話 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;webrtc--api&#34;&gt;WebRTC 的內部架構與所提供的 API&lt;/h3&gt;
&lt;p&gt;首先在咱們來看看 WebRTC 的基本架構，如下圖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181110/20089358srwDhi67JS.png&#34; alt=&#34;&#34;&gt;
圖片來源:&lt;a href=&#34;https://webrtc.org/architecture/&#34;&gt;官網&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最外層&lt;code&gt;紫色&lt;/code&gt;的地方就是我們所使用的 API 部份，基本上可以分三種:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getUserMedia: 用來處理音視串流採集。 (採集聲音或影像)。&lt;/li&gt;
&lt;li&gt;RTCPeerConnection: 用來建立兩個瀏覽器之間的直接通訊。 (建立與管理 p2p 連線)&lt;/li&gt;
&lt;li&gt;RTCDataChannel: 負責用來傳送資料。(操作那條 p2p 連線)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然後&lt;code&gt;藍色實線&lt;/code&gt;那層的 WebRTC C++ API 是專門給瀏覽器開發商更容易的實作 WebRTC 標準的 WebAPI。&lt;/p&gt;
&lt;p&gt;最後&lt;code&gt;藍色虛線&lt;/code&gt;那層由各瀏覽器開發商自行定義實作。&lt;/p&gt;
&lt;h4 id=&#34;heading1&#34;&gt;備註&lt;/h4&gt;
&lt;p&gt;關於 getUserMedia 的相關使用，可以參考筆者的以下兩篇文章。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180907/&#34;&gt;30-07之Web 如何進行語音與影像採集 ?&lt;/a&gt;
&lt;a href=&#34;https://mark-lin.com/posts/20180908/&#34;&gt;30-08之 WebRTC 採集的詳細說明與聲音的加工&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;webrtc-1&#34;&gt;WebRTC 所支援的語音視編碼與傳輸協議&lt;/h2&gt;
&lt;p&gt;在開始傳輸聲音之前，我們需要先進行編碼，接下來就是進行封裝，而封裝時也需要據傳輸協議才能決定要封裝成什麼型式來送貨。接下來這章節就簡單的說明一下 WebRTC 所支援的編碼與傳輸協議。&lt;/p&gt;
&lt;h3 id=&#34;heading2&#34;&gt;語音編碼&lt;/h3&gt;
&lt;p&gt;比較詳細的說明可至筆者的這篇文章『&lt;a href=&#34;https://mark-lin.com/posts/20180903/&#34;&gt;30-03之聲音的編碼與壓縮&lt;/a&gt;』&lt;/p&gt;
&lt;h4 id=&#34;opus&#34;&gt;Opus&lt;/h4&gt;
&lt;p&gt;這個編碼只要記得他是瑞士刀就好。&lt;/p&gt;
&lt;h4 id=&#34;isac&#34;&gt;iSac&lt;/h4&gt;
&lt;p&gt;它是一個提供寬帶 (wideband) 與超寬帶 (wideband) 的語音編碼器，大部份使用在 VoIP 與串流應用中，為 WebRTC 預設的語音編碼器。(目前是屬於 google 的)&lt;/p&gt;
&lt;p&gt;備註：
上面說的寬帶與超寬帶的意思是指他的採樣率的意思，寬帶是指 16KHz 與超寬帶指的是 32KHz。&lt;/p&gt;
&lt;h4 id=&#34;ilbc&#34;&gt;iLBC&lt;/h4&gt;
&lt;p&gt;它是一個提供窄帶的語音編碼器，也是大部都使用在 VoIP 與串流應用中，它的採樣率為 8HZ。&lt;/p&gt;
&lt;h3 id=&#34;heading3&#34;&gt;視頻編碼&lt;/h3&gt;
&lt;p&gt;比較詳細的說明可至筆者的這篇文章『&lt;a href=&#34;https://mark-lin.com/posts/20180905/&#34;&gt;30-05之影像的編碼與壓縮&lt;/a&gt;』&lt;/p&gt;
&lt;h3 id=&#34;vp8&#34;&gt;VP8&lt;/h3&gt;
&lt;p&gt;它是 Google 收購的 On2 所開發的視頻編碼，它基本上會封裝在 .webm 格式中&lt;/p&gt;
&lt;h3 id=&#34;vp9&#34;&gt;VP9&lt;/h3&gt;
&lt;p&gt;它就是 VP8 的進化版。&lt;/p&gt;
&lt;h3 id=&#34;webrtc-2&#34;&gt;WebRTC 所使用的通訊協議&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;它使用 RTP/RTCP 協議&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此協議詳細內容請看筆者的此篇文章『&lt;a href=&#34;https://mark-lin.com/posts/20180912/&#34;&gt;30-12之 RTP/RTCP 傳輸協議&lt;/a&gt;』。&lt;/p&gt;
&lt;p&gt;備註: 別忘了它是傳輸層協議
備註: 它可以選擇用 UDP(預設) 或 TCP&lt;/p&gt;
&lt;p&gt;這裡問一個問題。&lt;/p&gt;
&lt;h4 id=&#34;-webrtc--rtp--&#34;&gt;為什麼 WebRTC 要使用 RTP 協議呢 ?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;RTSP：RTSP 大部份是為了控制串流而使用它，而 WebRTC 目的是建立 P2P 的即時影音溝通，所以不太會選擇使用 RTSP。&lt;/li&gt;
&lt;li&gt;RTMP：Web 現在大部份不支援 Flash，所以這也不用，而且真要要幹的話，就代表雙方的瀏覽器都要可以解析 RTMP，那這樣只是找麻煩。&lt;/li&gt;
&lt;li&gt;HTTP 系列：如果有使用就代表雙方瀏覽器要有 HTTP Server 功能，不然對方收到我的 HTTP 請求如何解析，而且 HTTP 本來就是 C/S 架構的設計，要拿來用 C/C 架構，找自已的麻煩。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不過我覺得最大的理由在於，某此方面來說 WebRTC 已經可以算是應用層的協議，它讓雙方的瀏覽器都定義好了一定的流程來完成 P2P 溝通這件事情，因此它接下來應該只要在選擇使用什麼傳輸層協議來進行溝通就行了。&lt;/p&gt;
&lt;h2 id=&#34;webrtc--p2p-&#34;&gt;WebRTC 提供的基本 P2P 功能&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;要建立一個 WebRTC 的 P2P 基本應用如下圖，你會發現事實上還有一個 Server，但它不是說是 P2P 連線嗎 ?&lt;/p&gt;
&lt;p&gt;嗯沒錯，但它是指聲音或影像直接的進行 P2P 傳送，而不是需要經過 Server 來將聲音傳出去。&lt;/p&gt;
&lt;p&gt;那這個 Server 是要做什麼用的 ? 在 WebRTC 雙方要建立連線前，誰都不認識對方，這也代表雙方都不知對方在那，而這個 Server 就是讓他們互相認識的交誼廳 ，這在 WebRTC 中又被稱為 Signaling Server 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181110/20089358k4ZIrtsGBB.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;建立連線的過程如下圖。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用戶 A 向 Server 發送與 B 進行會話。&lt;/li&gt;
&lt;li&gt;Server 將會話請求發送給用戶 B。&lt;/li&gt;
&lt;li&gt;用戶 B 向 Server 進行應答，並回報 OK。&lt;/li&gt;
&lt;li&gt;Server 向用戶 A 發送 用戶 B 的相關資訊。&lt;/li&gt;
&lt;li&gt;雙方開始建立連線。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181110/20089358K4kVBXUaXn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;webrtc-3&#34;&gt;WebRTC 的簡單通訊實作&lt;/h2&gt;
&lt;p&gt;這裡基本上分為兩部份程式碼，一段是 client 端的，另一端為 server 端的。&lt;/p&gt;
&lt;h3 id=&#34;server&#34;&gt;Server&lt;/h3&gt;
&lt;p&gt;這一段是建立 Signaling Server，我們使用 nodejs 的 express 來建立，然後我們還有使用到&lt;code&gt;peer&lt;/code&gt;這個套件來幫助我們可以更輕鬆的使用 WebRTC 的 P2P 操作。&lt;/p&gt;
&lt;p&gt;下面這段程式碼中，事實上只做了兩件事。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立 client 的頁面 (註：這裡使用&lt;code&gt;/a&lt;/code&gt;與&lt;code&gt;/b&lt;/code&gt;不同的頁面來模擬不同的用戶)&lt;/li&gt;
&lt;li&gt;建立 client 的對話 (註：事實上詳細處理的都已經包在 peer 套件裡面了)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;express&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;express&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;express&lt;/span&gt;();
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expressPeerServer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;peer&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;ExpressPeerServer&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;server&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;listen&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;9000&lt;/span&gt;);

&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;peerserver&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;expressPeerServer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;server&lt;/span&gt;);

&lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;use&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/api&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;peerserver&lt;/span&gt;);

&lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/a&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;){
    &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;sendfile&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;__dirname&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/index-clientA.html&amp;#34;&lt;/span&gt;);
});

&lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/b&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;){
    &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;sendfile&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;__dirname&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/index-clientB.html&amp;#34;&lt;/span&gt;);
});

&lt;span style=&#34;color:#a6e22e&#34;&gt;peerserver&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;connection&amp;#39;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;) =&amp;gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;A client connected : &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;);
})

&lt;span style=&#34;color:#a6e22e&#34;&gt;peerserver&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;disconnect&amp;#39;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;) =&amp;gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;A client say ~ bye bye : &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;);
});

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;client&#34;&gt;Client&lt;/h3&gt;
&lt;h4 id=&#34;a-&#34;&gt;A 用戶&lt;/h4&gt;
&lt;p&gt;其中比較需要注意的是在使用&lt;code&gt;new Peer(‘A’)&lt;/code&gt;時，這裡面所代的 A 就代表你這用戶的編碼，別人如果要和你進行連線時，就需要使用這個編碼，但是這不是說任何人都可以和你連線，必須是要在此會話中，才能進行連線。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;viewport&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http-equiv&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;X-UA-Compatible&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ie=edge&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;Document&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/peerjs/0.3.9/peer.min.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Peer&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;host&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;port&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9000&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/api&amp;#39;&lt;/span&gt; });

        &lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;open&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;) {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;My peer ID is: &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;);
        });

        &lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;connection&amp;#39;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;) =&amp;gt; {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;open&amp;#39;&lt;/span&gt;, () =&amp;gt; {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 有任何人加入這個會話時，就會觸發
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; is connected with me&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;);
            });
            &lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;) {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 當收到訊息時會執行
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; : &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;);
                &lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;HI I am A&amp;#39;&lt;/span&gt;);
            });
        });
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;

&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;b-&#34;&gt;B 用戶&lt;/h4&gt;
&lt;p&gt;這個是 B 用戶，一但它建立連線後，就會發送與 A 會話的請求&lt;code&gt;peer.connect(‘A’)&lt;/code&gt;，然後連線成功後會在發送一段訊息給 A。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;charset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;viewport&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http-equiv&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;X-UA-Compatible&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ie=edge&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;Document&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/peerjs/0.3.9/peer.min.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Peer&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;host&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;port&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9000&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;path&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/api&amp;#39;&lt;/span&gt; });
        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;connect&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;A&amp;#39;&lt;/span&gt;);

        &lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;open&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;) {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;My peer ID is: &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;);
        });

        &lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;open&amp;#39;&lt;/span&gt;, () =&amp;gt; {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 與 A 連線後，會發送以下訊息給 A。    
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Hi I am B&amp;#39;&lt;/span&gt;);
        });

        &lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;) =&amp;gt; {
            &lt;span style=&#34;color:#75715e&#34;&gt;// 送到某人發送的訊息。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;peer&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; : &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;);
        });

    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;

&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;heading4&#34;&gt;執行&lt;/h3&gt;
&lt;p&gt;全部程式碼中此『&lt;a href=&#34;https://github.com/h091237557/30-audio-video/tree/master/code/webRTC-p2p-audio&#34;&gt;傳送門&lt;/a&gt;』&lt;/p&gt;
&lt;h4 id=&#34;1--npm-&#34;&gt;1. 安裝 npm 套件&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;npm install
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;2--server&#34;&gt;2. 執行 server&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;node broker-server.js
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;3--a--b-&#34;&gt;3. 在瀏覽器先開啟 A 與在開啟 B 用戶&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1:9000/a
127.0.0.1:9000/b
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;4-&#34;&gt;4. 執行結果&lt;/h4&gt;
&lt;h4 id=&#34;a-1&#34;&gt;A 用戶的畫面&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181110/200893587Df9ZCzkpl.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;b-1&#34;&gt;B 用戶的畫面&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181110/2008935867ojtrgktH.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;本篇文章中咱們學習了 WebRTC 的基本概念與架構，並且在簡單的實作一個 P2P 通信範例，而接下來的文章中，咱們要來討探一下上面有說到的 Signaling Server 的一些事情。&lt;/p&gt;
&lt;h2 id=&#34;heading6&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/RTCDataChannel&#34;&gt;官網-RTCDataChannel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection&#34;&gt;官網-RTCPeerConnection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-25之直播連麥的挑戰與方案 ( P2P )</title>
      <link>https://mark-lin.com/posts/20180925/</link>
      <pubDate>Tue, 25 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180925/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;現今大部份的直播咱們要可以與漂亮的直播主姐姐或硬漢大叔進行互動，基本上咱們只能使用&lt;code&gt;文字&lt;/code&gt;，也就是所謂的聊天室，而這篇文章咱們將要介紹另一種互動方式，那就是直播連麥，也就是直播主與聽眾可以進行語音溝通，更白話文的是說可以和漂亮姐姐進行語音聊天。這也就是本篇文章的主題。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以和漂亮姐姐進行語音聊天的難題與方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章將分成兩個章節：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直播連麥的挑戰&lt;/li&gt;
&lt;li&gt;直播連麥的架構&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading1&#34;&gt;直播連麥的挑戰&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;直播連麥最大的難題就是『 延遲 』問題。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假設我們在一般直播時，以比較低的延遲 2 秒來計算的話 ( 就是主播說話聽眾 2 秒鐘後才能聽到 )，那這樣在直播連麥時會發生什麼事情呢 ?&lt;/p&gt;
&lt;p&gt;如下圖所示，直播主說話以後，要經過 4 秒以後才會聽到連麥者的回復，而連麥者也相同的要等 4 秒後才能聽到直播主的回應，你覺得這樣還可以對話嗎 ?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181109/20089358SiGQeCGGnc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這裡來問個問題。&lt;/p&gt;
&lt;h3 id=&#34;-&#34;&gt;為什麼直播會延遲呢 ?&lt;/h3&gt;
&lt;p&gt;基本上可以分四個部份，如下圖。呃下面兩個箭頭算一部份，所以分別為&lt;code&gt;直播主處理&lt;/code&gt;、&lt;code&gt;網路傳輸&lt;/code&gt;、&lt;code&gt;CDN 與 Media Server 處理&lt;/code&gt;、&lt;code&gt;聽眾端處理&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181109/20089358GVjNKU5P7r.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-client&#34;&gt;首先第一個部份是直播主 Client&lt;/h4&gt;
&lt;p&gt;它需要花時間來進行聲音與影像的採集，接下來進行編碼，最後就準備封裝然後準備送貨。&lt;/p&gt;
&lt;p&gt;這部份有沒有可以優化的地方呢 ?&lt;/p&gt;
&lt;p&gt;基本上可以在編碼上加速，網路上有提到說&lt;code&gt;硬編碼&lt;/code&gt;與&lt;code&gt;軟編碼&lt;/code&gt;這兩個聽起來很硬東西，其中軟編碼就是使用 CPU 來編碼，而硬編碼就是使用非 CPU 來進行編碼，例如使用 GPU。&lt;/p&gt;
&lt;p&gt;而硬編碼效能優於軟編碼，不過需要硬體支援，這方面我沒很熟，請當參考。&lt;/p&gt;
&lt;h4 id=&#34;heading2&#34;&gt;第二部份為網路傳輸&lt;/h4&gt;
&lt;p&gt;只要實用網路進行傳輸，基本上都一定會發生延遲問題，而最主要產生的原因有兩個：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;距離。&lt;/li&gt;
&lt;li&gt;傳輸時的封包維護。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先距離是不用說的，直播主離你越遠，它的聲音要傳到你的小耳朵裡，一定比較花時間。&lt;/p&gt;
&lt;p&gt;然後第二點是傳輸時的封包維護，在網路傳輸時基本上會發生兩件事情&lt;code&gt;網路抖動&lt;/code&gt;與&lt;code&gt;網路掉包&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;網路抖動&lt;/code&gt;就是你傳送 A、B、C 封包給某個人，但某個人收到的封包為 C、B、A，那這時就要針對這狀態做一些處理，方法可能是緩存等到某段時間後，在根據封包裡面的時間來依順序播放，但緩存那邊就會產生延遲時間囉。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;網路掉包&lt;/code&gt;就是你傳送 A、B、C 但實際上對方只收到 A、B，而這時如果是 TCP 的話，它就會一段時間後，會在發送一次封包 C，然後這段時間也就產生延遲囉。&lt;/p&gt;
&lt;p&gt;那這部份有沒有啥解法 ?&lt;/p&gt;
&lt;p&gt;就是使用 CDN 只要離的越近，當然越快，而且發生網路網路抖動與網路掉包機率更低，當然如果你們公司夠強，那就自已開發一個基於 UDP 的協議吧。&lt;/p&gt;
&lt;h4 id=&#34;-cdn--media-server-&#34;&gt;第三部份為 CDN 或 Media Server 處理&lt;/h4&gt;
&lt;p&gt;在這一部份，它們可能會需要將 RTMP 推流轉成相對應其它協議的東西，例如 HLS 就需要產生 .m3u8 而 HTTP-FLV 就需要產生 .flv。&lt;/p&gt;
&lt;p&gt;那這部份有沒有啥解法 ?&lt;/p&gt;
&lt;p&gt;我不知道。&lt;/p&gt;
&lt;h4 id=&#34;-client1&#34;&gt;第三部份為聽眾 Client&lt;/h4&gt;
&lt;p&gt;當聽眾的設備收到直播主傳送來的聲音後，會開始進行解碼，然後進行播放，這裡也會需要花費時間。&lt;/p&gt;
&lt;p&gt;然後有一些播放器會有緩存的機制，為了防止看片卡頓的問題，所以它可能會在本地端，先緩存個 1 秒鐘的影像，然後在播出，因此這部份也會產生延遲囉。&lt;/p&gt;
&lt;p&gt;那這部份有沒有啥解法 ?&lt;/p&gt;
&lt;p&gt;基本上就看解碼器的能力吧……&lt;/p&gt;
&lt;h2 id=&#34;heading3&#34;&gt;直播連麥的架構&lt;/h2&gt;
&lt;h3 id=&#34;v1-&#34;&gt;V1 可動版&lt;/h3&gt;
&lt;p&gt;請看下圖，基本上就是直播主與連麥者發送一條 RTMP 到 CDN，然後雙方同時會去最近的 CDN 拉取對對方的 RTMP，最後聽眾端就同時去 CDN 抓兩條流回來。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181109/20089358OpjfjSA99b.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-v1--&#34;&gt;上面這種 V1 有啥問題 ?&lt;/h4&gt;
&lt;p&gt;如下所列，雖然它實現的方式比較簡單，但是有很多問題，基本上應該是沒啥商業價值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主播與連麥者在互動時，延遲性較高。&lt;/li&gt;
&lt;li&gt;主播與連麥者聲音會互相干擾，也就是所謂的迴音。&lt;/li&gt;
&lt;li&gt;延遲性非常的依賴 CDN 的效能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;v2--p2p-&#34;&gt;V2 基於 P2P 架構版&lt;/h3&gt;
&lt;p&gt;請看下圖，基本就是主播主與連麥者進行 P2P 的連線，然後通常會在主播端那將兩條聲音進行合流，然後在用 RTMP 推流將到丟到 CDN 那，然後聽眾在去用拉流去將這它抓下來。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181109/20089358EMvde2VH8s.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這種架構有以下特點:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;延遲性低。&lt;/li&gt;
&lt;li&gt;但 P2P 打洞成功機率不是 100 % (也就是說主播與連麥者不一定可以連到)&lt;/li&gt;
&lt;li&gt;這種方法在行動端網路會很受限制。&lt;/li&gt;
&lt;li&gt;主播端上傳 Loading 會很重 (而且如果連麥多人的話)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;雖然使用 P2P 的連麥架構還是有缺點，但是相比之下，連麥互動的根本，低延遲至少有解。這個版本基本上 P2P 這方面應該是有辦法使用 WebRTC 來方便實作，但如果 mobile 端要建立這個架構，如果無法使用 WebRTC 的話，那難度就比較高點兒，這就還要在調查了。&lt;/p&gt;
&lt;h2 id=&#34;heading4&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;本篇文章中，咱們探討了直播連麥的一些挑戰，基本上最主要是延遲的問題，如果這個能解，那基本上直播連麥應該就可以做到用戶不會冒火的水準，不過這裡說一下，寫到這邊以後發覺，某些方面這產業真的非常的燒錢，因為 CDN 真的很重要，好的 CDN 帶你上天堂，爛的 CDN 帶你下地獄。&lt;/p&gt;
&lt;p&gt;接下來下一篇文章，咱們將要來理解一下 WebRTC 是如何處理 P2P 連線的，這也有助於未來在想開發 Mobile 端 P2P 連線的幫助。&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kknews.cc/zh-tw/tech/5a8qv6l.html&#34;&gt;最火直播連麥技術大揭秘！內附技術詳解~&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kknews.cc/tech/4oyx4m2.html&#34;&gt;RTMP、WebRTC、UDP 三種互動直播方案的優劣比較&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/document/product/454/8092&#34;&gt;騰訊雲-如何实现连麦功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/22663282&#34;&gt;视频直播技术详解」系列之五：延迟优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-24之直播與點播可動版的改良 ( 正式版 )</title>
      <link>https://mark-lin.com/posts/20180924/</link>
      <pubDate>Mon, 24 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180924/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;上一篇文章中咱們學習完了 CDN 的相關知識以後，接下來這篇文章，我們將要將上一篇所學的來改善咱們以下兩篇文章可動版的架構。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 CDN 來調整可動版的架構&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180920/&#34;&gt;30-20之如何建立像 KKTV 一樣的點播功能呢 ?&lt;/a&gt;
&lt;a href=&#34;https://mark-lin.com/posts/20180921/&#34;&gt;30-21之如何建立的像 17 一樣的直播功能呢 ?&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;heading1&#34;&gt;點播&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181104/200893585CaXOeE2zc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;heading2&#34;&gt;直播&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181105/20089358nqLraVoW8t.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;本篇文章會分成以下幾個章節：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可動版本的問題。&lt;/li&gt;
&lt;li&gt;點播的架構改善版本。&lt;/li&gt;
&lt;li&gt;直播的架構改善版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading3&#34;&gt;可動版本的問題&lt;/h2&gt;
&lt;p&gt;在筆者這篇文章中『&lt;a href=&#34;https://mark-lin.com/posts/20180922/&#34;&gt;30-22之點播與直播可動版問題探討&lt;/a&gt;』，我們探討了可動版有以下的問題：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;人多時連線數限制問題。&lt;/li&gt;
&lt;li&gt;人多時頻寬問題。&lt;/li&gt;
&lt;li&gt;人多時效能消耗問題。&lt;/li&gt;
&lt;li&gt;遠距離看片卡頓的問題。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本上 1、3 我們可以用傳統的方法(加機器)來解決，而 2、4 就無法使用加機器來進行解決，因為以 2 的頻寬問題，就算你加了在多的機器，如果你在出去的網路還是在同一條，那頻寬還是沒加大，問題還是沒解決。而 4 的話就更不用說，只能讓使用者離機器更近一點才能解決。&lt;/p&gt;
&lt;h2 id=&#34;heading4&#34;&gt;點播架構的改善版本&lt;/h2&gt;
&lt;p&gt;基本上點播的架構會改成如下圖，它會將 CDN 加上去，而這樣就可幫助我們解決&lt;code&gt;頻寬&lt;/code&gt;與&lt;code&gt;距離看片卡頓&lt;/code&gt;的問題。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181108/20089358DW3jQScXM7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;先來說說頻寬的部份， CDN 基本上分散在不同的地方，這也代表這基本上它們的頻寬是各別獨立的，所以不太會發生搶頻寬的問題，而另一點距離的問題，由於大部份的 CDN 都會搭配使用智能 DNS 來幫助找到最近的 CDN，因此可以解決因為離影片來源太遠，而容易造成封包遺失與封包順序不一致問題。&lt;/p&gt;
&lt;p&gt;而且用了 CDN 事實上還有一個好處，那就是可以保證接近 100 的機率可以看片，你想想如果是自已建的一台 Media Server 來提供看片，如果它倒了，不就不能看片了，而有 CDN 就可以自動的轉到另一個臨近的 CDN 來取得資料。&lt;/p&gt;
&lt;p&gt;接下來說說它的運行流程，基本上如下 (以 HLS 拉流為範例)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Media Server 收到新的影片檔，然後它會將他進行切片，分成一小個一小個檔案 .ts。&lt;/li&gt;
&lt;li&gt;接下來會分發到各 CDN 上。&lt;/li&gt;
&lt;li&gt;有個用戶發送 Http 請求到智能 DNS 會給予最近的 CDN 位置。&lt;/li&gt;
&lt;li&gt;用戶在發送請求給 CDN 取得影片，CDN 開始將一小段一小段 .ts 傳送給用戶。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181108/20089358YLGLH7MgT6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;直播架構的改善版本&lt;/h2&gt;
&lt;p&gt;首先我們先看加了 CDN 的第一種的改善版如下圖。這種架構基本上一樣可以解決掉頻寬與遠距離觀看會卡頓的問題。&lt;/p&gt;
&lt;p&gt;它的運行流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直播主推送 RTMP 到 Media Server。&lt;/li&gt;
&lt;li&gt;Media Server 將 RMTP 依據所需支援的協議，切分成小檔案 (ex. HLS 的 .ts)&lt;/li&gt;
&lt;li&gt;Media Server 推送到 CDN。&lt;/li&gt;
&lt;li&gt;聽眾使用拉流 (ex. HLS、HTTP-FLV、Dash、RTMP) 來觀看直播主。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181108/20089358bELtTTFkiF.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-&#34;&gt;上面這個版本有啥問題嗎 ?&lt;/h4&gt;
&lt;p&gt;如果這是個非互動性要求的直播 (ex. 運動賽事直播) 的話，那問題不大。&lt;/p&gt;
&lt;p&gt;但如果是要求互動性的直播，那就有問題了，因為它的延遲會比沒有使用 CDN 還高，也就說沒使用 CDN 時直播主說話後要 5 秒鐘才能聽的到的話，那用了 CDN 可能就要 10 秒，原因如下圖，因為它要多傳輸不少東西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181108/20089358bk31OueXm3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;因此後來有人就提出直接將直播主的聲音丟到 CDN，然後由 CDN 來處理切分這些事情，架構圖與執行流程如下。但是相對的此架構的成本一定會比上述的還高，因為 CDN 要幫你多做不少事情。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直播主推送 RTMP 到離它最近的 CDN。&lt;/li&gt;
&lt;li&gt;CDN 幫你依據所需支援的協議，切分成小檔案。&lt;/li&gt;
&lt;li&gt;聽眾使用拉流 (ex. HLS、HTTP-FLV、Dash、RTMP) 來去最近的 CDN 觀看直播主。&lt;/li&gt;
&lt;li&gt;離聽眾最近的 CDN 會使用拉流來將直播主所在的 CDN 進行畫面拉去。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181108/20089358ijUWbr7e0K.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading6&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;基本上以上的點播與直播的改善版本，應該就是大部份雛形，然後你只要記好，在直播與點播的應用中，沒有 CDN 應該是無法做起來的，所以入深入的理解 CDN 的原因與理解各家 CDN 的應用，相信可以幫助你做出各優質的點播與直播的應用。&lt;/p&gt;
&lt;p&gt;接下來下一篇文章，我們就要來研究看看互動直動的一些挑戰。&lt;/p&gt;
&lt;h2 id=&#34;heading7&#34;&gt;參考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.52im.net/thread-1033-1-1.html&#34;&gt;首次披露：快手是如何做到百万观众同场看直播仍能秒开且不卡顿的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/f86e263187cd&#34;&gt;视频直播| 基础原理篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kknews.cc/zh-tw/tech/v42e2l.html&#34;&gt;直播CDN相關技術&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-23之 CDN 的說話島 ( AWS CloudFront  CDN 實作 )</title>
      <link>https://mark-lin.com/posts/20180923/</link>
      <pubDate>Sun, 23 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180923/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;上一篇文章中，咱們有提到點播與直播可動版本的一些問題，如下所列。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;人多時連線數限制問題。&lt;/li&gt;
&lt;li&gt;人多時頻寬問題。&lt;/li&gt;
&lt;li&gt;人多時效能消耗問題。&lt;/li&gt;
&lt;li&gt;遠距離看片卡頓的問題。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下來咱們要來理解一下，解這上述問題的關鍵技術 CDN 是什麼東西 ?&lt;/p&gt;
&lt;p&gt;本編文章將分為以下幾個章節：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什麼是 CDN 呢 ? 它又是用來解決啥呢 ?&lt;/li&gt;
&lt;li&gt;CDN 的請求運作方式。&lt;/li&gt;
&lt;li&gt;使用 AWS CloudFront 來建立 CDN。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;-cdn----&#34;&gt;什麽是 CDN 呢 ? 它又是用來解決啥呢 ?&lt;/h2&gt;
&lt;p&gt;在開始理解 CDN 之前，咱們先來說說傳統上一個 client 連線到一個網站的流程。&lt;/p&gt;
&lt;p&gt;首先看看下面這張圖，這張圖說明了每當一個 client 發送一個請求到 web 網站時，web 網站會回傳
html、css 與 javascript 回來，這裡假設咱們的 web 網站還在台灣，然後回應時間大約在 100 ms 以內 (假設)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358L394w8r0oh.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然後呢 ~ 這時付你錢的老大叫你將 web 網路架設到美國，因爲免費，然後這時發現回應時間變成 1000 ms 左右。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358WIYfHP7ksn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然後開始了有以下的對話 :&lt;/p&gt;
&lt;p&gt;老大：回應時間怎麼回事 ?
碼農仔：老大你叫我架到美國啊 !?
老大：我要的不是這回答，而是問你為啥回應時間你沒修改回來 ?
老大：你是專家對吧 ?
碼農仔：(深深的吸口氣) 沒錯，我是專家 ( I am an expert ! )&lt;/p&gt;
&lt;p&gt;回到正題。&lt;/p&gt;
&lt;p&gt;CDN ( Content Delivery Network )，它存在的目的就是讓你接近取得網路資料的方法，咱們如果將上圖加入 CDN 後就會長的如下圖，所以 client 要取得的一些資源 (html、css、js) 都會去 CDN 那取得。這樣就算你的網站架在美國，但只要 CDN 是在台灣，那回應速度應該也不會有太大的差距。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358NZ2rYxVuzs.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;cdn-&#34;&gt;CDN 的請求運作原理。&lt;/h2&gt;
&lt;p&gt;首先 CDN 基本上會分為三個部份。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;智能 DNS (Intelligent DNS)：事實上是 DNS 的某個功能，它的主要功用就是可以幫用戶找到最近的 Edge CDN，這樣用戶就可以去最近的 CDN 拿資料了。&lt;/li&gt;
&lt;li&gt;邊緣 CDN ( Edge CDN )：就是散布在不同地方的 CDN 節點。&lt;/li&gt;
&lt;li&gt;來源 Server ( Origin Server )：就是原始資料存放地。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然後基本一個圖片的請求，會變的如下圖所示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Client 發送一個 HTTP 請求來取得圖片。&lt;/li&gt;
&lt;li&gt;DNS 收到後，會去請求智能 DNS。&lt;/li&gt;
&lt;li&gt;智能 DNS 會回傳給 DNS 最近 CDN 的 IP 位置。&lt;/li&gt;
&lt;li&gt;Client 收到 IP 以後，在發送請求去那個 CDN。&lt;/li&gt;
&lt;li&gt;CDN 收到請求後，會先判斷有沒有緩存此圖片，如果有就直接回傳，沒有則在去來源 Server 取得圖片，然後緩存此圖片，最後在送去給 Client。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/200893580n0UPwlTOG.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;-aws-cloudfront--cdn&#34;&gt;使用 AWS CloudFront 來建立 CDN&lt;/h2&gt;
&lt;p&gt;接下來我們來簡單的看看如何使用 AWS CloudFront 來建立一個 CDN 範例。&lt;/p&gt;
&lt;p&gt;這個範例我們會使用 AWS S3 來存放一張圖片，然後再使用 AWS CloudFront 來建立 CDN 希望能提升圖片讀取速度。&lt;/p&gt;
&lt;h3 id=&#34;-s3&#34;&gt;資料來源 S3&lt;/h3&gt;
&lt;p&gt;首先我們會在 S3 先建立一個 bucket，為了測試需要我們將 region 設定在『EU (London)』&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://s3.eu-west-2.amazonaws.com/marklin-images-test-s3/1442041544.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後我們可以直接在 chrome 上執行上面的網址，來取得一張圖片，咱們先來看看在還沒使用 CDN 時的回應時間為多少，如下圖，超久的快 7 秒鐘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/200893580dE7gsX2wM.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;-aws-cloudfront&#34;&gt;設定 AWS CloudFront&lt;/h3&gt;
&lt;p&gt;接下來咱們來設定 AWS CloudFront。&lt;/p&gt;
&lt;h4 id=&#34;-cdn-&#34;&gt;選擇 CDN 類型&lt;/h4&gt;
&lt;p&gt;首先第一個一開始 AWS CloudFront 有提供兩種類型服務的 CDN，分別為&lt;code&gt;WEB&lt;/code&gt;與&lt;code&gt;RTMP&lt;/code&gt;，此篇文章咱們先來學習 web 這裡的設定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358N3oz0A4xkF.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;--origin-settings-&#34;&gt;設定資料來源 ( Origin Settings )&lt;/h4&gt;
&lt;p&gt;Origin Domain Name：這裡就是你資料來源的 domain ，基本上有以下的來源可以選擇:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你自已的網站&lt;/li&gt;
&lt;li&gt;AWS S3&lt;/li&gt;
&lt;li&gt;AWS EC2&lt;/li&gt;
&lt;li&gt;AWS Elastic Load Balancing&lt;/li&gt;
&lt;li&gt;MediaStore 容器與節點&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Origin Path：路徑源，像如果 S3 有要指定到某個資料夾，就是在這設定。
Origin ID：此來源的唯一編號。
Restrict Bucket Access：選擇了 YES，代表你不能在用 S3 的連結路徑，而只能用 CloudFont 的連結路行。
Origin Custom Headers：如果希望將 CloudFont 將請求轉發給來源時，包含自訂表頭，那就這設定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358Ln84SMygQ2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-cache---default-cache-behavior-settings-&#34;&gt;設定 cache 行為 ( Default Cache Behavior Settings )&lt;/h4&gt;
&lt;p&gt;在來是要設定 cache 行為的地方，這裡的設定基本上都用預設就可以動，不過還是簡單說明幾個比較常用的設定。&lt;/p&gt;
&lt;p&gt;Viewer Protocol Policy：這裡是要設定要訪問 CloudFont 的策略，看是要選只能 https 連結還是 http 也行。&lt;/p&gt;
&lt;p&gt;Allowed HTTP Methods：允許訪問的 http 方法設定。&lt;/p&gt;
&lt;p&gt;Minimum TTL: 這裡是設定在 CloudFont 中保持緩存的最小時間，假設設定 5 秒，那就代表 5 秒過後就會去來源端判斷是否有無更新。(預設為 0)&lt;/p&gt;
&lt;p&gt;Maximum TTL：緩存的最大時間。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358ldQJtMMlfJ.png&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358wQAI4nBRjM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-distribution-settings&#34;&gt;分配設定 Distribution Settings&lt;/h4&gt;
&lt;p&gt;最後就是分配設定，基本上只是測試用可以都 Default 值。&lt;/p&gt;
&lt;p&gt;Price Class：預設情況下可以使用所有 CloudFront 所提供的地方，當然你可以只選擇只使用特別地方的 CloudFront 如果你的用戶大部份都集中在某個區域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358OafV2aTTUJ.png&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358pzptztsJQn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;-s3-&#34;&gt;設定完後讀取 S3 圖片的速度&lt;/h3&gt;
&lt;p&gt;設置完 CloudFont 後，你會知道它的 domain name。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358IOYiVYODfm.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然後你再將原本的圖片網址替換成 cdn 網址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://s3.eu-west-2.amazonaws.com/marklin-images-test-s3/1442041544.jpg ( 原 )

https://d3oh771a3zmb3v.cloudfront.net/1442041544.jpg ( CDN )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最後咱們使用以上兩個分別為未使用與使用 CDN 的網址來取得圖片，你會發現超快 der ~&lt;/p&gt;
&lt;h4 id=&#34;-cdn&#34;&gt;未使用 CDN&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/200893580dE7gsX2wM.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-cdn1&#34;&gt;使用 CDN&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358zPgJF8DMQK.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;本篇文章中咱們學習到 CDN 的一些基本知識，接下來的文章，咱們將要加上 CDN 來重新的考量我們的點播與直播網路的架構。&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/29468624&#34;&gt;CDN缓存策略解读和配置策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/zh_cn/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginCustomHeaders&#34;&gt; AWS CloudFront 官網&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-22之點播與直播可動版問題探討</title>
      <link>https://mark-lin.com/posts/20180922/</link>
      <pubDate>Sat, 22 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180922/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;前面文章中咱們簡單了可以動的&lt;code&gt;點播 ( like KKTV )&lt;/code&gt;與&lt;code&gt;直播 ( like 17 )&lt;/code&gt;的功能，那接下來這篇文章主題要探討的目問題為：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這兩篇文章實際上應用會有什麼問題 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180920/&#34;&gt;30-20之如何建立像 KKTV 一樣的點播功能呢 ?&lt;/a&gt;
&lt;a href=&#34;https://mark-lin.com/posts/20180921/&#34;&gt;30-21之如何建立的像 17 一樣的直播功能呢 ?&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;heading1&#34;&gt;點播可動版架構&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181104/200893585CaXOeE2zc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;heading2&#34;&gt;直播可動版架構&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181105/20089358nqLraVoW8t.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;本篇文章分根據問題分成以下幾個章節：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;人多時連線數限制問題。&lt;/li&gt;
&lt;li&gt;人多時頻寬問題。&lt;/li&gt;
&lt;li&gt;人多時效能消耗問題。&lt;/li&gt;
&lt;li&gt;遠距離看片卡頓的問題。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading3&#34;&gt;人多時連線數限制問題&lt;/h2&gt;
&lt;p&gt;咱們都知道，每當 Client 要和 Server 要資料時，如果是以 TCP 傳輸為基礎的，那就一定要建立一條連線，那對 Server 而言連線是啥了 ?&lt;/p&gt;
&lt;p&gt;在 unix 中每一個 TCP 連線都要占用一個 file descriptor，而它有一定的限制數量，當使用完後，新的 TCP 連線到來就會發生錯誤以下的錯誤訊息 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Socket/File: Can&#39;t open so many files。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那一個 process 我們可以開啟幾個檔案呢 ? 我們可以用以下的指令來看看 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ulimit -n
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那這個最大值為多少呢 ? 這個我不確定，像我家用的 Aws Elasticsearch 就有 128000。&lt;/p&gt;
&lt;p&gt;這個東東傳統上如果真的碰到這個貧頸，那就是開多機器，然後用 Load Balance 來處理。&lt;/p&gt;
&lt;h4 id=&#34;-media-server--&#34;&gt;那這東東在 Media Server 上會很吃重嗎 ?&lt;/h4&gt;
&lt;p&gt;這個我覺得要看協議。&lt;/p&gt;
&lt;p&gt;首先 RTSP 應該是不會影響太大，因為它主要還是使用 RTP base UDP 這東東不太需要建立連線，所以應該是不會吃到 file descriptor。&lt;/p&gt;
&lt;p&gt;在來以 RTMP 來看，它本身的傳輸是用 RTMP 封包，然後使用 TCP 來進行傳輸，正常來說應該是使用 TCP 長連接來建立連線，所以他在傳輸影片時，應該都是用同一個 TCP 來傳輸，所以不會很吃 file descriptor。&lt;/p&gt;
&lt;p&gt;接下來是使用 HTTP 的 HLS，不知道為啥它本身是使用 HTTP 短連接，所以它會比較消耗 file descriptor，而且如果又把每個 ts 切的很細 ( ex. 1 ~ 2 秒 )，那就真的會吃很多囉。&lt;/p&gt;
&lt;p&gt;而 HTTP-FLV 則是使用長連接，所以不耗太多 file descriptor。&lt;/p&gt;
&lt;p&gt;最後是 MPEG-DASH 找不太到是用長還短連接。&lt;/p&gt;
&lt;p&gt;簡單的結論，如果是使用 HLS 那就要注意你的 file descriptor 限制囉。&lt;/p&gt;
&lt;h2 id=&#34;heading4&#34;&gt;人多時頻寬問題&lt;/h2&gt;
&lt;p&gt;這裡我想問個問題。&lt;/p&gt;
&lt;h4 id=&#34;-media-server--hls--server--&#34;&gt;假設我們都是直接從 Media Server 用 HLS 來看影片的話，那一台 Server 可以有幾個人，同時的在線上看片呢 ?&lt;/h4&gt;
&lt;p&gt;假設 Server 頻寬為 1G/600M HiNet 光世代的方案。&lt;/p&gt;
&lt;p&gt;這裡先聊聊頻寬為 1G/600M 。&lt;/p&gt;
&lt;p&gt;首先 1 G 代表下載頻寬，它實際上是指你每秒中的總下載量限制為 125 MB (計算如下)，但事實上還要扣一些系統內部使用的控制封包或啥的，所以你大約能使用的頻寬，簡單的算為 100 MB。這也代表你下載東西時的總限制量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 G = 1000 Mbps (bits per second) = 125 MB (byte per second)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而 600 M 為上傳頻寬，它實際上代表每秒中的總上傳量限制為 75 MB，但咱們實際上能用的算 60 MB 好了 (請別算太細)。&lt;/p&gt;
&lt;h4 id=&#34;-60-mb--server--&#34;&gt;那 60 MB 的上傳量，咱們的 Server 可以支援幾個人同時看人 ?&lt;/h4&gt;
&lt;p&gt;以看 FHD (1080 P) 這種高畫質的影片來看，基本上 10 分鐘的片子大約就需要 150 MB 左右，所以 1 分鐘大約需要 15 MB，而 1 秒鐘為 0.25 MB。&lt;/p&gt;
&lt;p&gt;那就代表每秒鐘 Server 每位用戶看片我需要花 0.25 MB，因此以 60 MB 的上傳量，我一台大概可以承受約為 240 位使用者，這只是簡單的計算不過誤差應該不太離太遠。&lt;/p&gt;
&lt;p&gt;嗯就 240 位。&lt;/p&gt;
&lt;p&gt;如果超果了就會開始發生有人會非常的卡的在看片，然後就怒關了。&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;人多時效能消耗問題&lt;/h2&gt;
&lt;p&gt;以現階段原始的架構，在直播時 Media Server 要做的事情就是接受直播主的 RTMP 串流，並且將之轉換成 client 所要求的協議內容，例如 Server 如果有提供 HLS 觀看，那就需要轉換成 .m3u8 與 .ts 檔，而 Http-FLV 也要轉換成.flv 流容器格式。&lt;/p&gt;
&lt;p&gt;另外如果聽眾人多時，這台 Server 還要一直的計算要發出去的串流封包，那這樣他遲早會 hold 不住的。&lt;/p&gt;
&lt;h2 id=&#34;heading6&#34;&gt;遠距離看片卡頓的問題&lt;/h2&gt;
&lt;p&gt;在點播中，如果有一位使用者馬克人在國外例如美國，然後咱們的 Server 架設在台灣，那這時馬克要看片時會發生什麼事情呢 ?&lt;/p&gt;
&lt;p&gt;馬克會發現卡卡 der。&lt;/p&gt;
&lt;p&gt;基本上最主要的原因就在於距離，距離遠了就代表你傳輸資料時間需要比較久，然後傳輸時間久了就代表發生問題的機率增加了，例如封包掉了或是封包順序不對，這些都需要花費時間來處理，這也是為啥會卡頓的原因之一。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181106/200893589MbEQJgfGa.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading7&#34;&gt;總結問題與解法&lt;/h2&gt;
&lt;p&gt;總結以下的問題：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;人多時連線數限制問題。&lt;/li&gt;
&lt;li&gt;人多時頻寬問題。&lt;/li&gt;
&lt;li&gt;人多時效能消耗問題。&lt;/li&gt;
&lt;li&gt;遠距離看片卡頓的問題。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那這些要如何解決呢 ?&lt;/p&gt;
&lt;p&gt;基本上傳統面對人多的時後，咱們可以將架構改成如下，就是基本的增加機台 Server，然後外面來個 Load Balance ，這樣基本上可以解決掉 1、3 的問題。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181106/20089358VuSkqmyJZx.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是如果是在 Media Server 這種類型的應用那就無法解決 2、4 。&lt;/p&gt;
&lt;p&gt;因此接下來一篇文章，咱們要先介紹一個可以解決 2、4 問題的技術，那就是&lt;code&gt;CDN&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;heading8&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dcard.tw/f/ncue/p/226266645&#34;&gt;科普小知識：網路速度多少撥網路影片才會順？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://0123456789.tw/?p=3467&#34;&gt;網路速度多少撥網路影片才會順？(youtube,pps,justin,twitch),光纖網路價格比較&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kknews.cc/zh-tw/tech/v42e2l.html&#34;&gt;直播CDN相關技術&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-21之如何建立的像 17 一樣的直播功能呢 ?</title>
      <link>https://mark-lin.com/posts/20180921/</link>
      <pubDate>Fri, 21 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180921/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;上一篇文章中，咱們已經學習了如何建立點播這種類型的網站應用，接下咱們要來學學如何建立&lt;code&gt;直播&lt;/code&gt;應用。&lt;/p&gt;
&lt;p&gt;在筆者的&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10204764&#34;&gt;30-09之別人要如何聽到我的聲音呢 ?&lt;/a&gt;有提到三種影音的傳遞方式，分別為：&lt;/p&gt;
&lt;p&gt;將聲音檔案直接丟給對方 ( 方法 1 )
將聲音檔案以串流的方式傳送給對方 ( 方法 2 )
像直播或網路電話一樣即時的將聲音傳送給對方 ( 方法 3 )&lt;/p&gt;
&lt;p&gt;接下來我們將來實作方法 3 的選項，而這東西事實上就是直播網站的應用，像 17 就是這種類型的應用，本篇文章將會說明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何建立的像 17 一樣的直播功能呢 (可以動就好版) ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181105/200893581RcXw4huRl.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;本篇將分為以下幾個章節：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直播架構原理。&lt;/li&gt;
&lt;li&gt;實作 - 建立 Media Server。&lt;/li&gt;
&lt;li&gt;實作 - 網頁用戶端取得串流影像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading1&#34;&gt;直播架構原理&lt;/h2&gt;
&lt;p&gt;直播的架構最基本的如下圖，基本上和點播很相似，只差了直播主推送聲音到 Media Server 這個步驟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181105/20089358nqLraVoW8t.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然後基本上推流的協議，應該是只有一種選擇&lt;code&gt;RTMP&lt;/code&gt;，網路上看到有人說 HLS 這點我還要待調查，我先打個問號，
然後還有提到 WebRTC 這個可以當推流 (不過它應該不算傳輸協議)，這理論上應該是行，這之後 WebRTC 的文章會來聊聊。&lt;/p&gt;
&lt;p&gt;而拉流就有不少&lt;code&gt;RTMP&lt;/code&gt;、&lt;code&gt;HLS&lt;/code&gt;、&lt;code&gt;HTTP-FLV&lt;/code&gt;、&lt;code&gt;MPEG-DASH&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;老樣子問個問題。&lt;/p&gt;
&lt;h4 id=&#34;-&#34;&gt;那要選擇那個協議來當拉流呢 ?&lt;/h4&gt;
&lt;p&gt;首先我覺得要先看你的直播應用是否為&lt;code&gt;互動性&lt;/code&gt;很要求的，如果是它就只有兩個選擇 RTMP 與 HTTP-FLV。不過 RTMP 拉流應該會有不少設備無法使用(果粉)，所以最後應該會選 HTTP-FLV 吧。&lt;/p&gt;
&lt;p&gt;而如果是不會太在意互動性的直播，例如運動賽事直播這種，那選那個，我覺得就看用戶那的支援度吧。&lt;/p&gt;
&lt;h2 id=&#34;---media-server&#34;&gt;實作 - 建立 Media Server。&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;這裡的 Media Server 基本上要做兩件事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以接受直播端的影音推流，通常是 RTMP。&lt;/li&gt;
&lt;li&gt;收到 RTMP 後，可以根據用戶的拉流協議來進行轉換 (ex. 如果是 HLS，那就要轉成 .m3u8 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這裡咱們就直接使用這個 nodejs 的 Media Server 套件，這裡我們就不深入探討 Media Server 相關選擇，這裡先只追求可以動就好 ( 改天有空在來討探 )。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/illuspas/Node-Media-Server&#34;&gt;nodejs-media-server&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用方法很簡單。&lt;/p&gt;
&lt;p&gt;首先將程式碼抓下來，然後將套件安裝好，接下來執行就好。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/illuspas/Node-Media-Server.git
cd Node-Media-Server
npm install

node app.js
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;執行完，如果你看到如下圖的模樣，那就代表成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181105/20089358Tss5iyF5eU.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;--&#34;&gt;實作 - 網頁用戶端取得串流影像&lt;/h2&gt;
&lt;p&gt;接下來我們來建立一個簡單的網頁來當聽眾，然後他會使用 HTTP-FLV 拉流來觀看直播主的畫面。這段程式碼很簡單，它就只要載入 flv.js 並且指定你要觀看的 HTTP-FLV 串流位置就完成了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;Test&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;title&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;head&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://cdn.bootcss.com/flv.js/1.4.2/flv.min.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;video&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;controls&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;video&lt;/span&gt;&amp;gt;

    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;text&amp;#34;&lt;/span&gt; /&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;button&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;load&amp;#34;&lt;/span&gt;&amp;gt;Load&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;button&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;flvjs&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;isSupported&lt;/span&gt;()) {
            document.&lt;span style=&#34;color:#a6e22e&#34;&gt;querySelector&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#load&amp;#34;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;video&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; document.&lt;span style=&#34;color:#a6e22e&#34;&gt;getElementById&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;video&amp;#39;&lt;/span&gt;);
                &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; document.&lt;span style=&#34;color:#a6e22e&#34;&gt;querySelector&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;input&amp;#34;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;flvPlayer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;flvjs&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createPlayer&lt;/span&gt;({
                    &lt;span style=&#34;color:#a6e22e&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;flv&amp;#39;&lt;/span&gt;,
                    &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;http://localhost:8000/live/&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.flv&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;
                });
                &lt;span style=&#34;color:#a6e22e&#34;&gt;flvPlayer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;attachMediaElement&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;video&lt;/span&gt;)
                &lt;span style=&#34;color:#a6e22e&#34;&gt;flvPlayer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;load&lt;/span&gt;();
                &lt;span style=&#34;color:#a6e22e&#34;&gt;flvPlayer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;play&lt;/span&gt;();
            })
        }
    &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;body&lt;/span&gt;&amp;gt;

&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;heading2&#34;&gt;最後執行結果&lt;/h2&gt;
&lt;p&gt;在 Server 與 Client 都完成以後，咱們接下來就來執行看看&lt;/p&gt;
&lt;h3 id=&#34;heading3&#34;&gt;直播端&lt;/h3&gt;
&lt;p&gt;我們使用 ffmpeg 假裝為某個直播主，然後打 RTMP 串流到 Server 中。下面指令中，我使用某個 .mp4 影片來假裝直播主的影音，接下來將它推送 rtmp 到指定的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffmpeg -re -i test.mp4 -c copy -f flv rtmp://localhost/live/mark
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;heading4&#34;&gt;聽眾&lt;/h3&gt;
&lt;p&gt;然後直播主已經在開直播了，接下來我們只要指定某個直播主就好，像上面我這個直播主是用 mark 這個串流，你這時就可以使用 http://127.0.0.1:8000/live/mark.flv 就可以觀看了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181105/20089358Hx7tUZPT1u.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;本篇文章中，咱們學習到了如何建立最簡單的 17 直播功能，接下來咱們要來探討一下，現在這種架構有什麼問題。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>