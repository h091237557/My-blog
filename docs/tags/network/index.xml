<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>network on 拿鐵派的馬克 Blog</title>
    <link>https://mark-lin.com/tags/network/</link>
    <description>Recent content in network on 拿鐵派的馬克 Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <managingEditor>h091237557@gmail.com (marklin)</managingEditor>
    <webMaster>h091237557@gmail.com (marklin)</webMaster>
    <lastBuildDate>Sun, 22 Sep 2019 20:16:57 +0800</lastBuildDate>
    
        <atom:link href="https://mark-lin.com/tags/network/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>30-22 之網路傳輸的優化 - HTTP 1.0 至 HTTP 3.0</title>
      <link>https://mark-lin.com/posts/20190922/</link>
      <pubDate>Sun, 22 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190922/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/20089358apr4SjNmTn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;本篇文章中，網路世界最重的協議 http，不只如上圖應用所示只有用戶端那有用到，現階段大部份很多 server 都還是會實用 http 去其它 server 取資料，所以一個系統中，最重要的應用層協議，咱們幾乎可能說是『 Http 』。&lt;/p&gt;
&lt;p&gt;本篇文章分為以下幾個章節，事實上也就是所謂的 http 進化史 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 行前基本知識&lt;/li&gt;
&lt;li&gt;HTTP 1.X 的過去式&lt;/li&gt;
&lt;li&gt;HTTP 2.0 的現在式&lt;/li&gt;
&lt;li&gt;HTTP 3.0 的未來式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;網路層的 http 優化事實上沒有啥重點，那就是 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;儘可能將 http 升級更高的版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;但是，為什麼要升級才是這一篇文章的重點。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;http-&#34;&gt;Http 行前基本知識&lt;/h2&gt;
&lt;p&gt;在這篇文章正式開始一前，咱們有些前知識要來學習一下，不然下面會有很多東西看不太種。&lt;/p&gt;
&lt;p&gt;首先 http 基本上可以說是網路世界的基礎，它當初建立出來的目的是為讓瀏覽器這個應用層的應用使用，然後它在傳輸資料時所使用的協議為『 TCP 』，所以當咱們要建立連線時會進行所謂的『 TCP 三次握手 』如下圖 1 所示 :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181026/2008935828kHLNtXuX.png&#34; alt=&#34;&#34;&gt;
圖 1 : tcp 建立連線 ( 三次握手 )&lt;/p&gt;
&lt;p&gt;然後有了這個連線以後，咱們就可以開始進行資料傳輸。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181026/20089358jMMPnt5Vc0.png&#34; alt=&#34;&#34;&gt;
圖 2 : tcp 傳輸資料&lt;/p&gt;
&lt;p&gt;最後斷線時就有所謂的四次揮手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181026/20089358QdssDQJC9f.png&#34; alt=&#34;&#34;&gt;
圖 3 : tcp 斷線 ( 四次揮手 )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小備註 1 ~&lt;/strong&gt;
如果不太熟細 tcp 的知識的友人，可以至筆者之前寫的這篇文章看看。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180911/&#34;&gt;即時影音通訊-30-11之 TCP 與 UDP 協議&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小備註 2 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果是連『網路協議』是什麼都不太能理解的友人，可以至筆者之前寫的這篇文章看看，希望可以幫到你。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180910/&#34;&gt;即時影音通訊-30-10之通訊協議的基本常識&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;http-1x-&#34;&gt;HTTP 1.X 的過去式&lt;/h2&gt;
&lt;p&gt;首先咱們簡單的從最原始的 1.0 談一下，它的基本特點就是如下圖 4 所示，一個請求會需要執行連立連線、傳輸資料、斷線這三個步驟。而假設有 10 個請求，就要重複執行這 10 次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/20089358HYjUT4j7ED.png&#34; alt=&#34;&#34;&gt;
圖 4 : 沒有 keep-alive 的 http 請求流程&lt;/p&gt;
&lt;p&gt;當然你想想，如果所有 http 請求都是這樣處理，那就代表每一張圖、每一個檔、每一個 html 都需要進行 tcp 三次握手建立連線與四次揮手關閉連線，這樣對發送方與接受方帶來的性能影響非常的巨大。&lt;/p&gt;
&lt;p&gt;因為就誕生一個叫『 keep-alive 』的機制來復用 tcp 連線。&lt;/p&gt;
&lt;p&gt;就是在 header 上加上這個標頭 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Connection: Keep-Alive
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection&#34;&gt;MDN-WEB-Connection&lt;/a&gt;
&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive&#34;&gt;MDN-WEB-Keep-Alive&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那這樣在傳完資料以後，就不會自動關閉連線，而之後的請求也就同樣使用這連線就好，如下圖 5 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/20089358wLDIK3uHAF.png&#34; alt=&#34;&#34;&gt;
圖 5 : 加上 keep-alive 後的 http 請求&lt;/p&gt;
&lt;p&gt;keep-alive 這個參數在 http 1.1 預設就是會幫你帶，也就是說在 1.1 預設是長連線，但不代表這個連線會永久存在，通常會有一個 keep-alive timeout 參數會設置一段時間沒有用後，就自動關閉。&lt;/p&gt;
&lt;p&gt;keep-alive timeout 這個參數通常會是會在 web server 設置，例如 nginx 可以設定成如下。其中 75 秒是 nginx 的預設。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http {
  keepalive_timeout 75s
  keepalive_requests 100
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而上述這些就是 http 1.1 的現況。接下來咱們來看看 http 1.1 這個我們最常用的協議，它還有那些問題 ?&lt;/p&gt;
&lt;h3 id=&#34;-1--http-11-&#34;&gt;問題 1 : HTTP 1.1 只能串行傳輸&lt;/h3&gt;
&lt;p&gt;如下圖 6 ，也就是一個請求需要等待回應以後，下一個請求才能發出去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/20089358atLSwXoH8m.png&#34; alt=&#34;&#34;&gt;
圖 6 : http 串行請求概念圖&lt;/p&gt;
&lt;p&gt;然後咱們以回應時間的角度來看一下它的時間，如下 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Request A : 2 sec
Request B : 1 sec
Request C : 3 sec
(這些秒數代表 server 所需花費處理時間)

第 0 秒時 : 發送 request GET A
第 2 秒時 : 收到 request A 回應，並且發出 request GET B
第 3 秒時 : 收到 request B 回應，並且發出 request GET C
第 6 秒時 : 收到 request C 回應

共 6 秒
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;為什麼呢 ? 為什麼會只能串行傳輸呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這點我真的不知道，我查了很多文章都只寫說 http 1.x 發送請求後，需要等到回應，才能在發下一個請求，就寫這樣，就算去看這個非常厚的文件，好像也沒看到寫為啥，目前也只能去慢慢的挖這份文件來找答案…… 目前覺得比較大的原因可能在於 tcp，但只是推測，目前沒看到任何文件有說 tcp 導致 http 只能串行傳。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.w3.org/Protocols/rfc2616/rfc2616.html&#34;&gt;rfc2616-Hypertext Transfer Protocol &amp;ndash; HTTP/1.1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可是為什麼我打開不少網站，然後開 chrome devtool networrk 看，有些請求是並行啊 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有幾種情況 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它已經升級 http 2。&lt;/li&gt;
&lt;li&gt;它自已打開 http pipeline 來使用。&lt;/li&gt;
&lt;li&gt;那些請求是 http 緩存 ( memory cache 或 disk cache )。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些情況下，那就有可能看到並行。順到說一下，如果不太清楚 http 緩存的東東，可以參考筆者的這一篇文章。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20190921/&#34;&gt;30-21 之網路傳輸加速 - CDN 與 HTTP 緩存&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;http-11--pipeline---&#34;&gt;HTTP 1.1 的嘗試增加性能的方法 Pipeline ( 失敗 )&lt;/h4&gt;
&lt;p&gt;http 嘗試建立一些方法來進行比串行傳輸更有效率的方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;而這方法所謂的 HTTP Pipeline&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;請求過程會變成如下圖 7 所示，就是將二個 http 請求打包成一組 tcp 資料發送，然後這時回應該就一次收二個 ( 依順序 )。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/200893589ckJocqL6k.png&#34; alt=&#34;&#34;&gt;
圖 7 : http pipeline 請求&lt;/p&gt;
&lt;p&gt;下面這簡單的回應時間範例可以來讓我們更能理解 pipeline 的運行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Request A : 2 sec
Request B : 1 sec
Request C : 3 sec
(這些秒數代表 server 所需花費時間)

第 0 秒時 : 發送 request GET A,B,C
第 1 秒時 : 等待
第 2 秒時 : 回應 request A,B (由於 B 排在 A 後面，所以即使 B 已經完成，但仍然還是要照順序回應)
第 3 秒時 : 回應 request C

共 3 秒
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這樣的確可以增加性能，但是它有幾個問題。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;head-of-line blocking ( HOL ) 問題，假設你使用 http pipeline 發了二個請求，那這時如果第一個請求要操作很久，那就會阻塞住這整個 http pipeline 的工作，就如同上述範例 A ( 2s ) 阻塞 B ( 1s )。&lt;/li&gt;
&lt;li&gt;只要寡等請求如 GET 或 HEAD 才能使用。&lt;/li&gt;
&lt;li&gt;有些代理伺服器沒有支援 pipeline 的實作，或是實作不完全。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由於有以上幾個問題，因此目前大部份的瀏覽器 http pipeline 功能預設都關閉。&lt;/p&gt;
&lt;p&gt;比較詳細的原因可以參考&lt;a href=&#34;https://stackoverflow.com/questions/30477476/why-is-pipelining-disabled-in-modern-browsers&#34;&gt;這篇 stackoverflow 的回答&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 ~&lt;/strong&gt;
tcp 也有所謂的 head-of-line blocking 喔。&lt;/p&gt;
&lt;h3 id=&#34;-2---http-&#34;&gt;問題 2 : 瀏覽器有限制 HTTP 同一個時間請求數量&lt;/h3&gt;
&lt;p&gt;由於上述所說 http 現階段只能串行傳輸，這也導致有些人會改使用另外開新 http 連線 ( 就是另開一個 tcp ) 來處理請求，但這時就有個問題會導致並行處理數上不去 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;瀏覽器對 domain 的 http 請求限制，以 chrome 的話它是 6 個限制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.pushtechnology.com/cloud/latest/manual/html/designguide/solution/support/connection_limitations.html&#34;&gt;各瀏覽器的連線限制&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading1&#34;&gt;各種奇技淫巧嘗試優化&lt;/h3&gt;
&lt;p&gt;由於無法使用 pipeline 且 domain 有限制 http 請求數，因此在 http 1.1 的世界中，開發者基本上有一個共同的準則 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;儘可能的減少 http 請求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;對，只要能減少 http 請求，即時只能串行傳輸，那性能影響也可以壓到很小。所以後人發展了以下幾個奇技淫巧來儘可能的減少 http 請求 :&lt;/p&gt;
&lt;h4 id=&#34;1---spriting&#34;&gt;1 :  Spriting&lt;/h4&gt;
&lt;p&gt;這是專門用來傳送圖片的，正常來說 http 只能傳送一張圖片，所以如果一個畫面有很多圖，那就要發送很多次請求，而這時就有人想出這個奇技淫巧 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;將小圖組成一個大圖，然後在使用 js 或 css 來取得某個小圖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;像這個友人說明的技術就是 Spriting。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cythilya.github.io/2018/08/20/svg-sprites/&#34;&gt;SVG Sprites-Summer。桑莫。夏天&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;2--js-bound&#34;&gt;2 : JS Bound&lt;/h4&gt;
&lt;p&gt;這個技術正常應該是都會用到，這個奇技淫巧就是 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;將多個 js 檔打包成一個 js 檔。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而通常咱們會順到將這個一包 js 檔在壓縮，讓它變的小小的。&lt;/p&gt;
&lt;h4 id=&#34;3--domain-sharding&#34;&gt;3 : Domain Sharding&lt;/h4&gt;
&lt;p&gt;這個是專門用來處理瀏覽器 domain 限制，它主要的手法就是將一些資源放在不同的 domain 上，如下圖所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/20089358v5SaA6AhAb.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;http-2-&#34;&gt;HTTP 2 的現在式&lt;/h2&gt;
&lt;p&gt;雖然上面用了不少奇技淫巧來處理上面這些問題，但是每一種都是應用層的處理方式，而不是個大家都遵守的『 協議 』，也就代表不是每個應用都是這樣處理的，因此後來 google 大神就開啟了 spdy 協議來嘗試解決，而這個就是 http2 的前身。&lt;/p&gt;
&lt;p&gt;http 2 的重點就是兩個字  :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它針對性能方面進行了以下幾點的加強 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它解決了 http pipeline 會阻塞的問題。&lt;/li&gt;
&lt;li&gt;header 壓縮。&lt;/li&gt;
&lt;li&gt;它提供了 Server Push 的功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http-2--http-pipeline--&#34;&gt;HTTP 2 如何解決 HTTP Pipeline 會阻塞的問題呢 ?&lt;/h3&gt;
&lt;p&gt;http2 解決了 http pipeline 會阻塞的問題，但這裡不是說它在 pipeline 機制上進行改善，而是直接改變整個 http 的傳輸機制，讓它可以不會阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小提醒 ~&lt;/strong&gt;
http2 沒有解決 tcp head-of-line locking 的問題。&lt;/p&gt;
&lt;h4 id=&#34;-http-2--frame--stream&#34;&gt;解決重點 HTTP 2 的 Frame 與 Stream&lt;/h4&gt;
&lt;p&gt;它是如何解決的呢 ?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先 http 2 它修改了一下封包的包裝變成如下圖 8 所示，它做兩個改變。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;從文本格式改為二進位格式，如圖 8 中的左邊橘色的 binary frame。&lt;/li&gt;
&lt;li&gt;將封包結構從新定義成 frame 這個概念，如果 8 中的右邊橘色的 frame。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/20089358SSaMvjzcOp.png&#34; alt=&#34;&#34;&gt;
圖 8 : http 2 的封包格式 ( 圖片來源 : &lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/http2/&#34;&gt;developers.google-Introduction to HTTP/2&lt;/a&gt; )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下來又引入了另一個重要概念『 stream 』。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;stream 這東西你可以想成一條管子，然後裡面傳送的東西單位就是 frame，然後每一個 frame 都有一個 stream identifier 這欄位確認它是那個 stream。這裡要注意，它是一個邏輯的概念，而不是真的有這個 stream，它只是用 stream 來區別 request。&lt;/p&gt;
&lt;p&gt;然後加入了『 frame 』與『 stream 』的元素以後，http2 的傳輸變成如下圖 9 所示，每一個請求都是一個 stream，而 stream 中有多個 frame，下圖每個小格子就是 frame。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/20089358sHP7sI6Ehb.png&#34; alt=&#34;&#34;&gt;
圖 9 : http2 傳輸概念 ( stream、frame )&lt;/p&gt;
&lt;p&gt;然後與 http 1.1 相比較變成如圖 10 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/200893588ZjO4LvSOA.png&#34; alt=&#34;&#34;&gt;
圖 10 : http2 VS http 1.1 傳輸概念。&lt;/p&gt;
&lt;p&gt;由於每個 frame 都有說明是那一個 stream，而每一個 stream 你可以想成就是一個 http 請求，所以這時就算傳送的順序有問題，它仍然可以根據 frame 所屬的 stream 編號，重新組出某個請求的資料。&lt;/p&gt;
&lt;p&gt;所以最後在 http2 就可以達成以下的傳輸方式，如下圖 11 所示，請求 b 不在需要等待 a 回來才能收到請求 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/20089358qjjdnXZvVC.png&#34; alt=&#34;&#34;&gt;
圖 11 : http2 的並行傳輸流程&lt;/p&gt;
&lt;p&gt;然後回應時間如下所示 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Request A : 2 sec
Request B : 1 sec
Request C : 3 sec
(這些秒數代表 server 所需花費時間)

第 0 秒時 : 發送 request GET A,B,C
第 1 秒時 : 收到 B 的回應。
第 2 秒時 : 收到 A 的回應。
第 3 秒時 : 收到 C 的回應。

共 3 秒
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;header-&#34;&gt;Header 壓縮&lt;/h3&gt;
&lt;p&gt;在 http 2 中，它有針對 header 專門進行壓縮。&lt;/p&gt;
&lt;p&gt;不過 http 1.1 不是本來就有 gzip 壓縮了碼 ? 嗯對沒錯，它是重點在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;http 1.1 只是壓縮 body，沒有壓縮 header&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你看看 http 1.1 header 欄位就知道，它寫的很清楚是 content 內容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;content-encoding: gzip
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;server-push-&#34;&gt;Server Push 的功能&lt;/h3&gt;
&lt;p&gt;這個功能簡單的說它就是讓 server 端可以推送資源到瀏覽器，下圖 11 為 http 1.1 與 http 1.2 的讀網頁的差別，這圖應該就可以很清楚的知道 server push 做的事情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/20089358szMxmpCCz1.png&#34; alt=&#34;&#34;&gt;
圖 12 : http 1.1 與 http 1.2 的讀網頁的差別。&lt;/p&gt;
&lt;p&gt;這裡順到簡單的談一下 websocket 與 http2 server push 的關係，雖然它們都是可以讓 server 推東西，但是還是有點不太一樣，假設你是要推『 資料 』到前端的就用 websocket，而 server push 是用在這種 server 端主動推送『 資源、檔案 』這種情況，會更適合。&lt;/p&gt;
&lt;h2 id=&#34;http-30-&#34;&gt;HTTP 3.0 的未來式&lt;/h2&gt;
&lt;p&gt;上面在 http2 有提到，它解決的是 http pipeline 的 head-of-line locking，但是它沒有辦法解決 tcp 的 head-of-line locking，所以它事實上還是會產生下面這張圖。&lt;/p&gt;
&lt;p&gt;如圖 13 所示，當在 http2 時，已經將兩個請求分成兩個 stream 且多個 frame 後，未依順序的請 tcp 傳輸，但是如果第一個傳輸的 a1 frame 遺失或消失了，那就會導致整個 tcp 被卡住，為了等待 a1 重傳。&lt;/p&gt;
&lt;p&gt;但是假設是在下圖 13 中的 a3 frame 遺失，那請求 b 還是會正常的處理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/20089358iZOSQWDXjh.png&#34; alt=&#34;&#34;&gt;
圖 13 : http2 的問題&lt;/p&gt;
&lt;h3 id=&#34;--tcp--headofline-locking&#34;&gt;仍然會卡住原因 : TCP 的 Head-of-line locking&lt;/h3&gt;
&lt;p&gt;這個問題主要是出在 tcp 的要求的可靠性，所建立出來的機制問題。它為了可靠性基本上做了兩件事情 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;『 順序 』與『 重傳 』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;咱們來看一下 tcp 傳送資料的流程，如下。&lt;/p&gt;
&lt;p&gt;假設咱們在一個 tcp 中有這些資料要傳輸，我們給它個編號為 1 至 10。&lt;/p&gt;
&lt;p&gt;1 . 將準備要發送的資料編號 1 至 3，放至緩衝區。
2 . 幫 1 至 3 資料設定時器。
3-1 . 時間內有收到接受方的 ack ( 代表接受方有收到 1 至 3 資料 )，清除緩衝區。
3-2 . 一直沒收到 ack，則重傳。
4 . 再開始處理 4 至 7 直到全部傳完後，就送去給 http 應用層。&lt;/p&gt;
&lt;p&gt;而這裡問題就出在這個機制，如果這時有個來插花的 http 也想用同一條 tcp 來傳輸，那這樣就會讓 tcp 產生混亂不知道如何解析這個順序，而且如果其中一個請求傳封包後，一直沒有 ack 也就會卡住所有的請求，因此 tcp 就只能這樣處理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 補充知識 : tcp 滑動窗口 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;熟悉 tcp 的友人應該知道，關於第一點只有 3 個資料 ( 1 至 3 ) 放至緩衝區這個地方，其中 3 這個數量就是滑動窗口的概念，這裡簡單的說明一下這個知識。&lt;/p&gt;
&lt;p&gt;tcp 基本的重傳機制如下，假設 a 發送封包給 b，然後 b 會發送給 a 一個 ack ( 證明收到 )，然後這時 a 才會再發送下一個封包，但如果在一定時間內沒收到 b 的 ack ，那它就會重傳。&lt;/p&gt;
&lt;p&gt;但這個機制非常的毛，原因在於要一直等，性能吃很大，因此 tcp 又加了這個機制下去 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;滑動窗口 ( Sliding window )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假設咱們有個請求，它的資料包序號為 1 至 8，然後下圖 6 上面部份紅色區塊窗口裡的封包(1 ~ 3)代表為可以發送的封包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191007/20089358oCSLGlBU1D.png&#34; alt=&#34;&#34;&gt;
圖 14 : 滑動窗口概念&lt;/p&gt;
&lt;p&gt;然後當發送完 1 至 3 封包後，如果接受到 1、2 封包後，窗口會往右移，變成上圖 6 下面部份，然後通常裡面會有個 point 要來判斷那些可以發送，那些還在等 ack。&lt;/p&gt;
&lt;p&gt;由於有了這個機制的封包發送就不需要一直花時間等 ack，而可以並行的丟封包出去囉。&lt;/p&gt;
&lt;p&gt;這裡只淺談一下滑動窗口的概念，如果真的要完整說明，那至少還要在開一篇……&lt;/p&gt;
&lt;h3 id=&#34;http-3----tcp--quic&#34;&gt;HTTP 3 解法 : 換掉 TCP 改用 QUIC&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP3 = HTTP + QUIC ( Quick UDP Internet Connections )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由於 tcp 有上述的問題，所以就在考慮將傳輸層的 tcp 協議換掉，改成以 udp 為基礎的 quic。這裡簡單的說一下 quic、tcp、udp 都是傳輸層的東西，而 quic 是以 udp 這個不可靠的東西進行改善，讓它變成可靠性傳輸。&lt;/p&gt;
&lt;p&gt;quic 的可靠性的重點在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多傳一個包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假設一個請求有三個封包要傳輸，而這時 quic 則會傳一個特殊包，它保含其它三個的資料，也就是說就算前三個中有一個包丟失了，仍然可以用省下的三個來組合出丟失的那一個。&lt;/p&gt;
&lt;p&gt;例如假設一個請求 quic 會準備成以下的包 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;資料包 : A,B,C,D
特殊包 : Z
它們的關係為 : A + B + C + D = Z
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以當 A 幫包丟失時，咱們可以用以下的方法反推出 A。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A = Z - B - C - D
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而這個演算法就是在硬碟那很有名的 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Raid 5 演算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這裡就先淺淡到這。http 3 事實上還有非常多的事情還沒提到，這裡就先從 http 1.x 時代就一直被人詬病的 tcp HOL 問題拿出來看看 http 3 這它是如何解決的，之後未來有時間在詳細的寫寫 http 3 的事情。&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章咱們基本上學習了 http 的整個歷史，並且也知道每一個時代的痛點與嘗試的解決方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;http 1.x : 只能串行傳輸，後來有嘗試用 http pipeline 改善，但因很多問題，所以大部份瀏覽器預設都是不用的。&lt;/li&gt;
&lt;li&gt;http 2 : 嘗試的解決 http pipeline 的 HOL 問題，它解決的手法是提出 stream 與 frame 的機制來處理。&lt;/li&gt;
&lt;li&gt;http 3 : 嘗試的解決 tcp 的 HOL 問題，它解決的手法就是不用 tcp 改用 quic。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最後這裡總結一下這個章節的性能優化建議 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;嘗試的將服務至升級支援為 http 2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;http 2 在 2019 年這個時代，根據 W3Techs 統計，已經有大約 40+% 的網站已經有進行支援，並且提能也提升不少，可以參考此網站的比較喔。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.http2demo.io/&#34;&gt;http 1.1 vs http 2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而由於 IETF 在 2018 年時，正式的將基於 quic 協議的 http 命名為 http3，目前世界上大部份的設備應該是都還沒有完全支援，所以就先別考慮了。&lt;/p&gt;
&lt;h2 id=&#34;heading3&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5&#34;&gt;wiki-HTTP持久連接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.chionlab.moe/2016/11/07/tcp-keepalive-on-chrome/&#34;&gt;TCP keepalive的探究 (2) : 浏览器的Keepalive机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/9334401/http-keep-alive-and-tcp-keep-alive&#34;&gt;HTTP Keep Alive and TCP keep alive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lanjingling.github.io/2016/06/11/nginx-https-keepalived-youhua/&#34;&gt;nginx优化——包括https、keepalive等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/28894266&#34;&gt;聊聊 TCP 中的 KeepAlive 机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.gslin.org/archives/2014/02/22/4283/domain-sharding-%E7%9A%84%E8%AA%BF%E6%95%B4/&#34;&gt;Domain Sharding 的調整&amp;hellip;-Gea-Suan Lin&#39;s BLOG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5ce37660f265da1bb13f05f0&#34;&gt;什么是队头阻塞以及如何解决&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://http3-explained.haxx.se/zh/why-tcphol.html&#34;&gt;TCP队头阻塞（head of line blocking）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://xiaozhuanlan.com/topic/2083674195&#34;&gt;试图取代 TCP 的 QUIC 协议到底是什么?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/http2/&#34;&gt;developers.google-Introduction to HTTP/2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html&#34;&gt;HTTP/2 服务器推送（Server Push）教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-21 之網路傳輸的加速 - CDN 與 HTTP 緩存</title>
      <link>https://mark-lin.com/posts/20190921/</link>
      <pubDate>Sat, 21 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190921/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191006/20089358zmfCBeJfDV.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;前幾篇文章中，咱們討論完資料庫層的資料緩存以後，接下來咱們要來談談另外兩個緩存 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CDN ( Content Delivery Network )&lt;/li&gt;
&lt;li&gt;HTTP 緩存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章分為以下幾個章節 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CDN 與運行流程&lt;/li&gt;
&lt;li&gt;HTTP 緩存與運行流程&lt;/li&gt;
&lt;li&gt;CDN 與 HTTP 緩存搞在一起用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這裡先說一下，接下來有一些 cdn 的章節我是直接抓以前我寫的文章來簡單修改一下，不然我還真想不到 cdn 這還要寫什麼。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180923/&#34;&gt;30-23之 CDN 的說話島 ( AWS CloudFront CDN 實作 )&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;cdn-&#34;&gt;CDN 與運行流程&lt;/h2&gt;
&lt;p&gt;在開始理解 CDN 之前，咱們先來說說傳統上一個 client 連線到一個網站的流程。&lt;/p&gt;
&lt;p&gt;首先看看下面這張圖 1 所示，這張圖說明了每當一個 client 發送一個請求到 web 網站時，web 網站會回傳
html、css 與 javascript 回來，這裡假設咱們的 web 網站還在台灣，然後回應時間大約在 100 ms 以內 (假設)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358L394w8r0oh.png&#34; alt=&#34;&#34;&gt;
圖 1 : 一個台灣用戶連到台灣網站的時間&lt;/p&gt;
&lt;p&gt;然後呢 ~ 這時付你錢的老大叫你將 web 網路架設到美國，因爲免費，然後這時發現回應時間變成 1000 ms 左右，如下圖 2 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358WIYfHP7ksn.png&#34; alt=&#34;&#34;&gt;
圖2 : 一個台灣用戶連到美國網站的時間&lt;/p&gt;
&lt;p&gt;這就是 CDN 最一開始要解決的問題 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;將資源放到離用戶更近一點的地方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CDN ( Content Delivery Network )，它存在的目的就是讓你接近取得網路資料的方法，咱們如果將上圖加入 cdn 後就會長的如下圖 3 所示，所以 client 要取得的一些資源 (ex. html、css、js, imgage, video) 都會去 cdn 那取得。這樣就算你的網站架在美國，但只要 cdn 是在台灣，那回應速度應該也不會有太大的差距。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358NZ2rYxVuzs.png&#34; alt=&#34;&#34;&gt;
圖 3 : cdn 回應加速圖&lt;/p&gt;
&lt;p&gt;雖然當初 cdn 是為了上述原因才誕生的，但它事實上有很多的優點 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抓資源更快。&lt;/li&gt;
&lt;li&gt;保護來源端。&lt;/li&gt;
&lt;li&gt;節省網路傳輸量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且如果是影音傳輸的情境下 cdn 可以說是核心的命脈，好的 cdn 讓你看片不卡卡，壞的 cdn 讓你砸電腦。&lt;/p&gt;
&lt;h3 id=&#34;cdn-1&#34;&gt;CDN 的請求運作原理&lt;/h3&gt;
&lt;p&gt;首先 cdn 基本上會分為三個部份。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;智能 DNS (Intelligent DNS)：事實上是 dns 的某個功能，它的主要功用就是可以幫用戶找到最近的 edge cdn，這樣用戶就可以去最近的 cdn 拿資料了。&lt;/li&gt;
&lt;li&gt;邊緣 CDN ( Edge CDN )：就是散布在不同地方的 cdn 節點。&lt;/li&gt;
&lt;li&gt;來源 Server ( Origin Server )：就是原始資料存放地。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然後基本一個圖片的請求，會變的如下圖 4 所示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;client 發送一個 http 請求來取得圖片。&lt;/li&gt;
&lt;li&gt;dns 收到後，會去請求智能 dns。&lt;/li&gt;
&lt;li&gt;智能 dns 會回傳給 dns 最近 cdn 的 ip 位置。&lt;/li&gt;
&lt;li&gt;client 收到 ip 以後，在發送請求去那個 cdn。&lt;/li&gt;
&lt;li&gt;cdn 收到請求後，會先判斷有沒有緩存此圖片，如果有就直接回傳，沒有則在去來源 server 取得圖片，然後緩存此圖片，最後在送去給 client。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/200893580n0UPwlTOG.png&#34; alt=&#34;&#34;&gt;
圖 4 : cdn 請求流程&lt;/p&gt;
&lt;h4 id=&#34;---server--&#34;&gt;這裡問個問題 ~ 如果 Server 檔案有更新了，通常會如何處理呢 ?&lt;/h4&gt;
&lt;p&gt;基本上就是兩個 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等緩存到期&lt;/li&gt;
&lt;li&gt;強制將 cdn 緩存清空&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常第一個解法是用在一些不那麼需要即時的圖片或啥的檔案來使用，就是時間一到就自然會更新。&lt;/p&gt;
&lt;p&gt;而第二種，通常是用在例如 html 或 js 這種有重要更新一定要吃到它時，就會去 cdn 那強制的刷新緩存，這種所有的請求都會暫時的去來源來抓最新檔案。通常大部份的 cdn 都要設置這個功能。&lt;/p&gt;
&lt;h2 id=&#34;http-&#34;&gt;HTTP 緩存與運行流程&lt;/h2&gt;
&lt;p&gt;http 這個咱們網路世界最常用的協議，它也有支援所謂的緩存機制，它所在的位置嚴格來說如下圖 5 所示，也就是會在瀏覽器將資源存在那台電腦上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191006/20089358bfg610iilV.png&#34; alt=&#34;&#34;&gt;
圖 5&lt;/p&gt;
&lt;p&gt;嚴格來說，我覺得這個緩存稱為『 瀏覽器緩存 』會比較準確一點，雖然它是 http 提供的機制，但是有沒有實作它要看應用層，例如瀏覽器，而如果你是在一個例如 web server 的應用程式裡，另外打 http 給其它 api，你覺得會有緩存嗎 ?&lt;/p&gt;
&lt;p&gt;不一定，真的要看應用層有沒有實現，還真有看到不少套件有真的處理，像 android volly 就有處理 http 緩存。&lt;/p&gt;
&lt;h4 id=&#34;http-1&#34;&gt;HTTP 緩存流程&lt;/h4&gt;
&lt;p&gt;那接下來咱們來看看，如果這時用戶端要一張圖片，那整個緩存流程會是如何，如下圖 6 所示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用戶端發請一個 http 請求要一張馬克圖&lt;/li&gt;
&lt;li&gt;server 回應圖片，且會在表頭塞一個『 Cache-Control:max-age=60 』欄位，標示這張圖片要緩存 60 秒，過期後再去 server 重拿。&lt;/li&gt;
&lt;li&gt;瀏覽器看到回應有 Cache-Control 欄位，就將此圖片存在用戶端內。&lt;/li&gt;
&lt;li&gt;用戶端第二次發送請一個 http 請求要一張馬克圖。&lt;/li&gt;
&lt;li&gt;但發現本地端已經有緩了，就直接從本地端拿回傳。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191006/20089358oPvIedY0V6.png&#34; alt=&#34;&#34;&gt;
圖 6 : http 緩存實現流程&lt;/p&gt;
&lt;h4 id=&#34;http-2&#34;&gt;Http 緩存過期流程&lt;/h4&gt;
&lt;p&gt;接下來咱們來看看過期的流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用戶端發請一個 http 請求要一張馬克圖&lt;/li&gt;
&lt;li&gt;server 回應圖片，且會在表頭塞二個『 Cache-Control:max-age=60 』與 『 Etag: abcde 』 欄位，標示這張圖片要緩存 &lt;strong&gt;60 秒&lt;/strong&gt;，過期後再去 server 重拿 ( etag 過期流程會說 )。&lt;/li&gt;
&lt;li&gt;瀏覽器看到回應有 cache-Control 欄位，就將此圖片存在用戶端內。&lt;/li&gt;
&lt;li&gt;時間過了 &lt;strong&gt;100 秒&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;100 秒後用戶要再一次請求圖片，發現緩存已到期，再請新發送請求，並且帶這從之前 etag 拿到的圖片指紋，發送給 server。&lt;/li&gt;
&lt;li&gt;server 收到後，使用 if-none-match 裡的 etag 指紋來比對一下這張圖片有沒有更新過。&lt;/li&gt;
&lt;li&gt;『 沒 』更新過，則回傳 304，叫瀏覽器自已再從本地端拿圖片來用就行了。&lt;/li&gt;
&lt;li&gt;『 有 』更新過，則回傳新圖片，之後如同第二個步驟。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意一下 etag 主要是為了讓 server 端判斷這張圖片有沒有更新過，如果沒有則叫用戶在抓一次本地端的圖，這樣可以節省網路傳輸。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191006/20089358EaStSvyKxh.png&#34; alt=&#34;&#34;&gt;
圖 7 : http 緩存過期實現流程&lt;/p&gt;
&lt;p&gt;關於 http 緩存的詳細內容，建議看這篇文章，寫得非常好理解。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.techbridge.cc/2017/06/17/cache-introduction/&#34;&gt;循序漸進理解 HTTP Cache 機制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小知識 ~&lt;/strong&gt;
在 http 1.0 有一個 expires 表頭欄位，但是在 http 1.1 之後就幾乎被 cache-control 替代囉，因為 expires 是看用戶端時間，也就是說你調整時間緩存就失效了。&lt;/p&gt;
&lt;p&gt;如果在使用時有帶 expires，http 現在都還是會看 cache-control 的配置。&lt;/p&gt;
&lt;h2 id=&#34;cdn--http-&#34;&gt;CDN 緩存與 HTTP 緩存&lt;/h2&gt;
&lt;p&gt;咱們已經分別的看完 cdn 緩存與 http 緩存的知識以後，咱們接下來把它混在一起看它們的運行流程。&lt;/p&gt;
&lt;p&gt;這裡就只看以下兩種基本的情況，另外兩個過期圖事實上也沒有太大的差別。&lt;/p&gt;
&lt;h4 id=&#34;-1--cdn--http-&#34;&gt;情況 1 : CDN 與 HTTP 緩存都還沒過期&lt;/h4&gt;
&lt;p&gt;如下圖 8 所示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用戶端發請一個 http 請求要一張馬克圖。&lt;/li&gt;
&lt;li&gt;cdn 的馬克圖還沒過期，直接回傳。&lt;/li&gt;
&lt;li&gt;server 回應圖片，且會在表頭塞二個緩存用欄位。&lt;/li&gt;
&lt;li&gt;瀏覽器看到回應有 Cache-Control 欄位，就將此圖片存在用戶端內。&lt;/li&gt;
&lt;li&gt;用戶端第二次發送請一個 http 請求要一張馬克圖。&lt;/li&gt;
&lt;li&gt;但發現本地端已經有緩存了，就直接從本地端拿圖片。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191006/20089358VelbNWz9YM.png&#34; alt=&#34;&#34;&gt;
圖 8 : CDN 與 Http 緩存都還沒過期&lt;/p&gt;
&lt;h4 id=&#34;-2--cdn--http-&#34;&gt;情況 2 : CDN 過期而 HTTP 緩存還沒過期&lt;/h4&gt;
&lt;p&gt;如下圖 9 所示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用戶端發請一個 http 請求要一張馬克圖。&lt;/li&gt;
&lt;li&gt;cdn 的馬克圖還過期，至 server 拿取新圖。&lt;/li&gt;
&lt;li&gt;server 回傳新馬克圖。&lt;/li&gt;
&lt;li&gt;server 回應圖片，且會在表頭塞二個緩存用欄位。&lt;/li&gt;
&lt;li&gt;瀏覽器看到回應有 Cache-Control 欄位，就將此圖片存在用戶端內。&lt;/li&gt;
&lt;li&gt;用戶端第二次發送請一個 http 請求要一張馬克圖。&lt;/li&gt;
&lt;li&gt;但發現本地端已經有緩存了，就直接從本地端拿圖。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191006/20089358ZxoNCNxxb6.png&#34; alt=&#34;&#34;&gt;
圖 9 :  CDN 過期而 Http 緩存還沒過期圖&lt;/p&gt;
&lt;h3 id=&#34;--&#34;&gt;問題 - 雙方不同步&lt;/h3&gt;
&lt;p&gt;這兩個混在一起時，有個地方有注意，不然會是雷 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cdn 緩存過期時間與 http 緩存過期時間要一起考慮&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;問題會出在如下圖 10 所示，通常 server 端會決定這個圖片緩存時間要多久，而 cdn 這裡也有配置可以決定緩存時間要多久，而這時如果兩者時間不同步，那就會發生以下的情境。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用戶 : 奇怪我明明已經更新大頭圖了，為啥等了 10 幾分鐘都還沒更新呢 ?
server : 奇怪我明明設定緩存時間為 60 秒過期，客戶應該 60 秒後就會抓到新的啊……

調查以後發現…

cdn : 對不起 ~ 因為我這配置為 1000 秒後才更新緩存……
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191006/20089358vfdtgRGJG5.png&#34; alt=&#34;&#34;&gt;
圖 10 :  雙方配置問題點&lt;/p&gt;
&lt;p&gt;這裡順到說一下，每一家 cdn 廠商緩存更新配置可以都會有點不同，請參閱更家文件，在來決定配置。&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章中，咱們簡單的談談了兩個網路傳輸優化技術 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CDN&lt;/li&gt;
&lt;li&gt;HTTP 緩存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;並且要注意在使用上，兩個有可能會互相的打架，這個小雷要注意。&lt;/p&gt;
&lt;p&gt;最後如果想要看看 aws cloudFront cdn 服務的使用，可以參考我之前寫的文章，請參閱。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180923/&#34;&gt;30-23之 CDN 的說話島 ( AWS CloudFront CDN 實作 )&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kknews.cc/zh-tw/tech/gqkzny.html&#34;&gt;http緩存與cdn相關技術&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.techbridge.cc/2017/06/17/cache-introduction/&#34;&gt;循序漸進理解 HTTP Cache 機制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/55623075&#34;&gt;图解Http缓存控制之max-age=0、no-cache、no-store区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://caibaojian.com/mobile-cache.html&#34;&gt;移动web缓存介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-28之 WebRTC 連線前傳 - 為什麼 P2P 連線很麻煩 ? ( NAT )</title>
      <link>https://mark-lin.com/posts/20180928/</link>
      <pubDate>Fri, 28 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180928/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;在開始說明 WebRTC 如何建立 P2P 連線前，咱們要先理解一件事情，那就是 WebRTC 要使用非常多的 P2P 連線技術，那位啥它需要使用如此多的技術呢 ? 那就是本篇文章要探討的主題：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;為什麼 P2P 連線很麻煩呢 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因為如果你理解了這個問題，你就會知道為什麼 WebRTC 要使用怎麼多的技術來進行 P2P 連線囉，這也是為什麼我們會先說明這篇文章。&lt;/p&gt;
&lt;p&gt;本篇文章的問題，為什麼 P2P 的連線會很麻煩呢 ? 最主要的問題在於：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NAT 與防火牆的存在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此本篇文章將針對這兩個東西來理解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NAT 與防火牆是啥 ?&lt;/li&gt;
&lt;li&gt;NAT 的運作原理。&lt;/li&gt;
&lt;li&gt;為什麼有了 NAT 後 P2P 會很麻煩 ?&lt;/li&gt;
&lt;li&gt;NAT 的分類。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nat--&#34;&gt;NAT 與防火牆是啥 ?&lt;/h2&gt;
&lt;h3 id=&#34;nat&#34;&gt;NAT&lt;/h3&gt;
&lt;p&gt;NAT (Network Address Translation) 中文就做網路位置轉換，它是用來將私網 IP 轉換成公網 IP 的技術。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181112/20089358uIvytHQF4j.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-nat-&#34;&gt;為啥會有 NAT ?&lt;/h4&gt;
&lt;p&gt;先說說它的起源。&lt;/p&gt;
&lt;p&gt;在咱們世界裡有個叫 IPV4 的地址規則，由於它數量稀少，不可能讓每一台電腦都有一個地址，因此就有了以下的解法如下圖，就是每個家庭或公司只有一組地址，然後公司內的電腦就使用這位置來上網。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181112/20089358LoYXoAE97j.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中常用的私有 IP 段為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10.0.0.0 ~ 10.255.255.255&lt;/li&gt;
&lt;li&gt;172.16.0.0 ~ 172.31.255.255&lt;/li&gt;
&lt;li&gt;192.168.0.0 ~ 192.168.255.255&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這樣的確就可以解決 IPV4 位置不足的問題，那這裡問個問題。&lt;/p&gt;
&lt;h4 id=&#34;-ip--&#34;&gt;那這樣私有 IP 要如何連到外面上網呢 ?&lt;/h4&gt;
&lt;p&gt;因為假設一台外網的 Server 收到一個從 192.168.0.1 來的請求，那他在回覆時要送給誰呢 ? 說不定在那台 Server 所在的網路中也有一個 192.168.0.1，那這樣回覆就會送錯人囉。&lt;/p&gt;
&lt;p&gt;而這就是 NAT 最主要的功能，將內網的 IP 對應到外網的 IP。&lt;/p&gt;
&lt;h3 id=&#34;heading1&#34;&gt;防火牆&lt;/h3&gt;
&lt;p&gt;防火牆基本上所處的位置如下圖，它就是外網與內網的守門員，它最主要職則就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;決定誰可以通過我 (防火牆)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181112/2008935889mzadtVYm.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading2&#34;&gt;兩者差異&lt;/h3&gt;
&lt;p&gt;基本上你會發現防火牆所在的位置與 NAT 所在的位置很相似，但是記好他們兩個的職則不太一樣：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NAT：負責外網 IP 與 內網 IP 的映射。&lt;/li&gt;
&lt;li&gt;防火牆：負責維護內網的安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不過現在很多情況下 NAT 事實上會包含了一些防火牆在做的事情，所以接下來我們就專心的來研究 NAT。&lt;/p&gt;
&lt;h2 id=&#34;nat-&#34;&gt;NAT 的運作原理&lt;/h2&gt;
&lt;p&gt;接下來這章節我們來詳細的理解一下 NAT 的實際運作原理。&lt;/p&gt;
&lt;p&gt;假設：&lt;/p&gt;
&lt;p&gt;A 在馬克公司內，想連到外部網站 B&lt;/p&gt;
&lt;p&gt;A 的 IP：192.168.1.1
B 的 IP : 210.110.1.1
馬克公司 IP：310.110.1.1&lt;/p&gt;
&lt;p&gt;NAT 對映表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;內網 IP&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;外網 IP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;192.168.1.1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;310.110.1.1:9000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;192.168.1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;310.110.1.1:9001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;192.168.1.3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;310.110.1.1:9002&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;那這樣連線流程如下圖。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A (192.168.1.1) 的封包抵達 NAT。&lt;/li&gt;
&lt;li&gt;NAT 將封包內的 source ip 修改成 310.110.1.1:9000 (根據對映表)。&lt;/li&gt;
&lt;li&gt;NAT 將 A 的封包(310.110.1.1:9000) 發送到 B (210.110.1.1)。&lt;/li&gt;
&lt;li&gt;B (210.110.1.1) 的回應抵達 NAT。&lt;/li&gt;
&lt;li&gt;NAT 將 B 發的封包根據對映表，來決定此幫包該發給誰。&lt;/li&gt;
&lt;li&gt;NAT 將 B 的封包發送到 A (192.168.1.1)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181112/20089358HCusgn8TNn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;-nat--p2p--&#34;&gt;為什麼有了 NAT 後 P2P 會很麻煩 ?&lt;/h2&gt;
&lt;p&gt;為什麼有了 NAT 後 P2P 連線會很麻煩 ?&lt;/p&gt;
&lt;p&gt;最主要的原因在於：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NAT 不允許外網主機直接訪問內網&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;當然這不是完全不行，假設如果你要在內網中架台 Server 給外部使用，那的確可以特別設置讓外部的人可以連線進來。&lt;/p&gt;
&lt;p&gt;但是正常來說大部份都是無法直接連進來的，如果可以就代表你公司內部的電腦被外人看光光，但是 P2P 連線就是需要雙方都可以主動建立連線，這也是為什麼要建立 P2P 連線會很麻煩的關係。&lt;/p&gt;
&lt;p&gt;還有另一個原因在於，就算你知道了對方的 IP 與 Port 以後，你要進行連線還是一定要經過 NAT 這時如果你不在 NAT 的允許進來名單裡面，那你就一定進不來的。&lt;/p&gt;
&lt;h2 id=&#34;nat-1&#34;&gt;NAT 的分類&lt;/h2&gt;
&lt;p&gt;NAT 事實上有分很多類型，如果要學習 NAT 穿洞技術，那第一個條件就是要先了解你要穿的洞是什麼類型，這樣才能做相對應對策略，其本上分為以下四種類型&lt;/p&gt;
&lt;h3 id=&#34;full-cone-nat&#34;&gt;Full Cone NAT&lt;/h3&gt;
&lt;p&gt;當內部主機(Aip, Aport)被 NAT 映射外部(Eip, Eport)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有之後 A 出去的請求都會轉換成(Eip, Eport)&lt;/li&gt;
&lt;li&gt;所有外部主機發送(Eip, Eport)的都會轉換成(Aip, Aport)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;restricted-cone-nat&#34;&gt;Restricted Cone NAT&lt;/h3&gt;
&lt;p&gt;當內部主機(Aip, Aport)被 NAT 映射外部(Eip, Eport)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有之後 A 出去的請求都會轉換成(Eip, Eport)&lt;/li&gt;
&lt;li&gt;所有外部主機發送(Eip, Eport)的都會轉換成(Aip, Aport)&lt;/li&gt;
&lt;li&gt;但可以設定限制的外部主機，也就是只有它發進來的才可以轉為(Aip, Aport)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;port-restricted-cone-nat&#34;&gt;Port Restricted Cone NAT&lt;/h3&gt;
&lt;p&gt;當內部主機(Aip, Aport)被 NAT 映射外部(Eip, Eport)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有之後 A 出去的請求都會轉換成(Eip, Eport)&lt;/li&gt;
&lt;li&gt;所有外部主機發送(Eip, Eport)的都會轉換成(Aip, Aport)&lt;/li&gt;
&lt;li&gt;但可以設定限制的外部主機與 Port，也就是只有它(ip 與 port)發進來的才可以轉為(Aip, Aport)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;symmetric-nat---p2p--&#34;&gt;Symmetric NAT ( 無法進行 P2P 串透 )&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A 出去針對某個『特定』的位置的請求才會轉換成(Eip, Eport)，不然 NAT 都會轉成不同的 Port。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這裡的意思是指，假設內網 A 傳給封包給外網 B，那 NAT 會分配 Port 50000。而如果 A 要傳給 C 那 NAT 會分配 Port 50001。&lt;/p&gt;
&lt;p&gt;這種類型的 NAT 是無法實現 P2P 的，最主要的問題就在於它的 Port 會變。&lt;/p&gt;
&lt;h4 id=&#34;heading3&#34;&gt;備註：&lt;/h4&gt;
&lt;p&gt;在 Mobile 端如果使用 Wifi 來上網的大部份都是屬於前三種類型的，所以可以實現 P2P 穿透，而使用 3G 或 4G 的就是屬於 Symmetric NAT，所以它無法進行 P2P 穿透。(這未來會開篇文章來探討)&lt;/p&gt;
&lt;h2 id=&#34;heading4&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;本篇文章中，咱們理解了為什麼要建立 P2P 連線很麻煩的原因，最主要就是 NAT 的問題，因此我們下一文章就要來說明 WebRTC 是如何來穿透 NAT 這東東。&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.52im.net/thread-50-1-1.html&#34;&gt;P2P技术详解(一)：NAT详解——详细原理、P2P简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.nccu.edu.tw/~lien/Writing/NGN/firewall.htm&#34;&gt;穿越防火牆技術&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://linux.vbird.org/linux_server/0250simple_firewall/0320nat.php&#34;&gt;鳥哥的 Linux-NAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/30269820&#34;&gt;知乎-请问目前可否实现手机上的NAT穿透，建立P2P链接？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/84e8c78ca61d&#34;&gt;ICE协议下NAT穿越的实现（STUN&amp;amp;TURN）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-23之 CDN 的說話島 ( AWS CloudFront  CDN 實作 )</title>
      <link>https://mark-lin.com/posts/20180923/</link>
      <pubDate>Sun, 23 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180923/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;上一篇文章中，咱們有提到點播與直播可動版本的一些問題，如下所列。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;人多時連線數限制問題。&lt;/li&gt;
&lt;li&gt;人多時頻寬問題。&lt;/li&gt;
&lt;li&gt;人多時效能消耗問題。&lt;/li&gt;
&lt;li&gt;遠距離看片卡頓的問題。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下來咱們要來理解一下，解這上述問題的關鍵技術 CDN 是什麼東西 ?&lt;/p&gt;
&lt;p&gt;本編文章將分為以下幾個章節：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什麼是 CDN 呢 ? 它又是用來解決啥呢 ?&lt;/li&gt;
&lt;li&gt;CDN 的請求運作方式。&lt;/li&gt;
&lt;li&gt;使用 AWS CloudFront 來建立 CDN。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;-cdn----&#34;&gt;什麽是 CDN 呢 ? 它又是用來解決啥呢 ?&lt;/h2&gt;
&lt;p&gt;在開始理解 CDN 之前，咱們先來說說傳統上一個 client 連線到一個網站的流程。&lt;/p&gt;
&lt;p&gt;首先看看下面這張圖，這張圖說明了每當一個 client 發送一個請求到 web 網站時，web 網站會回傳
html、css 與 javascript 回來，這裡假設咱們的 web 網站還在台灣，然後回應時間大約在 100 ms 以內 (假設)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358L394w8r0oh.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然後呢 ~ 這時付你錢的老大叫你將 web 網路架設到美國，因爲免費，然後這時發現回應時間變成 1000 ms 左右。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358WIYfHP7ksn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然後開始了有以下的對話 :&lt;/p&gt;
&lt;p&gt;老大：回應時間怎麼回事 ?
碼農仔：老大你叫我架到美國啊 !?
老大：我要的不是這回答，而是問你為啥回應時間你沒修改回來 ?
老大：你是專家對吧 ?
碼農仔：(深深的吸口氣) 沒錯，我是專家 ( I am an expert ! )&lt;/p&gt;
&lt;p&gt;回到正題。&lt;/p&gt;
&lt;p&gt;CDN ( Content Delivery Network )，它存在的目的就是讓你接近取得網路資料的方法，咱們如果將上圖加入 CDN 後就會長的如下圖，所以 client 要取得的一些資源 (html、css、js) 都會去 CDN 那取得。這樣就算你的網站架在美國，但只要 CDN 是在台灣，那回應速度應該也不會有太大的差距。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358NZ2rYxVuzs.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;cdn-&#34;&gt;CDN 的請求運作原理。&lt;/h2&gt;
&lt;p&gt;首先 CDN 基本上會分為三個部份。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;智能 DNS (Intelligent DNS)：事實上是 DNS 的某個功能，它的主要功用就是可以幫用戶找到最近的 Edge CDN，這樣用戶就可以去最近的 CDN 拿資料了。&lt;/li&gt;
&lt;li&gt;邊緣 CDN ( Edge CDN )：就是散布在不同地方的 CDN 節點。&lt;/li&gt;
&lt;li&gt;來源 Server ( Origin Server )：就是原始資料存放地。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然後基本一個圖片的請求，會變的如下圖所示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Client 發送一個 HTTP 請求來取得圖片。&lt;/li&gt;
&lt;li&gt;DNS 收到後，會去請求智能 DNS。&lt;/li&gt;
&lt;li&gt;智能 DNS 會回傳給 DNS 最近 CDN 的 IP 位置。&lt;/li&gt;
&lt;li&gt;Client 收到 IP 以後，在發送請求去那個 CDN。&lt;/li&gt;
&lt;li&gt;CDN 收到請求後，會先判斷有沒有緩存此圖片，如果有就直接回傳，沒有則在去來源 Server 取得圖片，然後緩存此圖片，最後在送去給 Client。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/200893580n0UPwlTOG.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;-aws-cloudfront--cdn&#34;&gt;使用 AWS CloudFront 來建立 CDN&lt;/h2&gt;
&lt;p&gt;接下來我們來簡單的看看如何使用 AWS CloudFront 來建立一個 CDN 範例。&lt;/p&gt;
&lt;p&gt;這個範例我們會使用 AWS S3 來存放一張圖片，然後再使用 AWS CloudFront 來建立 CDN 希望能提升圖片讀取速度。&lt;/p&gt;
&lt;h3 id=&#34;-s3&#34;&gt;資料來源 S3&lt;/h3&gt;
&lt;p&gt;首先我們會在 S3 先建立一個 bucket，為了測試需要我們將 region 設定在『EU (London)』&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://s3.eu-west-2.amazonaws.com/marklin-images-test-s3/1442041544.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後我們可以直接在 chrome 上執行上面的網址，來取得一張圖片，咱們先來看看在還沒使用 CDN 時的回應時間為多少，如下圖，超久的快 7 秒鐘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/200893580dE7gsX2wM.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;-aws-cloudfront&#34;&gt;設定 AWS CloudFront&lt;/h3&gt;
&lt;p&gt;接下來咱們來設定 AWS CloudFront。&lt;/p&gt;
&lt;h4 id=&#34;-cdn-&#34;&gt;選擇 CDN 類型&lt;/h4&gt;
&lt;p&gt;首先第一個一開始 AWS CloudFront 有提供兩種類型服務的 CDN，分別為&lt;code&gt;WEB&lt;/code&gt;與&lt;code&gt;RTMP&lt;/code&gt;，此篇文章咱們先來學習 web 這裡的設定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358N3oz0A4xkF.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;--origin-settings-&#34;&gt;設定資料來源 ( Origin Settings )&lt;/h4&gt;
&lt;p&gt;Origin Domain Name：這裡就是你資料來源的 domain ，基本上有以下的來源可以選擇:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你自已的網站&lt;/li&gt;
&lt;li&gt;AWS S3&lt;/li&gt;
&lt;li&gt;AWS EC2&lt;/li&gt;
&lt;li&gt;AWS Elastic Load Balancing&lt;/li&gt;
&lt;li&gt;MediaStore 容器與節點&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Origin Path：路徑源，像如果 S3 有要指定到某個資料夾，就是在這設定。
Origin ID：此來源的唯一編號。
Restrict Bucket Access：選擇了 YES，代表你不能在用 S3 的連結路徑，而只能用 CloudFont 的連結路行。
Origin Custom Headers：如果希望將 CloudFont 將請求轉發給來源時，包含自訂表頭，那就這設定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358Ln84SMygQ2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-cache---default-cache-behavior-settings-&#34;&gt;設定 cache 行為 ( Default Cache Behavior Settings )&lt;/h4&gt;
&lt;p&gt;在來是要設定 cache 行為的地方，這裡的設定基本上都用預設就可以動，不過還是簡單說明幾個比較常用的設定。&lt;/p&gt;
&lt;p&gt;Viewer Protocol Policy：這裡是要設定要訪問 CloudFont 的策略，看是要選只能 https 連結還是 http 也行。&lt;/p&gt;
&lt;p&gt;Allowed HTTP Methods：允許訪問的 http 方法設定。&lt;/p&gt;
&lt;p&gt;Minimum TTL: 這裡是設定在 CloudFont 中保持緩存的最小時間，假設設定 5 秒，那就代表 5 秒過後就會去來源端判斷是否有無更新。(預設為 0)&lt;/p&gt;
&lt;p&gt;Maximum TTL：緩存的最大時間。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358ldQJtMMlfJ.png&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358wQAI4nBRjM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-distribution-settings&#34;&gt;分配設定 Distribution Settings&lt;/h4&gt;
&lt;p&gt;最後就是分配設定，基本上只是測試用可以都 Default 值。&lt;/p&gt;
&lt;p&gt;Price Class：預設情況下可以使用所有 CloudFront 所提供的地方，當然你可以只選擇只使用特別地方的 CloudFront 如果你的用戶大部份都集中在某個區域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358OafV2aTTUJ.png&#34; alt=&#34;&#34;&gt;
&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358pzptztsJQn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;-s3-&#34;&gt;設定完後讀取 S3 圖片的速度&lt;/h3&gt;
&lt;p&gt;設置完 CloudFont 後，你會知道它的 domain name。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358IOYiVYODfm.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然後你再將原本的圖片網址替換成 cdn 網址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://s3.eu-west-2.amazonaws.com/marklin-images-test-s3/1442041544.jpg ( 原 )

https://d3oh771a3zmb3v.cloudfront.net/1442041544.jpg ( CDN )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最後咱們使用以上兩個分別為未使用與使用 CDN 的網址來取得圖片，你會發現超快 der ~&lt;/p&gt;
&lt;h4 id=&#34;-cdn&#34;&gt;未使用 CDN&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/200893580dE7gsX2wM.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-cdn1&#34;&gt;使用 CDN&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181107/20089358zPgJF8DMQK.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;本篇文章中咱們學習到 CDN 的一些基本知識，接下來的文章，咱們將要加上 CDN 來重新的考量我們的點播與直播網路的架構。&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/29468624&#34;&gt;CDN缓存策略解读和配置策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/zh_cn/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginCustomHeaders&#34;&gt; AWS CloudFront 官網&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-18 之影音傳輸協議總整理</title>
      <link>https://mark-lin.com/posts/20180918/</link>
      <pubDate>Tue, 18 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180918/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20180912/&#34;&gt;30-12之 RTP/RTCP 傳輸協議&lt;/a&gt;
&lt;a href=&#34;https://mark-lin.com/posts/20180913/&#34;&gt;30-13之 RTSP 傳輸協議&lt;/a&gt;
&lt;a href=&#34;https://mark-lin.com/posts/20180914/&#34;&gt;30-14之 RTMP 傳輸協議&lt;/a&gt;
&lt;a href=&#34;https://mark-lin.com/posts/20180915/&#34;&gt;30-15之 HLS 傳輸協議&lt;/a&gt;
&lt;a href=&#34;https://mark-lin.com/posts/20180916/&#34;&gt;30-16之 HTTP-FLV 傳輸協議&lt;/a&gt;)
&lt;a href=&#34;https://mark-lin.com/posts/20180917/&#34;&gt;30-17之 MPEG-DASH 傳輸協議&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;前面的幾面文章，咱們學習了各種型的影音傳輸媒體，接下來將會在這一篇文章中，進行這些協議的總結。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;各種影音傳輸協議之比較與整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;heading1&#34;&gt;一張圖來簡單的理解各種協議的運作方式&lt;/h2&gt;
&lt;h3 id=&#34;rtsp&#34;&gt;RTSP&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181102/20089358ShjNiXqUHZ.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;rtmp&#34;&gt;RTMP&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181102/200893585c56Vf8TvA.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;hls&#34;&gt;HLS&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181102/20089358MFyBdyD5tf.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;httpflv&#34;&gt;HTTP-FLV&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181102/20089358egSRY1y6zS.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mpegdash&#34;&gt;MPEG-DASH&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181102/20089358Mwsa0EDev0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;特點整理&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;協議&lt;/th&gt;
&lt;th&gt;傳輸層選擇&lt;/th&gt;
&lt;th&gt;聲音編碼&lt;/th&gt;
&lt;th&gt;影像編碼&lt;/th&gt;
&lt;th&gt;延遲性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RTSP&lt;/td&gt;
&lt;td&gt;RTP、TCP、UDP&lt;/td&gt;
&lt;td&gt;RTP 可支援的都行&lt;/td&gt;
&lt;td&gt;RTP 可支援的東行&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RTMP&lt;/td&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;AAC、MP3&lt;/td&gt;
&lt;td&gt;H.26X 系列&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HLS&lt;/td&gt;
&lt;td&gt;TCP (因為它是用 HTTP )&lt;/td&gt;
&lt;td&gt;AAC、MP3&lt;/td&gt;
&lt;td&gt;H.26X 系列&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HTTP-FLV&lt;/td&gt;
&lt;td&gt;TCP (因為它是用 HTTP )&lt;/td&gt;
&lt;td&gt;AAC、MP3&lt;/td&gt;
&lt;td&gt;H.26X 系列&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEPG-DASH&lt;/td&gt;
&lt;td&gt;TCP (因為它是用 HTTP )&lt;/td&gt;
&lt;td&gt;沒啥限制，不過 AAC 用比較多&lt;/td&gt;
&lt;td&gt;H.26X、VPX 系列&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;heading3&#34;&gt;應用狀況&lt;/h2&gt;
&lt;h3 id=&#34;rtsp1&#34;&gt;RTSP&lt;/h3&gt;
&lt;p&gt;RTSP 這種協議，大部份都是應用在一些有專線的應用，例如 IPTV 這種 機上盒的應用，比較大的原因我覺得有兩個原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因為 RTSP 的特性就是控制流，也就可以快轉、停止等操作，非常適合 這種類型的應用。&lt;/li&gt;
&lt;li&gt;因為 RTSP 可以基於 UDP 進行傳輸，而在專線上因為網路穩定，所以很適合使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rtmp1&#34;&gt;RTMP&lt;/h3&gt;
&lt;p&gt;RTMP 這種協議，目前大部份都使用在網路直播應用中，主要的原因在於：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因為它的延遲低。&lt;/li&gt;
&lt;li&gt;在直播產業剛起來時，大部份的裝置都有 Flash。&lt;/li&gt;
&lt;li&gt;它支援推流。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hls1&#34;&gt;HLS&lt;/h3&gt;
&lt;p&gt;HLS 這種協議，大部份都應用在直播與點播中，其中直播的應用它是屬於比較不重視延遲 的類型，也就是非互動直播，主要的原因在於：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非互動直播的原因在於，它的延遲高，所以他只適合那種，比賽直播啊、或是一些轉播的應用。&lt;/li&gt;
&lt;li&gt;而點播，也就是由用戶決定要看啥的，不管延遲，所以他一定適合。&lt;/li&gt;
&lt;li&gt;他也很適合在行動網路上看直播與點播，因為它可以動態的調整畫質，當你網路不好，它就會用較少解析度的影片。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;httpflv1&#34;&gt;HTTP-FLV&lt;/h3&gt;
&lt;p&gt;HTTP-FLV 這種應用目前都用於直播，點播事實上也可以使用，而且這個協議也慢慢將 HLS 與 RTMP 也替代掉囉，主要有兩個原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因為它延遲低。&lt;/li&gt;
&lt;li&gt;因為它是用 Http 來傳輸，不會被一些東西擋。&lt;/li&gt;
&lt;li&gt;它也支援動態的調整畫質。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mpegdash1&#34;&gt;MPEG-DASH&lt;/h3&gt;
&lt;p&gt;DASH 基本上於 HLS 相似，基本上 HLS 可以使用的非互動直播與點播都可以選擇。&lt;/p&gt;
&lt;h2 id=&#34;heading4&#34;&gt;支援度&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;協議&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;支援度 web html5&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;支援度 ios&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;支援度 mac&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;支援度 android&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RTSP&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RTMP&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;html5 不支援，需使用套件。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HLS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;支援&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;支援&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;支援&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;支援&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HTTP-FLV&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;支援 (flv.js)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MPEG-DASH&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;支援 (dash.js)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支援，需使用套件。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;heading5&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;今天這篇文章將這幾個協議進行了簡單的總整理，但只是簡單的整理一下，不過這篇文章還會繼續的更新，包含上面提到的各平台支援度的套件支援，我會去調查清楚，又及更協議在那些實際上應用的項目( ex. Youtube 有在用 dash )這些的到時還會慢慢的補上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>30-17之 MPEG-DASH 傳輸協議</title>
      <link>https://mark-lin.com/posts/20180917/</link>
      <pubDate>Mon, 17 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180917/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181101/20089358FiJhMsd2NL.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;接下來咱們要來介紹 MPEG-DASH協議。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MPEG-DASH 協議&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章將會分成幾個章節來理解 MPEG-DASH 協議：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MPEG-DASH 協議是要用來完成什麼事情呢 ?&lt;/li&gt;
&lt;li&gt;MPEG-DASH 協議如何完成它想做的事情呢 ?&lt;/li&gt;
&lt;li&gt;建立 MPEG-DASH 的串流傳輸流程。&lt;/li&gt;
&lt;li&gt;MPEG-DASH 的特點總結。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mpegdash--&#34;&gt;MPEG-DASH 協議是要用來完成什麼事情呢 ?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;讓 client 與 server 可以透過 Http 來進行流媒體的傳輸&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;嗯事實上它想完成的事情和 HLS 事實上是相同的，那為啥他會誕生出來呢 ? 比較大的問題是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HLS 是由蘋果所主導的協議，而不是國際通用協議，這也代表蘋果怎麼改，其它人也要一起動，也就是說一切蘋果說的算。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此在 MPEG 的主導下在與一些大廠合作下 MPEG-DASH 這種國際標準的協議就誕生了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;&#34;&gt;ISO/IEC 23009-1:2012&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mpegdash--1&#34;&gt;MPEG-DASH 協議如何完成它想做的事情呢 ?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;它將聲音切成一小個一小個檔案，然後 client 就一個一個發 http 去下載。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就如同 HLS 一樣。&lt;/p&gt;
&lt;h2 id=&#34;-mpegdash-&#34;&gt;建立 MPEG-DASH 的串流傳輸流程&lt;/h2&gt;
&lt;p&gt;它的基本流程如下圖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181101/20089358PAq07DPhjL.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1--server&#34;&gt;1. 直播主將聲音或影像傳輸到 Server&lt;/h3&gt;
&lt;p&gt;這裡可以使用 RTMP 來將聲音推收到 Server，又或是如果不是直播情況可以直接將聲音檔例如 .mp4 直接丟到 Server。&lt;/p&gt;
&lt;h3 id=&#34;2-server-&#34;&gt;2. Server 將收到的聲音進行處理&lt;/h3&gt;
&lt;p&gt;這裡它基本上會將做兩件事情。&lt;/p&gt;
&lt;h4 id=&#34;-mp4--ts-&#34;&gt;將聲音切分成多個 .mp4 或 .ts 檔案&lt;/h4&gt;
&lt;p&gt;DASH 它可以支援動態調整碼率，因此它會將聲音根據不同碼率來切分，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181101/20089358FAnQeDaImv.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-mpd-&#34;&gt;產生 .mpd 檔&lt;/h4&gt;
&lt;p&gt;.mpd 檔就有點像是索引檔，裡面存放了這一段聲音的總共由那些小檔案所組成，然後 client 就是去看這個檔案來決定要抓那些影片影。它的內容如下圖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181101/20089358Ti8F4Pj2Ur.png&#34; alt=&#34;&#34;&gt;
圖片來源 : &lt;a href=&#34;https://blog.csdn.net/qq_27582179/article/details/51598208&#34;&gt;CSDN-MPEG-DASH介绍&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Period : 這個會有多個，這也代表一個場景或是一段歌曲，並用來表示這段場景的長度，而用多個就代表你可以穿插廣告或啥的。&lt;/li&gt;
&lt;li&gt;AdaptationSet : 它是用來說明這個媒體流的資訊，例如一個影像流或一個聲音流。&lt;/li&gt;
&lt;li&gt;Representation : 用來表示不同的螢幕大小或碼率。也就是說 Dash 會根據使用者現在的狀態來決定要去抓那一種影片 ( ex. 1080p or 720p )&lt;/li&gt;
&lt;li&gt;SegmentBase : 實際聲音的聲音或影像檔案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然後下面為某一段實際的 .mpd 檔，從這檔案可以知道它提供了 1080p 與 720p 的 mp4 影像。全部的檔案請拉到最下面的備註。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;MPD&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;urn:mpeg:DASH:schema:MPD:2011&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mediaPresentationDuration=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;PT0H3M1.63S&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minBufferTime=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;PT1.5S&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;profiles=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;urn:mpeg:dash:profile:isoff-on-demand:2011&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;type=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;static&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Period&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;duration=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;PT0H3M1.63S&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;start=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;PT0S&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;AdaptationSet&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;ContentComponent&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;contentType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Representation&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bandwidth=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4190760&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codecs=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;avc1.640028&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;height=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1080&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mimeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video/mp4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;width=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1920&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;BaseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;car-20120827-89.mp4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/BaseURL&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SegmentBase&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;indexRange=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;674-1149&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Initialization&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;range=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0-673&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SegmentBase&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Representation&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Representation&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bandwidth=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2073921&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codecs=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;avc1.4d401f&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;height=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;720&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mimeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video/mp4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;width=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1280&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;BaseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;car-20120827-88.mp4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/BaseURL&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SegmentBase&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;indexRange=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;708-1183&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Initialization&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;range=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0-707&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SegmentBase&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Representation&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;3--http-server--mpd-&#34;&gt;3. 聽眾向 HTTP Server 請求 .mpd 檔&lt;/h3&gt;
&lt;h3 id=&#34;4--mpd--mp4-&#34;&gt;4. 然後根據 .mpd 開始去請求一小段一小段的 .mp4 檔。&lt;/h3&gt;
&lt;h2 id=&#34;mpegdash-&#34;&gt;MPEG-DASH 特點總結&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;它的概念基本上與 HLS 差不多，因此延遲度也差不多。&lt;/li&gt;
&lt;li&gt;它有提供動態選擇碼率 ( ex. 1080p or 720p )。&lt;/li&gt;
&lt;li&gt;它可以支持任何的編碼格式 (ex. H.26X or VPX )。&lt;/li&gt;
&lt;li&gt;以 HTTP 為基礎，所以看影片暢通無比。&lt;/li&gt;
&lt;li&gt;Youtube、Facebook 是他的愛用者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前現在還是比較多 HLS 使用者，推測主要的原因是因為它先出來，而且又有大蘋果這個靠山，你想想蘋果的設備在這世界佔了多少。&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84%E5%8A%A8%E6%80%81%E8%87%AA%E9%80%82%E5%BA%94%E6%B5%81&#34;&gt;wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_27582179/article/details/51598208&#34;&gt;MPEG-DASH介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading2&#34;&gt;備註&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;MPD&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;xmlns=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;urn:mpeg:DASH:schema:MPD:2011&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mediaPresentationDuration=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;PT0H3M1.63S&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minBufferTime=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;PT1.5S&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;profiles=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;urn:mpeg:dash:profile:isoff-on-demand:2011&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;type=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;static&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Period&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;duration=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;PT0H3M1.63S&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;start=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;PT0S&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;AdaptationSet&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;ContentComponent&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;contentType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Representation&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bandwidth=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4190760&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codecs=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;avc1.640028&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;height=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1080&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mimeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video/mp4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;width=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1920&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;BaseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;car-20120827-89.mp4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/BaseURL&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SegmentBase&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;indexRange=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;674-1149&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Initialization&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;range=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0-673&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SegmentBase&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Representation&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Representation&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bandwidth=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2073921&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codecs=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;avc1.4d401f&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;height=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;720&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mimeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video/mp4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;width=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1280&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;BaseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;car-20120827-88.mp4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/BaseURL&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SegmentBase&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;indexRange=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;708-1183&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Initialization&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;range=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0-707&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SegmentBase&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Representation&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Representation&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bandwidth=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;869460&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codecs=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;avc1.4d401e&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;height=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;480&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mimeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video/mp4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;width=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;854&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;BaseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;car-20120827-87.mp4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/BaseURL&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SegmentBase&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;indexRange=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;708-1183&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Initialization&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;range=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0-707&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SegmentBase&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Representation&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Representation&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bandwidth=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;686521&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codecs=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;avc1.4d401e&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;height=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;360&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mimeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video/mp4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;width=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;640&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;BaseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;car-20120827-86.mp4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/BaseURL&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SegmentBase&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;indexRange=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;708-1183&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Initialization&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;range=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0-707&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SegmentBase&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Representation&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Representation&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bandwidth=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;264835&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codecs=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;avc1.4d4015&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;height=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;240&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;5&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mimeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video/mp4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;width=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;426&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;BaseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;car-20120827-85.mp4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/BaseURL&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SegmentBase&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;indexRange=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;672-1147&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Initialization&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;range=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0-671&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SegmentBase&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Representation&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Representation&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bandwidth=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;100000&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codecs=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;avc1.4d4015&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;height=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;144&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;5&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mimeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;video/mp4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;width=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;256&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;BaseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;car-20120827-160.mp4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/BaseURL&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SegmentBase&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;indexRange=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;671-1146&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Initialization&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;range=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0-670&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SegmentBase&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Representation&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/AdaptationSet&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;AdaptationSet&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;ContentComponent&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;contentType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;audio&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Representation&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bandwidth=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;127236&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codecs=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mp4a.40.2&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;6&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mimeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;audio/mp4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;numChannels=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sampleRate=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;44100&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;BaseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;car-20120827-8c.mp4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/BaseURL&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SegmentBase&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;indexRange=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;592-851&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Initialization&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;range=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0-591&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SegmentBase&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Representation&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Representation&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bandwidth=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;255236&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codecs=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mp4a.40.2&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;7&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mimeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;audio/mp4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;numChannels=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sampleRate=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;44100&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;BaseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;car-20120827-8d.mp4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/BaseURL&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SegmentBase&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;indexRange=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;592-851&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Initialization&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;range=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0-591&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SegmentBase&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Representation&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Representation&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bandwidth=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;31749&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;codecs=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;mp4a.40.5&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;8&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mimeType=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;audio/mp4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;numChannels=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sampleRate=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;22050&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;BaseURL&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;car-20120827-8b.mp4&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/BaseURL&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;SegmentBase&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;indexRange=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;592-851&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;Initialization&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;range=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0-591&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/SegmentBase&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Representation&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/AdaptationSet&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/Period&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;/MPD&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>30-16之 HTTP-FLV 傳輸協議</title>
      <link>https://mark-lin.com/posts/20180916/</link>
      <pubDate>Sun, 16 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180916/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181031/20089358F4oFL2rQ0I.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;接下來咱們要來介紹 HTTP-FLV 協議。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP-FLV 協議&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章將會分成幾個章節來理解 HTTP-FLV 協議：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP-FLV 協議是要用來完成什麼事情呢 ?&lt;/li&gt;
&lt;li&gt;HTTP-FLV 協議如何完成它想做的事情呢 ?&lt;/li&gt;
&lt;li&gt;建立 HTTP-FLV 的串流傳輸流程。&lt;/li&gt;
&lt;li&gt;HTTP-FLV 的特點總結。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;httpflv--&#34;&gt;HTTP-FLV 協議是要用來完成什麼事情呢 ?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;可以使用 HTTP 來完成低延遲的串流媒體傳輸。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那為啥他想使用 HTTP 呢 ?&lt;/p&gt;
&lt;p&gt;先來說說 RTMP，它不是基於 Http 來進行傳輸，所以他個缺點，那就是有一定的機率被封，而且還有另外一點，通常使用 Http 的來進行傳輸的 html5 會支援的不錯，像在 chrome 比較新的幾個版本就有開始支援 HLS，而當然 RTMP 不支援。&lt;/p&gt;
&lt;p&gt;那為啥不用 HLS 呢 ?&lt;/p&gt;
&lt;p&gt;使用 HLS 的極大缺點就是它的延遲問題，可能直播主說個話後，大約要 10 秒左右聽眾才可以聽到，而 HTTP-FLV 就是想要解決這件事情。&lt;/p&gt;
&lt;h2 id=&#34;httpflv--1&#34;&gt;HTTP-FLV 協議如何完成它想做的事情呢 ?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;將聲音與影像封裝成 FLV 流容器，然後在使用 Http 進行流式傳輸。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以直播情況來看，直播主會將聲音用任何方式 ( RTMP 或啥的 ) 傳送到 Server，然後 Server 會將它轉換成 FLV 檔，然後 Client 會使用 Http 來請求這個畫面，請求如下，然後 Server 就會用 Http 流的方式就影像一段一段的傳輸過去。&lt;/p&gt;
&lt;p&gt;這裡問個問題。&lt;/p&gt;
&lt;h4 id=&#34;http--&#34;&gt;http 流式傳輸是啥 ?&lt;/h4&gt;
&lt;p&gt;一般的 http 請求都會對應一個 http 回應這點是沒錯，http 流傳輸就是一個請求，會回應一堆小封包，然後最後才是一個 http 回應。&lt;/p&gt;
&lt;p&gt;而 http 流式傳輸需要使用&lt;code&gt;chunk&lt;/code&gt;這個東西，它的使用方法如下，就是在 http response header 加上下面的欄位，這樣 http 的回應就會變成一段一段的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Transfer-Encoding: chunked
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這裡簡單使用 nodejs 簡單寫個 http chunk 的使用，如下範例，不過下面的程式碼沒有在 http 加 header 欄位是因為 nodejs 的 http 本身如果不執行 res.end() 這一段，它就會自動的幫你加 chunked。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// test.js
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ms&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Promise(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ms&lt;/span&gt;));

&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createServer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;async&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;) =&amp;gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;writeHead&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;, { &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Content-Type&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;text/html&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;charset&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt; });
  
  &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;write&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;loading...
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;);
  &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2000&lt;/span&gt;);
  &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;write&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wait: 2000ms
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;);
  &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;5000&lt;/span&gt;);
  &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;write&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wait: 5000ms
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;);
  &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;end&lt;/span&gt;();
});

&lt;span style=&#34;color:#a6e22e&#34;&gt;app&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;listen&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3000&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下來咱們來執行它看看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node test.js
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;執果如下圖，你可以看到這個 http response 的 header 的 Transfer-Encoding 為 chunked 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181031/20089358j5o7rP3qQn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;-&#34;&gt;那實際的封包是跑什麼樣子呢 ?&lt;/h4&gt;
&lt;p&gt;簡單的畫張圖如下，它的基本概念就是會將資料分成一包一包的 tcp 傳回去，然後在判斷是最後一包時，就會回傳一個 http response 然後它裡面的 tcp 就有包含最後一段的資料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181031/200893587zxUFjkXsr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;-httpflv-&#34;&gt;建立 HTTP-FLV 的串流傳輸流程&lt;/h2&gt;
&lt;p&gt;事實上概念還蠻簡單的請看下圖，基本上直播主丟過去的聲音或影像的方法，可以選擇使用 RTMP (比較多人選)，然後聽眾就會發個 http 請求給 server，然後 server 就會開始進行 http 串流傳輸，基本上就是這樣。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181031/20089358S6O1t9H2FA.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;httpflv-&#34;&gt;HTTP-FLV 的特點總結&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTP-FLV 目前在 HTML5 支援比較好，其它平台要找找看有沒有 player 可以播放它。&lt;/li&gt;
&lt;li&gt;HTTP-FLV 延遲性優於 HLS，並且大約和 RTMP 差不多。&lt;/li&gt;
&lt;li&gt;HTTP-FLV 支援影像編碼為 H.264 (VP8 好像某)。&lt;/li&gt;
&lt;li&gt;HTTP-FLV 支援聲音編碼為 AAC、MP3。&lt;/li&gt;
&lt;li&gt;使用 .flv 流容器。&lt;/li&gt;
&lt;li&gt;使用 http 串流傳輸 (chunked)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前大部份如果要做互動類型的直播，比較會選擇 HTTP-FLV，因為它們延遲低，而 RTMP 延遲雖然也低，但是因為不是用 http 而且要用 flash 播放器，所以優先度比較低點兒。&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.apowersoft.tw/what-is-flv-format.html&#34;&gt;什麼是FLV格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gwuhaolin/blog/issues/3&#34;&gt;使用flv.js做直播&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/bfdba8ab903a&#34;&gt;直播协议 HTTP-FLV 详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-15之 HLS 傳輸協議</title>
      <link>https://mark-lin.com/posts/20180915/</link>
      <pubDate>Sat, 15 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180915/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181030/20089358myoxhabE2N.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;接下來咱們要來介紹 HLS 協議。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HLS 協議&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章將會分成幾個章節來理解 HLS 協議：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HLS 協議是要用來完成什麼事情呢 ?&lt;/li&gt;
&lt;li&gt;HLS 協議如何完成它想做的事情呢 ?&lt;/li&gt;
&lt;li&gt;建立 HLS 的串流傳輸流程。&lt;/li&gt;
&lt;li&gt;HLS 的延遲問題。&lt;/li&gt;
&lt;li&gt;HLS 的特點總結。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hls--&#34;&gt;HLS 協議是要用來完成什麼事情呢 ?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;讓 client 與 server 可以透過 Http 來進行流媒體的傳輸&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HLS ( HTTP Live Streaming ) 是由高大尚的蘋果公司所開發，再 HLS 還沒誕生之前，這世界大部份的流媒體傳輸都是被 RTMP 所佔據，最主要的原因在於當時，大部份的電腦都有裝 Flash Player。&lt;/p&gt;
&lt;p&gt;而蘋果開發出 HLS 主要有兩個原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不想被 Flash 綁死，所以它大部份的設備都慢慢的把 Flash 拔掉(當時)。&lt;/li&gt;
&lt;li&gt;RTMP 有個問題就是，它不是透過 HTTP 來進行傳輸，所以它很有可能會被一些防火墻防掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hls--1&#34;&gt;HLS 協議如何完成它想做的事情呢 ?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;它將聲音切成一小個一小個檔案，然後 client 就一個一個發 http 去下載。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上 http 本身不能說它有支援傳輸串流媒體機制，但它的確有提供一個叫做&lt;code&gt;http chunk&lt;/code&gt;的東西，可以將要傳輸的數據分成多個來傳輸。但是如果要用這個方法來傳輸串流媒體，它的確可以傳輸流容器過去，但是問題要如何進行解析，那又需要在自幹一些標準，不然接受端如何知道要播放，這也是為啥說純 http 本身不提供串流媒體的功能。&lt;/p&gt;
&lt;p&gt;因此蘋果就基於 HTTP 協議來開發出另一個應用層的協議 HLS，為了可以使用 HTTP 來進行串流媒體傳輸。&lt;/p&gt;
&lt;h2 id=&#34;-hls-&#34;&gt;建立 HLS 的串流傳輸流程。&lt;/h2&gt;
&lt;p&gt;它的基本概念如下圖，首先它會將一段聲音或影像編碼，轉換成兩種檔案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.m3u8 : 它是個索引檔，裡面記錄了這一段聲音，被分割成那些檔案存放。&lt;/li&gt;
&lt;li&gt;.ts : 它是實際上的影音檔，然後別忘了 .ts 為流容器，這也代表他可以一邊下載一邊聽。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181030/20089358RLn7unGk9r.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;然後這個為實際上 .m3u8 檔案內所放的東西，其中比較重要的 EXTINF 代表這個 .ts 共有 4 秒長度，這也代表這一段聲音總共有 4 x 6 = 24 秒的長度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#ID3-EQUIV-TDTG:2016-11-26T02:40:23
#EXT-X-MEDIA-SEQUENCE:376
#EXT-X-TWITCH-ELAPSED-SYSTEM-SECS:1511.137
#EXT-X-TWITCH-ELAPSED-SECS:1508.980
#EXT-X-TWITCH-TOTAL-SECS:1535.137
#EXTINF:4.000,
index-0000000377-6zCW.ts
#EXTINF:4.000,
index-0000000378-vHZS.ts
#EXTINF:4.000,
index-0000000379-Gkgv.ts
#EXTINF:4.000,
index-0000000380-PNoG.ts
#EXTINF:4.000,
index-0000000381-h58g.ts
#EXTINF:4.000,
index-0000000382-W88t.ts
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下來 client 如果要聽這一段聲音時，它會先用 http 發送一段請求，就如同下面的範例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://127.0.0.1/test.m3u8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後它的過程如下，Server 會回傳個 .m3u8 檔案回來，然後它的內容就是說明這聲音檔被分割成那些 .ts 檔案，然後因為 Client 是遵循 HLS 協議，因此會在去取得這些 .ts 檔案來播放。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181030/20089358e5Aj8SoHoS.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;hls-&#34;&gt;HLS 的延遲問題&lt;/h2&gt;
&lt;p&gt;HLS 如果是要用在那種點播 (就是線上點選看影片那樣) 類型的應用，那是沒有什麼太大的問題，但是如果是在互動直動這種應用，那它就有很大的問題。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因為基本它 HLS 延遲大約 10 秒左右。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是說直播主話說以後，要大約 10 秒後才會到聽眾端。&lt;/p&gt;
&lt;h4 id=&#34;-&#34;&gt;那為什麼延遲會如此的長呢 ?&lt;/h4&gt;
&lt;p&gt;咱們以下面的 .m3u8 為說明，下面的每一個 .ts 檔都為 4 秒，這也代表這一段聲音總共為 4 x 6 = 24 秒的長度，如果這是在直播的情況下，那不就代表這個直播主事實上已經說完了 24 秒的話了，對吧 ?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:5
#ID3-EQUIV-TDTG:2016-11-26T02:40:23
#EXT-X-MEDIA-SEQUENCE:376
#EXT-X-TWITCH-ELAPSED-SYSTEM-SECS:1511.137
#EXT-X-TWITCH-ELAPSED-SECS:1508.980
#EXT-X-TWITCH-TOTAL-SECS:1535.137
#EXTINF:4.000,
index-0000000377-6zCW.ts
#EXTINF:4.000,
index-0000000378-vHZS.ts
#EXTINF:4.000,
index-0000000379-Gkgv.ts
#EXTINF:4.000,
index-0000000380-PNoG.ts
#EXTINF:4.000,
index-0000000381-h58g.ts
#EXTINF:4.000,
index-0000000382-W88t.ts
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上面的例子，我們可以稱這一段聲音有 5 個片段，然後每個片段為 4 秒鐘，那我想問個問題。&lt;/p&gt;
&lt;h4 id=&#34;-1&#34;&gt;片段的數量與長度可以調整嗎 ?&lt;/h4&gt;
&lt;p&gt;當然可以 !&lt;/p&gt;
&lt;p&gt;但是問題就在於要調整的如何 ?&lt;/p&gt;
&lt;p&gt;首先來看看&lt;a href=&#34;https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008332-CH1-SW1&#34;&gt;官網推薦&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官網建議 3 個片段，每個片段為 10 秒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是如果使用這種建議，那就代表至少會延遲 30 秒，不過相對的看影片時就不會卡頓。&lt;/p&gt;
&lt;p&gt;那如果縮小呢 ? 例如每個片段為 1 秒呢 ? 這樣的確可以降低延遲，但是相對的 Server 負擔會非常的龐大，非常的不建議這樣做。基本上如果真的要做那種很在意延遲性的應用，例如直播互動，請直接放棄掉 HLS。&lt;/p&gt;
&lt;h2 id=&#34;hls-1&#34;&gt;HLS 的特點總結&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HLS 的延遲性高，如果是要做互動直播這種類型的應用，請放棄他。&lt;/li&gt;
&lt;li&gt;HLS 支援影像編碼為 H.264。&lt;/li&gt;
&lt;li&gt;HLS 支援聲音編碼為 AAC、MP3。&lt;/li&gt;
&lt;li&gt;HLS 使用 .ts 流容器。&lt;/li&gt;
&lt;li&gt;HLS 支援可以根據網路狀態，動態的調整碼率，比較白話文點就是你網路不好，他會自動讓你的畫質變差點兒，而不會讓你卡頓。&lt;/li&gt;
&lt;li&gt;HLS 以 HTTP 為基礎，所以看影片暢通無比，這裡是指如果你要連到某個 HLS Server 看迷片，比較不會因為一些防火墻或啥的問題，而不能看。&lt;/li&gt;
&lt;li&gt;它有個大靠山，大蘋果 !&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading1&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/b520c2a9b795&#34;&gt;直播-拉流和推流概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/wutong_login/article/details/50601488&#34;&gt;HLS协议深入分析——时间线介绍（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://support.upyun.com/hc/kb/article/1055195&#34;&gt;让Chrome看不了WWDC直播的HLS技术详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.eduve.org/knowledge/732&#34;&gt;在线视频之HLS协议—学习笔记：M3U8格式讲解及实际应用分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008332-CH1-SW1&#34;&gt;官網&lt;/a&gt;：&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-14之 RTMP 傳輸協議</title>
      <link>https://mark-lin.com/posts/20180914/</link>
      <pubDate>Fri, 14 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180914/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181029/20089358qubqhcvKOT.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;接下來咱們要來介紹 RTMP 協議。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RTMP 協議&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章將會分成幾個章節來理解 RTMP 協議：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RTMP 協議是要用來完成什麼事情呢 ?&lt;/li&gt;
&lt;li&gt;RTMP 協議如何完成它想做的事情呢 ?&lt;/li&gt;
&lt;li&gt;建立 RTMP 的串流傳輸流程。&lt;/li&gt;
&lt;li&gt;RTMP 的特點總結。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rtmp--&#34;&gt;RTMP 協議是要用來完成什麼事情呢 ?&lt;/h2&gt;
&lt;p&gt;它當初的動機為：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Flash 平台與伺服器進行串流媒體傳輸的協議&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RTMP( Real-Time Messaging Protocol )，為 Adode 所開發，它就是要用來讓 Server 可以與 Flash 平台進行串流傳輸。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181029/20089358P4e1TTnNwr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這裡問個問題。&lt;/p&gt;
&lt;h4 id=&#34;-rtsp--&#34;&gt;為什麼不要用 RTSP 來進行傳輸呢 ?&lt;/h4&gt;
&lt;p&gt;這裡我覺得有兩個原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因為 RTSP 大部份還是基於 RTP over UDP 上，由於當時 RTSP 大部份都用在 IPTV 或 VOD 上這些都是有專門一條線給它用，所以網路很穩定。但是 RTMP 當初是希望開發在互聯網上，所以不能保證網路很穩定，因此它選擇用 TCP 來傳輸。2. 因為想建立一個更符合 Flash 用途的協議。我猜的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更多有支援的請參考&lt;a href=&#34;http://wwwimages.adobe.com/www.adobe.com/content/dam/acom/en/devnet/rtmp/pdf/rtmp_specification_1.0.pdf&#34;&gt;RTMP Spec&lt;/a&gt;在 31、32 頁。&lt;/p&gt;
&lt;h2 id=&#34;rtmp--1&#34;&gt;RTMP 協議如何完成它想做的事情呢 ?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;事實上就是一樣定義一些連線標準&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不過這裡有個比較特殊的東西要說明一下，那就是 RTMP 傳輸的結構，如下圖，假設你有一段聲音要進行傳遞，它會將它封裝成&lt;code&gt;message&lt;/code&gt;，然後再實際要傳輸時，會將它分成更小的&lt;code&gt;chunk&lt;/code&gt;。對了注意一下 message 不是只有聲音與影像這樣類型，還有一些控制或調整的類型，但這裡就不細說明了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181029/20089358dYZ9bFSILu.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;分割成較小的 chunk 有個好處，這樣更能有助於調解傳輸的效率，例如假設因為某些原因導致影像的傳輸低於聲音，這時就可以自動增加影像的 chunk 傳輸量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181029/20089358dQ6DyKPKWL.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;這裡咱們問個問題。&lt;/p&gt;
&lt;h4 id=&#34;-chunk--&#34;&gt;那一個 Chunk 是多大呢 ?&lt;/h4&gt;
&lt;p&gt;基本上預設為&lt;code&gt;128 byte&lt;/code&gt;，當然這個大小可以進行調整。&lt;/p&gt;
&lt;h4 id=&#34;-chunk--1&#34;&gt;那 Chunk 大一點好還是小一點好 ?&lt;/h4&gt;
&lt;p&gt;都有優缺點。&lt;/p&gt;
&lt;p&gt;大一點的 chunk 可以節省傳輸的內容，並且減少 cpu 的計算時間(因為要計算每個 chunk 的關係)，但缺點就在於越大就越不容易進行調整傳輸效率，就會有比較高的機率發生影像卡彈。&lt;/p&gt;
&lt;p&gt;而相對的小一點的 chunk 則比較不會發生影像卡彈，但缺點在於它要傳的資訊會比較多，因為每個 chunk 都會有 header 附加額外資訊。&lt;/p&gt;
&lt;p&gt;所以這可能要根據你所在的網路環境來進行 chunk 的大小調整。&lt;/p&gt;
&lt;h2 id=&#34;-rtmp-&#34;&gt;建立 RTMP 的串流傳輸流程。&lt;/h2&gt;
&lt;p&gt;要建立 RTMP 來進行串流媒體的傳輸基本上有以下幾個步驟。接下來我們來理一下每一個步驟在做啥。&lt;/p&gt;
&lt;p&gt;備註：&lt;/p&gt;
&lt;p&gt;下面的封包資訊是使用 wireshake 與 ffmpeg 打 rtmp 所產的，有興趣的友人可以試試。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffmpeg rtmp://184.72.239.149/vod/mp4:bigbuckbunny_1500.mp4
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;-handshake&#34;&gt;握手 (Handshake）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;這階段事實上只是確認兩件事情 1. RTMP 版本 2. 網路是否正常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;流程如下圖。172 為我的電腦，而 184 則為 RTMP Server 位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client 發送 C0 + C1 Chunks 給 Server。&lt;/li&gt;
&lt;li&gt;Server 回傳 S0 + S1 + S2 Chunks 給 Client。&lt;/li&gt;
&lt;li&gt;Client 發送 C2 給 Client。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這裡 RMTP Spec 裡面這些 Chunk 裡面只要求帶版本號而以，其它裡面帶的都是由實作端自已決定，它沒有強制要求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181029/20089358y8d4DCgzhD.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading1&#34;&gt;建立網路連接&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;設定一些這個連接的參數&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在使用 Handshake 確認可以建立連接以後，接下來就是設定一些參數，例如 Chunk 大小、頻寬大小等，如下圖 289 ~ 318。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181029/20089358TpgnYYpe37.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading2&#34;&gt;然後就是開始傳輸資料囉。&lt;/h3&gt;
&lt;p&gt;如同下圖的 323 開始，然後你會看到每個封包裡面都多包含多個 chunk，像 323 的最左邊那寫的 audio data 與 video data 這樣。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181029/20089358TpgnYYpe37.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;rtmp-&#34;&gt;RTMP 的特點總結&lt;/h2&gt;
&lt;p&gt;它有以下特點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基於 TCP 的雙向傳輸。&lt;/li&gt;
&lt;li&gt;RTMP 串流目前只能由 Flash 播放器來播出 ( 這也代表開始不支援 Flash 的東東都無法執行 ex. 蘋果的東東，還有一些瀏覽器 ex. chrome)&lt;/li&gt;
&lt;li&gt;默認 Port 為 1935。&lt;/li&gt;
&lt;li&gt;它可以使用 AMF 與 FLV 流容器。&lt;/li&gt;
&lt;li&gt;它可以支援聲音編碼主要的為 AAC、MP3。&lt;/li&gt;
&lt;li&gt;而支援的影像編碼為 H.264。 (它好像沒支援 VPX 系列的呢)&lt;/li&gt;
&lt;li&gt;它支援推流與拉流，也就是所謂的你可以推聲音到 Server，你也可以去 Server 將聲音拉回來。 (之後會詳細說明)&lt;/li&gt;
&lt;li&gt;目前大部份的 PC 都有 Flash，但手機端就 QQ 了。&lt;/li&gt;
&lt;li&gt;它的延遲時間大約 3 ~ 5 秒或更低，如果處理的好的話，這裡的延遲的意思就是主播說話後，你大約 3 ~ 5 秒才能聽到。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading3&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Real-Time_Messaging_Protocol&#34;&gt;wiki-rtmp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/5ce11c20a9df&#34;&gt;RTMP协议解析（一） —— 基本了解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/9459606c2025&#34;&gt;RTMP协议 03 RTMP设计思想&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/shangmingyang/article/details/50837852&#34;&gt;带你吃透RTMP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/mm792261167/article/details/69499590?utm_source=blogxgwz1&#34;&gt;流媒体-RTMP交互过程及协议解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-13之 RTSP 傳輸協議</title>
      <link>https://mark-lin.com/posts/20180913/</link>
      <pubDate>Thu, 13 Sep 2018 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20180913/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181028/20089358yRyPKEWLRg.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;本篇文章咱們將要開始介紹第一個應用層的流通訊協議 RTSP，別忘了上一篇介紹的 RTP 是傳輸層。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RTSP 協議&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章將會分成幾個章節來理解 RTSP 協議：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RTSP 協議是要用來完成什麼事情呢 ?&lt;/li&gt;
&lt;li&gt;RTSP 協議如何完成它想做的事情呢 ?&lt;/li&gt;
&lt;li&gt;建立 RTSP 的串流傳輸流程。&lt;/li&gt;
&lt;li&gt;RTSP 的特點。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rtsp--&#34;&gt;RTSP 協議是要用來完成什麼事情呢 ?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;它是被設計出來為，為了控制串流媒體 Sever 的協議 (ex. 快轉、暫停影片之類)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RTSP 它被設計出來是為了可以控制串流媒體伺服器的協議 (所以他是 C/S 架構)，例如我們先發送一個觀看影片的請求給 Server，然後它就開始以串流型式來傳輸影片，然後這時我們可以用 RTSP 所提供的一些方法，來進行影片的快轉或暫停，為了能控制串流就是它被設計出來的原理。&lt;/p&gt;
&lt;p&gt;就如同下圖所示，RTSP 讓我們可以操控串流媒體。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181028/20089358BxhJvtZP0F.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;rtsp--1&#34;&gt;RTSP 協議如何完成它想做的事情呢 ?&lt;/h2&gt;
&lt;p&gt;那它要如何控制呢串流呢 ?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它定義了控制的方法與參數&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就如同 HTTP 一樣，它定義了一些方法可以給我們控制，例如 Play 這個動作，當串流 Server 看到這個動詞後，就會開始傳輸影片給請求者。&lt;/p&gt;
&lt;h2 id=&#34;-rtsp-&#34;&gt;建立 RTSP 的串流傳輸流程&lt;/h2&gt;
&lt;p&gt;我們直接去使用網路上所提供的 RTSP 進行請求看看。這個連結你可以使用 ffplay 來開啟 (ffplay 之後會提)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rtsp://184.72.239.149/vod/mp4:BigBuckBunny_115k.mov
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下來我們下面說明，如果 client 端發送一條 rtsp 請求後，實際上的封包產生流程會長的什麼樣子 ?&lt;/p&gt;
&lt;h4 id=&#34;1--client--rtsp--options--client-server--rtsp-&#34;&gt;1. 首先第一步 client 會發送 rtsp 的 options 方法給 client，然後 server 會回傳他可以支援什麼 RTSP 的方法。&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;C -&amp;gt; S
CSeq: 1
Request: OPTIONS rtsp://184.72.239.149:554/vod/mp4:BigBuckBunny_115k.mov RTSP/1.0

S -&amp;gt; C
CSeq: 1
Response: RTSP/1.0 200 OK
Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, OPTIONS, ANNOUNCE, RECORD, GET_PARAMETER
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;2--describe-&#34;&gt;2. 接下來會發送 DESCRIBE 請求來進行類似登入的動作，用來確保你可不可以建立線或加入這個會話。&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;C -&amp;gt; S
Request: DESCRIBE rtsp://184.72.239.149:554/vod/mp4:BigBuckBunny_115k.mov RTSP/1.0
Accept: application/sdp
CSeq: 2

S -&amp;gt; C
Response: RTSP/1.0 200 OK
CSeq: 2
Server: Wowza Streaming Engine 4.7.5.01 build21752
Cache-Control: no-cache
Expires: Sat, 25 Aug 2018 14:16:23 UTC
Content-length: 589
Content-Base: rtsp://184.72.239.149:554/vod/mp4:BigBuckBunny_115k.mov
Date: Sat, 25 Aug 2018 14:16:23 UTC
Content-type: application/sdp
Session: 1305852487;timeout=60

包在 RTSP 封包的 SDP
Session Description Protocol Version (v): 0
Owner/Creator, Session Id (o): - 1305852487 1305852487 IN IP4 184.72.239.149
Session Name (s): BigBuckBunny_115k.mov
Session Attribute (a): range:npt=0- 596.48
Time Description, active time (t): 0 0
Media Description, name and address (m): audio 0 RTP/AVP 96
Media Attribute (a): rtpmap:97 H264/90000
Media Attribute (a): fmtp:96 profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3;config=1490
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;3--server--rtp-over-udp--rtp-3012-rtprtcp-httpsithelpithomecomtwarticles10205715&#34;&gt;3. 接下來和 server 詢問要用什麼傳輸協議來進行這個資源的傳輸，如下範例它是會使用 RTP over UDP 來進行傳輸，不熟悉 RTP 的可以至筆者的『&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10205715&#34;&gt;30-12之 RTP/RTCP 傳輸協議&lt;/a&gt;』來學習學習。&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;C -&amp;gt; S
Request: SETUP rtsp://184.72.239.149:554/vod/mp4:BigBuckBunny_115k.mov/trackID=1 RTSP/1.0
Transport: RTP/AVP/UDP;unicast;client_port=22610-22611
CSeq: 3
Session: 1305852487

S -&amp;gt; C
Response: RTSP/1.0 200 OK
Transport: RTP/AVP/UDP;unicast;client_port=22610-22611;source=184.72.239.149;server_port=8880-8881;ssrc=372D3B76
Session: 1305852487;timeout=60
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;4---&#34;&gt;4 .  最後就開始進行影像傳輸囉。&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;C -&amp;gt;
Request: PLAY rtsp://184.72.239.149:554/vod/mp4:BigBuckBunny_115k.mov/ RTSP/1.0\r\n
Range: npt=0.000-
CSeq: 5
Session: 1305852487

S -&amp;gt; C
Response: RTSP/1.0 200 OK
RTP-Info: url=rtsp://184.72.239.149:554/vod/mp4:BigBuckBunny_115k.mov/trackID=1;seq=1;rtptime=0,url=rtsp://184.72.239.149:554/vod/mp4:BigBuckBunny_115k.mov/trackID=2;seq=1;rtptime=0
CSeq: 5
Range: npt=0.0-596.48
Session: 1305852487;timeout=60
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;rtsp-&#34;&gt;RTSP 的特點總結&lt;/h2&gt;
&lt;p&gt;最後來說明一下 RTSP 的幾個特點。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RTSP 是屬於雙向協議，你可以將它想成 client 與 server 雙方都可以發出請求。&lt;/li&gt;
&lt;li&gt;RTSP 只處理串流的控制，但用什麼傳輸不算他管，基本上他是使用 RTP base UDP 或 UDP 來進行傳輸。&lt;/li&gt;
&lt;li&gt;目前多用於 VOD ( Video On Demand ) 與視訊會議。&lt;/li&gt;
&lt;li&gt;比較悲哀的事，目前不多東西支援它。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最後這裡問個問題。&lt;/p&gt;
&lt;h4 id=&#34;rtsp--audio--video--&#34;&gt;RTSP 支援什麼 audio 或 video 的編碼呢 ?&lt;/h4&gt;
&lt;p&gt;這個問題事實上有點兒不算問題。&lt;/p&gt;
&lt;p&gt;基本上不是看它可不可以支持，而是看傳輸層的協議可不以支持，像如果使用 RTP 那基本上大部份都可以，因為 RTP 會將這些編碼自動轉成 RTP 容器，然後接受端在收到 RTP 時就可以根據他的表頭來知道它是什麼編碼，然後在解碼播歌。&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ietf.org/rfc/rfc2326.txt&#34;&gt;RTC2326&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://meson.tian.yam.com/posts/106583744&#34;&gt;Streaming 通訊協定 RTP RTCP RTSP RTMP HLS 介紹&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/tq08g2z/article/details/77773129&#34;&gt;Wireshark 抓包分析 RTSP/RTP/RTCP 基本工作过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.itread01.com/articles/1476115529.html&#34;&gt;流媒體傳輸協議系列之&amp;ndash;RTSP協議詳解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>