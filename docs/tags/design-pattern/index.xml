<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>design pattern on 拿鐵派的馬克 Blog</title>
    <link>https://mark-lin.com/tags/design-pattern/</link>
    <description>Recent content in design pattern on 拿鐵派的馬克 Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <managingEditor>h091237557@gmail.com (marklin)</managingEditor>
    <webMaster>h091237557@gmail.com (marklin)</webMaster>
    <lastBuildDate>Sun, 11 Jun 2017 19:51:35 +0800</lastBuildDate>
    
	<atom:link href="https://mark-lin.com/tags/design-pattern/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Node設計模式之命令模式 ( Command )</title>
      <link>https://mark-lin.com/posts/20170611/</link>
      <pubDate>Sun, 11 Jun 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170611/</guid>
      <description>本文中我們將會知道兩件事件
為什麼要使用命令模式呢 ? 什麼是命令模式呢? 為什麼要使用命令模式呢 ? 我們先來想想，假設我們要做一個簡單的計算機的功能，然後他有提供以下方法:
 加 減 乘 除  然後實際上執行大概會長這樣 :
add(5) =&amp;gt; current = 5 sub(3) =&amp;gt; current = 2 mul(3) =&amp;gt; current = 6 div(3) =&amp;gt; current = 2 這樣我們大概會寫個最簡單的程式碼，大概會長成下面這樣:
class Calculator { constructor(){ this.current = 0; } add(value){ this.current += value; } sub(value){ this.current -= value; } mul(value){ this.current *= value; } div(value){ this.current /= value; } getCurrent(){ return this.current; } } const client = new Calculator(); client.</description>
    </item>
    
    <item>
      <title>Node設計模式之策略模式 ( Stratgey )</title>
      <link>https://mark-lin.com/posts/20170610/</link>
      <pubDate>Sat, 10 Jun 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170610/</guid>
      <description>本篇文章中，我們想要知道以下兩件事情 :
  為什麼要使用它呢 ? 什麼是策略模式呢 ?   為什麼要使用策略模式呢 ? 我們簡單的寫一下，一個多需要用不同方法的登入方法，它可以選擇使用google、facebook的方法，來進行登入。
var user = { login: function (type) { if (type == &amp;#34;google&amp;#34;) { doGoogleLoginSomething(); console.log(&amp;#34;google login process&amp;#34;); } else if (type == &amp;#34;facebook&amp;#34;) { doFbLoginSomething(); console.log(&amp;#34;facebook login process&amp;#34;); } else { doSomething(); console.log(&amp;#34;custom login process&amp;#34;); } } } user.login(&amp;#34;google&amp;#34;); 那上面這段程式碼中，有那些缺點呢 ?
首先第一個，它包含了很多的 if else 判斷，這樣反而增加了該函數的邏輯分支。
第二個為該函數缺泛彈性，如果你想增加twitter的登入，那就必須修改這函數的內部實作，這樣違反了開放封閉原則
 開放封閉原則 : 白話文就是當你增加新功能時，盡量不修改原有的程式碼。
好處 : 較好維護、較好測試、可重複使用
 所以說，當碰到這種情況時，就可以使用策略模式囉 ~
策略模式簡單的來說，就是為了處理以下的情況 :</description>
    </item>
    
    <item>
      <title>Node 設計模式之代理器 ( Proxy )</title>
      <link>https://mark-lin.com/posts/20170603/</link>
      <pubDate>Sat, 03 Jun 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170603/</guid>
      <description>本篇文章中我們將要解決以下的問答。
  什麼是代理器模式 ? 我們為什麼要使用它 ?   其中本篇文章還會介紹ES6所提供的Proxy使用方法。
什麼是代理器模式呢 ? 首先我們先來看一張下面這張圖，這張圖基本就說明了代理器模式的概念，無論如何，client和Real Object之間一定會由Proxy來進行溝通。
我們還可以用下面這句非常白話文的文字來表達代理器模式的精華。
 我的時間很忙的，除非真的要用到我，不然請直接找我的代理人。
 我們簡單來寫個範例來說明一下，代理器的實際上使用，首先我們先寫一個登入的程式。
Class UserService{ construct () { } GetUser(name,password){ ...... return user; } } 然後通常我們要使用的時後會執行下面程式碼。
const userService = new UserService(); const user = userService.GetUser(&amp;#34;mark&amp;#34;,&amp;#34;123456789&amp;#34;); 這樣看起來是沒什麼問題，東西是都還可以執行，然後我們來改寫成代理器的模式，我們會先建立一個UserServiceProxy，我們外面要使用UserService時，都只能透過這個Proxy進行溝通 (想找明星，只能想找他的代理人)。
 注意 : 這只是其中一種寫法，代理器還有很多的方法可實現。
 Class UserServiceProxy { construct(real){ this.Real = real; } GetUser(name,passowrd){ const real = new Real(); real.getUser(name,password); } } const userServiceProxy = new UserServiceProxy(UserService); const user = userServiceProxy.</description>
    </item>
    
  </channel>
</rss>