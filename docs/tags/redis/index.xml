<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>redis on 拿鐵派的馬克 Blog</title>
    <link>https://mark-lin.com/tags/redis/</link>
    <description>Recent content in redis on 拿鐵派的馬克 Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <managingEditor>h091237557@gmail.com (marklin)</managingEditor>
    <webMaster>h091237557@gmail.com (marklin)</webMaster>
    <lastBuildDate>Fri, 20 Sep 2019 20:16:57 +0800</lastBuildDate>
    
        <atom:link href="https://mark-lin.com/tags/redis/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>30-20 之資料緩存失效問題</title>
      <link>https://mark-lin.com/posts/20190920/</link>
      <pubDate>Fri, 20 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190920/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191005/20089358IRjIjOjHB9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;上一篇文章中咱們已經學習了一些緩存基本的策略，那接下來我們要來理解一下一個重要的主題 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果緩存失效的情況，與可能會發生什麼事情呢 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上緩存失效後的結果，會很慘，尤其是你當初建立緩存時，就是已經為了讀取接近性能臨異值而建立的情況，當緩存一失效，你的資料庫也會瞬間爆掉，然後用戶就不愈悅，你就完了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191005/20089358iSAyY62hsU.png&#34; alt=&#34;&#34;&gt;
圖 1 : 緩存失效圖&lt;/p&gt;
&lt;p&gt;而在實務上，緩存失效大至可以分為以下幾類，也就是咱們接下來每個章節 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;緩存失效情況 - 緩存穿透&lt;/li&gt;
&lt;li&gt;緩存失效情況 - 緩存雪崩&lt;/li&gt;
&lt;li&gt;緩存失效情況 - 緩存服務炸了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;--&#34;&gt;緩存失效情況 - 緩存穿透&lt;/h2&gt;
&lt;p&gt;這個的主要情境如下 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查詢一個不存在的資料，由於沒命中緩存，因此會一直往 DB 穿，如下圖 2 所示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191005/20089358HcNMiF23QA.png&#34; alt=&#34;&#34;&gt;
圖 2 : 緩存穿透&lt;/p&gt;
&lt;p&gt;通常這種情況有可能是前端出了錯，導致一直送不存在的資料，又或是人為刻意，就是要有人想打爆你整個系統。&lt;/p&gt;
&lt;h3 id=&#34;-1--&#34;&gt;解法 1 : 硬處理&lt;/h3&gt;
&lt;p&gt;這種方法就是，當用戶使用 a key 去 redis 找發現沒有 cache，然後再去 db 抓，也發現沒有，然後就將『 這個 a key 是空值 』也寫入到緩存中 ( 可以給它設個到期時間 )，如下程式碼範例。&lt;/p&gt;
&lt;p&gt;這樣後面有人在使用這個 key 去打，會在 cache 這被防下來，然後將算後來真的有寫入 a key 時，咱們緩存寫入流程也是會將它處理 ( 詳見前篇文章 )。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 概念碼
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;userId&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;A&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;isExistInCache&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;userId&lt;/span&gt;)){
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getCache&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;userId&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;user&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getUser&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;userId&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cacheValue&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;user&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;( &lt;span style=&#34;color:#a6e22e&#34;&gt;user&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; ){
  &lt;span style=&#34;color:#a6e22e&#34;&gt;cacheValue&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getDefaultEmptyValue&lt;/span&gt;();
}

&lt;span style=&#34;color:#a6e22e&#34;&gt;setCache&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;userId&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;cacheValue&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;不過這種方案還是有缺點&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它無法防護隨機編號的攻擊，因為每一次都是不同的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;-2----bloom-filter-&#34;&gt;解法 2 : 布隆過濾器 ( Bloom Filter )&lt;/h3&gt;
&lt;p&gt;它的基本解法概念為 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;建立一個很大的 hash 來『 存放值 』，當如果是『 不存在的值 』則會再檢查時被過濾掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;問個問題 ~ 這裡用 hash 感覺就可以處理了，為啥要用啥布隆過濾器概念不是很像嗎 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;咱們寫來說說 hash 的處理方案。&lt;/p&gt;
&lt;p&gt;首先 hash 就是一個 key 與 value 的對應，然後 key 會通過 hash 函數來進行轉換，如下圖 3 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191005/20089358k9asK77cRH.png&#34; alt=&#34;&#34;&gt;
圖 3 : hash&lt;/p&gt;
&lt;p&gt;這裡順到說一下，上圖 3 的 jack 與 jiro 這兩個 key 通過 hash 有可能會指到相同的 value 4，那這樣如何處理呢 ?&lt;/p&gt;
&lt;p&gt;比較常見有兩種方案 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拉鍊法 : 就是 value 裡面實際上是存 linklist，但是這種要很注意 hash function 的設計，因為一不小心就會變成一個很長的 linklist。&lt;/li&gt;
&lt;li&gt;尋址法 : 就是第一個 key 放到某個位置後，如果第二個 key 還是到這個位置，它發現有人了，那它就會再找下一個位置，有可能是往前或往後走。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在補充一下 hash 的新增與抓取操作時間複雜都是 o(1)，然後 linklist 新增是 o(1)，但是抓取就是 o(n)，而如果變成太長的 linklist，你要抓值時，就代表要一個一個看看，也就是 o(n) 的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那 hash 又與布隆過濾器有啥差別 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;兩則概念很相似，但問題出在 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 key 非常多的情況下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;hash 有可能會爆，因為你可以想成它是每一個 key，就會花個空間來儲，而布隆過濾器就是可以解決這一點。&lt;/p&gt;
&lt;p&gt;簡單來說它可以花少少的空間來判斷，一個 key 是否存在，但然後它的缺點就在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有誤判率&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以這個演算法不適合用在 100% 確定的場景，而是只能用在大約有 70 ~ 80 % 左右的準確度就夠了，例如緩存穿透、垃圾郵件過濾、爬蟲 url 去除重複。&lt;/p&gt;
&lt;p&gt;詳細的布隆過濾器原理，這裡就不說了，有興趣的友人請自行查查。&lt;/p&gt;
&lt;h4 id=&#34;heading1&#34;&gt;實現&lt;/h4&gt;
&lt;p&gt;好然後拉回來，如果要用布隆過濾器來處理緩存穿透時，咱們大概會用以下程式碼來實現 :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Mark&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;// 這裡會先判斷 target 有沒有存在，透布隆過濾器表來判斷
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;isExistBoolFilter&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt;)){
   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;isExistInCache&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt;)){
  &lt;span style=&#34;color:#a6e22e&#34;&gt;rturn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt;];
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然後我覺得比較重要的點在於，&lt;strong&gt;你的 boolFilter 要如何維護呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前想到比較簡單的處理是，當 target 被新增的時後，則更新一次記憶體中的 boolFilter，而如果是移除了，則不理它，反正 cache 那會防。&lt;/p&gt;
&lt;p&gt;別忘了這裡是為了達到 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;儘可能的過濾資料，別讓緩存服務爆了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以你要確保，即使 boolFilter 誤判了，那業務運行還是不會出錯。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;對了，那這個 boolFilter 要存那呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比較建議是存在緩存服務外的另一個 redis 上。&lt;/p&gt;
&lt;p&gt;在單機時存記憶體上還沒啥毛病，就算機器重開了，那也項多是去 db 重拉一份資料然後再存入記憶體，但多機時你還要考慮每台機器 boolFilter 更新的問題。&lt;/p&gt;
&lt;h2 id=&#34;--1&#34;&gt;緩存失效情況 - 緩存雪崩&lt;/h2&gt;
&lt;p&gt;這個的主要情境如下 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;當緩存在同一個時間內大量失效時(因為到期或啥的)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191005/200893583QKDEJmJ3g.png&#34; alt=&#34;&#34;&gt;
圖 4 : 緩存雪崩&lt;/p&gt;
&lt;p&gt;這種情況基本上分為以下兩個情境 :&lt;/p&gt;
&lt;h3 id=&#34;-1--1&#34;&gt;雪崩情況 1 : 緩存的到期時間到期，而自動清除緩存&lt;/h3&gt;
&lt;p&gt;首先說說第一個，上一章節有提到，通常會建議，在寫入緩存時，會給它設置一個到期時間，免得上面殘留太多的那些忘記寫清除程式，或因系統故障導致沒有清除的不需要的緩存。下面為 redis 設定 key 的到期時間小範例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis&amp;gt; SET mykey &amp;quot;Hello&amp;quot;
&amp;quot;OK&amp;quot;
redis&amp;gt; EXPIRE mykey 10
(integer) 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而這時如果有大量的 key，它們到期時間設置相同，那失效的那個瞬間就會產生所謂的緩存雪崩。&lt;/p&gt;
&lt;h4 id=&#34;heading2&#34;&gt;解法&lt;/h4&gt;
&lt;p&gt;這種方案的解法通常為，給它設置一個隨機變數 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EXPIRE mykey 10 + random
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;-2--&#34;&gt;雪崩情況 2 : 瞬間大量的寫入&lt;/h3&gt;
&lt;p&gt;而至於第二種情況，瞬間的大量寫入，上一章節咱們要有說在緩存最少是使用『 淘汰 』，而不是用『 更新 』，但是如果這時有瞬間的大量寫入，那就是產生大量的『 淘汰 』，那這時也會產生所謂的緩存雪崩。&lt;/p&gt;
&lt;h4 id=&#34;heading3&#34;&gt;解法&lt;/h4&gt;
&lt;p&gt;這一題目前想了一下，事實上發生機率很低，因為會建立緩存的資料前提假設之一就是更新頻率低，而在這個情況下還是會發生這種情況的另一種可能就在於『 有人在批次大量修改資料 』。&lt;/p&gt;
&lt;p&gt;如果是在這種批次的情況下，那就建議直接用『 批次更新 』緩存，而不要在正規使用『 淘汰 』，先說一下系統內的運行一樣是『 淘汰 』，只是當發現有需要大量修改資料時，請手動的『 更新 』緩存。&lt;/p&gt;
&lt;p&gt;如果都不是上面說的這種情況，而還是發生了，那就可能需要使用『 隊列服務 』來讓這些寫操作排隊，不要一口氣灌到緩存服務，但當然，這會對架構與性能可能都會有不少影響，所不定也會出現一堆坑。&lt;/p&gt;
&lt;h2 id=&#34;--2&#34;&gt;緩存失效情況 - 緩存服務炸了&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;就是緩存服務炸掉了，導致直接灌到資料庫層去，如下圖 5 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191005/20089358zGZGXNrEnk.png&#34; alt=&#34;&#34;&gt;
圖 5 : 緩存服務炸了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小備註 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;這裡應該會有人覺得很奇怪，假設咱們程式碼如下所示，那基本緩存服務掛了，資料庫那層應該是不會處理啊，因為錯誤囉。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Mark&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;isExistInCache&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt;)){
  &lt;span style=&#34;color:#a6e22e&#34;&gt;rturn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cache&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt;];
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;對是沒錯。&lt;/p&gt;
&lt;p&gt;但這時你要想想，這樣是對的嗎 ?&lt;/p&gt;
&lt;p&gt;緩存是為了什麼 ? 是為了加快查詢的速度與保護資料庫層。那你想想，你覺得緩存服務掛了，要讓整個『 系統業務 』都死嗎，如果你有個記錄 log 的服務掛了，也要整個系統都死嗎 ?&lt;/p&gt;
&lt;p&gt;不不 ~ 這樣不太對 ~ 別忘了我們追求的是『 好的系統 』，是要讓客戶愉悅的，如果一個業務系統要綁十個服務，然後每個服務都要完成，業務才算完成，那你想想你的業務完成機率是多少呢 ? 順到說一下，如果一個服務裡需要綁那麼多服務，請考慮開拆。&lt;/p&gt;
&lt;p&gt;緩存掛了對用戶來說，有時也感覺不到，log 服務掛了對用戶來說更感覺不到，所以通常咱們會在這 isExistInCache 這方法裡面加個 try cache 然後繼續去 db 查詢。&lt;/p&gt;
&lt;p&gt;這樣才能保證緩存服務就算故障了，也不影響『 系統業務 』。&lt;/p&gt;
&lt;h3 id=&#34;--masterslave-&#34;&gt;解法 - Master-Slave 模式&lt;/h3&gt;
&lt;p&gt;這個架構基本算是最基本的 redis 高可用架構，它主要的目的在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;當 master 掛了，一台 slave 馬上來補 ( 就是升為 master )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以當緩存服務有建立這架構後，就可以解決緩存服務炸了導致大量請求直接灌入到 db 的問題，因為有後補者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191005/200893589pWhqnB78a.png&#34; alt=&#34;&#34;&gt;
圖 6 : master-slave 架構&lt;/p&gt;
&lt;p&gt;這裡簡單說明一下這個架構，這個架構基本上是有三個服務 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master : 主要接客用的 redis。&lt;/li&gt;
&lt;li&gt;slave : 後補球員。&lt;/li&gt;
&lt;li&gt;sentinel : master 監控者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;圖 6 中，這裡有兩個小重點，首先第一個 master slave 會一直運行資料同步 ( a 的部份 )，這樣才能保證 slave 轉換到 master 時，有相同的資料，而第二點為 sentinel 它會不斷的監控這 master ( b 的部份 )，當它發現 master 掛了，就會將某個 slave 上架上來。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小備註&lt;/strong&gt;
傳統它這個架構，它會有三個 sentinel, 主要的原因有兩個 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;防止 sentinel 單點掛掉。&lt;/li&gt;
&lt;li&gt;sentinel 仲裁會。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 sentinel 仲裁會比較特別一點，這個東西就是用來決定 master 要不要下掉的機制。一台 master 要下掉需要由多個 sentinel 來投票，如果 n 個 sentinel 同意 master 掛掉，則進行 failover ( 就是 slave 補上 )。&lt;/p&gt;
&lt;h2 id=&#34;heading4&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章中，咱們介紹了幾種緩存失效的類型 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;緩存穿透&lt;/li&gt;
&lt;li&gt;緩存雪崩&lt;/li&gt;
&lt;li&gt;緩存服務炸了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上緩存穿透我目前還比較少碰到，雖然當初再開發時有想到這問題，但後來想想發生機率不高，就有點懶的解…… ( 這不算好事情，請別學 )。然後我也是在查資料時才知道有布隆過濾器這個解法。&lt;/p&gt;
&lt;p&gt;而至於緩存雪崩這問題，這就還真的碰到不少次，最後也是給每個 key 的到期時間，給它加個大秒 10 秒以內的隨機亂數，才比較安全一點。但如果真的沒辦法給你就要考慮 key 的退場方案新機制，例如用 queue 來處理之類的。&lt;/p&gt;
&lt;p&gt;最後緩存服務炸了這件事情麻，還真沒啥發生過，因為咱家 redis 基本型就是 master-slave 炸了可以馬上的換過來。&lt;/p&gt;
&lt;p&gt;但是最近咱們在談討一個問題 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 redis 有被應用層 connection pool 連線住，那 failover 機制可以正常運行嗎 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前我們發現好像不會正常運行，會卡住，但根本原因還要再研究一下，之後有空在發篇文來談談。&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/39114188&#34;&gt;如果缓存失效，瞬间大量请求可能会直接访问数据库，请问如何在代码层面应该怎么处理？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/37645456&#34;&gt;常见的缓存穿透，缓存击穿，缓存雪崩解决方案分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://redis.io/commands/expire&#34;&gt;REDIS-EXPIRE key seconds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dotblogs.com.tw/supershowwei/2016/02/03/123740&#34;&gt;軟體主廚的程式料理廚房&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000002680804&#34;&gt;Redis Sentinel机制与用法（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://imhuchao.com/1271.html&#34;&gt;布隆过滤器(bloom filter)介绍以及php和redis实现布隆过滤器实现方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-19 之資料庫層的優化  - 資料緩存策略</title>
      <link>https://mark-lin.com/posts/20190919/</link>
      <pubDate>Thu, 19 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190919/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/20089358Z0dcXbWruv.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;上一篇咱們基本上已經理解緩存服務 redis 的基本概念後，接下來咱們要進入正題 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;緩存策略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信不少人應該會覺得這很簡單，不就是將熱資料丟到緩存，然後用戶先優先去緩存取得，沒有則去資料庫拿去嗎 ?&lt;/p&gt;
&lt;p&gt;用腦袋想很簡單沒錯，但是難處就在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你要如何確保資料一致性呢 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有沒有覺得這名詞很耳熟呢 ? 你只要記好，只要是多個服務，只要是共用資料的，那就一定會碰到它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什麼樣類型資料適合緩存呢 ?&lt;/li&gt;
&lt;li&gt;緩存讀流程&lt;/li&gt;
&lt;li&gt;緩存寫策略與難題&lt;/li&gt;
&lt;li&gt;緩存寫策略的難題總結&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;-&#34;&gt;什麼樣類型資料適合緩存呢 ?&lt;/h2&gt;
&lt;p&gt;在建立緩存時，我們需要先來決定一件重要的事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什麼樣的資料需要存放到緩存中呢 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上適合緩存資料的特點有以下幾點 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這個資料是常常被使用到的。&lt;/li&gt;
&lt;li&gt;這個資料是不常被更新的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;且中如果符合上述兩個情況的那就可以算在『 適合建立緩存的資料 』選項中。&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;緩存讀流程&lt;/h2&gt;
&lt;p&gt;讀的基本流程如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 用戶往應用服務發送請求。&lt;/li&gt;
&lt;li&gt;(2) 應用服務至緩存服務看看是否有緩存。&lt;/li&gt;
&lt;li&gt;(3A) 有，則回傳。&lt;/li&gt;
&lt;li&gt;(3B) 無，則前往資料庫服務取得資料。&lt;/li&gt;
&lt;li&gt;(4) 並將資料回寫入緩存服務。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本上這種讀的流程比較沒有太大問題與爭論。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/200893584LY6F9hzAc.png&#34; alt=&#34;&#34;&gt;
圖 1 : 緩存讀取流程&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;緩存寫策略與難題&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;緩存策略最大坑在這&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比較大的問題在於『 寫 』這裡，因為不同的寫入方式會產生不同的問題，而且這沒有 100% 的完美解，只能有較優但還是有缺點的解。接下來我們來一個一個慢慢看。&lt;/p&gt;
&lt;p&gt;先說一下，最大的問題在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在併發情況下，會產生 db 與 緩存 ( redis ) 不一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上會有以下四種變型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先寫 db 後改緩存&lt;/li&gt;
&lt;li&gt;先寫 db 後淘汰援存&lt;/li&gt;
&lt;li&gt;先改緩存 後寫 db&lt;/li&gt;
&lt;li&gt;先淘汰緩存，後寫 db&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;---db-&#34;&gt;第一種 : 先寫 DB 後改緩存&lt;/h3&gt;
&lt;p&gt;首先咱們先來看第一種方式『 先寫 db 後改緩存 』。&lt;/p&gt;
&lt;p&gt;流程如下圖 2 所示 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 用戶請求修改資料。&lt;/li&gt;
&lt;li&gt;(2) 先修改 db 資料。&lt;/li&gt;
&lt;li&gt;(3) 再修改緩存資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/20089358rWJhth7O2V.png&#34; alt=&#34;&#34;&gt;
圖 2 : 先寫 db 後改緩存模式&lt;/p&gt;
&lt;p&gt;這種情境會有什麼問題呢 ?&lt;/p&gt;
&lt;p&gt;基本會有兩個問題。&lt;/p&gt;
&lt;h4 id=&#34;-1--&#34;&gt;問題 1 : 會有一次讀取到舊的緩存資料&lt;/h4&gt;
&lt;p&gt;首先第一個問題為會有一次讀取到舊的緩存資料如下圖 3 所示，雖然有些人會覺得這沒什麼，但是你想想如果是搶票情況呢 ? 假設有個用戶已經確定買到票，且已經更新完 db 後，這時另一個用戶，在緩存更新『 前 』讀取，發現還有一張票，但實際上已經沒票了。這時你覺得用戶會如何呢 ?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/20089358peOnuAPVUL.png&#34; alt=&#34;&#34;&gt;
圖 3 : 先寫 db 後改緩存的問題 1&lt;/p&gt;
&lt;h4 id=&#34;-2---db-&#34;&gt;問題 2 : 併行修改時會有緩存 DB 資料不一致問題&lt;/h4&gt;
&lt;p&gt;這一種情況是發生同時有兩個用戶要進行修改的情況，如下圖 4 所示，用戶 a 先要求修改數量，接下來用戶 b 要再將數量修改，但是問題就出在緩存這裡，變成用戶 b 先修改緩存，用戶 a 後來才修改緩存。&lt;/p&gt;
&lt;p&gt;這是真的有可能會發生的場境，你不能保證所有操作都是照你想的順序進行。&lt;/p&gt;
&lt;p&gt;這會造成什麼後果呢 ? 那就是後來進來的請求，全部都會在緩存這讀取到『 錯誤 』的數量，而這個錯誤只能人工發現修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/20089358iwToAD7fYd.png&#34; alt=&#34;&#34;&gt;
圖 4 : 先寫 db 後改緩存的問題 2&lt;/p&gt;
&lt;h3 id=&#34;---db---cache-aside-pattern-&#34;&gt;第二種 : 先寫 DB 後淘汰緩存 ( Cache Aside Pattern )&lt;/h3&gt;
&lt;p&gt;接下來咱們先來看第二種方式『 先寫 db 後淘汰緩存 』。這裡和第一種的差別就在於，從『 修改 』轉『 淘汰 』，這裡淘汰的意思就是刪除緩存，然後當讀取 miss 後再去重新建立緩存。&lt;/p&gt;
&lt;p&gt;順到說一下，這種類型又被稱為『 Cache Aside Pattern 』，它也是 facebook 所使用的緩存策略。&lt;/p&gt;
&lt;p&gt;流程如下圖 5 所示 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 用戶請求修改資料。&lt;/li&gt;
&lt;li&gt;(2) 先修改 db 資料。&lt;/li&gt;
&lt;li&gt;(3) 再淘汰緩存 ( 也就是直接將緩存移除 )。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/20089358dIzBpdt6Zb.png&#34; alt=&#34;&#34;&gt;
圖 5 : 先寫 db 後淘汰緩存&lt;/p&gt;
&lt;p&gt;這種情境會有什麼問題呢 ?&lt;/p&gt;
&lt;p&gt;基本會有一個問題。&lt;/p&gt;
&lt;h4 id=&#34;-1--1&#34;&gt;問題 1 : 緩存操作失敗會導致資料不一致性問題&lt;/h4&gt;
&lt;p&gt;這種情況會發生當緩存刪除操作失敗時，之後所有的讀取都會讀到錯誤的資訊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/20089358vfv0MkVux8.png&#34; alt=&#34;&#34;&gt;
圖 6 : 先寫 db 後淘汰緩存問題 1&lt;/p&gt;
&lt;p&gt;這個問題仔細思考一下，發生機率事實上應該不高，首先如果緩存刪除那一步失敗，那再重試，而如果一直不行那事實上也有可能緩存服務整個掛掉，那這樣用戶 b 應用也不會讀到錯誤的緩存。&lt;/p&gt;
&lt;p&gt;而這裡還有另一種解法，那就是當發現緩存失敗了，就回滾 db 操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小備註 ~&lt;/strong&gt;
如果是 db 操作失敗，那也就只是回覆用戶說這個操作失敗，而不是會回錯誤的數量給用戶。&lt;/p&gt;
&lt;h3 id=&#34;---db&#34;&gt;第三種 : 先改緩存後寫 DB&lt;/h3&gt;
&lt;p&gt;流程如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 用戶請求修改資料。&lt;/li&gt;
&lt;li&gt;(2) 先修改緩存資料。&lt;/li&gt;
&lt;li&gt;(3) 再修改 db 資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/20089358QWx5RSq4Qd.png&#34; alt=&#34;&#34;&gt;
圖 7 : 先改緩存後寫 db&lt;/p&gt;
&lt;p&gt;這種情境會有什麼問題呢 ?&lt;/p&gt;
&lt;p&gt;基本上會有兩個問題 :&lt;/p&gt;
&lt;h4 id=&#34;-1---db-&#34;&gt;問題 1 : 修改 DB 失敗會有資料不一致問題&lt;/h4&gt;
&lt;p&gt;這種情況會發生在，當修戶緩存成功，但修改 db 失敗時，緩存會是錯誤資料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/20089358U8v2nd63lU.png&#34; alt=&#34;&#34;&gt;
圖 8 : 先改緩存後寫 db 問題 1&lt;/p&gt;
&lt;h4 id=&#34;-2--&#34;&gt;問題 2 : 並行寫入問題會有資料不一致問題&lt;/h4&gt;
&lt;p&gt;這種情況會發生在，當用戶 a 請求修改，而用戶 b 在請求修改，但這時如果用戶 b 的都先完成，用戶 a 的後完成，就會發生 db 與緩存會是不一致的。而這情境上面事實上也有發生過，注意只要是『 修改緩存 』的情境，這都會發生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/20089358fAvbtozxvC.png&#34; alt=&#34;&#34;&gt;
圖 9 : 先改緩存後寫 db 問題 2&lt;/p&gt;
&lt;h3 id=&#34;---db1&#34;&gt;第四種 : 先淘汰緩存後寫 DB&lt;/h3&gt;
&lt;p&gt;流程如下圖 10 所示 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) 用戶請求修改資料。&lt;/li&gt;
&lt;li&gt;(2) 先淘汰緩存資料。&lt;/li&gt;
&lt;li&gt;(3) 再修改 db 資料。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/20089358hLyDyzpaIB.png&#34; alt=&#34;&#34;&gt;
圖 10 : 先淘汰緩存，後寫 db&lt;/p&gt;
&lt;p&gt;這種情境會有什麼問題呢 ?&lt;/p&gt;
&lt;p&gt;基本會有個問題。&lt;/p&gt;
&lt;h4 id=&#34;-1--2&#34;&gt;問題 1 : 併行讀時可能會有資料不一致問題&lt;/h4&gt;
&lt;p&gt;這個情況如下圖 11 所示，如果在刪除緩存到修改 db 這一段時間，有人進來讀取，發現是空的緩存，然後去 db 抓資料來塞緩存，而這個動作又快於用戶 a 修改 db，那就會發生緩存與 db 資料不一致的問題。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191004/20089358IMtDyLbiUN.png&#34; alt=&#34;&#34;&gt;
圖 11 : 先淘汰緩存後寫 db 問題 1&lt;/p&gt;
&lt;h2 id=&#34;heading3&#34;&gt;緩存寫策略的難題總結&lt;/h2&gt;
&lt;p&gt;那要選那個方案好呢 ?&lt;/p&gt;
&lt;h4 id=&#34;--db-&#34;&gt;第一種: 先寫 DB 後改緩存&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;問題 1 : 會有一次讀取到舊的緩存資料。&lt;/li&gt;
&lt;li&gt;問題 2 : 並行修改時會有緩存 db 資料不一致問題。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;--db---cache-aside-pattern-&#34;&gt;第二種: 先寫 DB 後淘汰援存 ( Cache Aside Pattern )&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;問題 1 : 緩存操作失敗會導致資料不一致性問題。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;---db2&#34;&gt;第三種: 先改緩存 後寫 DB&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;問題 1 : 修改 db 失敗會有資料不一致問題。&lt;/li&gt;
&lt;li&gt;問題 2 : 並行寫入問題會有資料不一致問題。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;--db&#34;&gt;第四種: 先淘汰緩存，後寫 DB&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;問題 1 : 併行讀時可能會有資料不一致問題&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading4&#34;&gt;小總結&lt;/h4&gt;
&lt;p&gt;事實上咱們可以注意到一件事情，每一種都會有問題，這個基本上是無法避免的事情，所以咱們只能儘可能的選擇比較不差的。&lt;/p&gt;
&lt;p&gt;首先第一種與第三種這兩個類型，可以先刪除了，這兩個問題比較多些而。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;改緩存的選項可移除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下來第二種與第四種來選。基本上如果是我來選的話，應該會選擇『 第二種 』方法當緩存策略。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;建議走第二種 : 先寫 DB 後淘汰援存 ( Cache Aside Pattern )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要的原因在於這種感覺比較想的到解法，當你發現後淘汰緩存失敗後，你可以手動的讓 db rollback，雖然在 rollback 這一段時間，可能緩存還是錯誤的，但至少會回復。&lt;/p&gt;
&lt;p&gt;而第四種雖然這種發生的機率可能性比較小，但是這種很難像上面情況我們可以處理，除非我們將它完全變成序列化執行，也就是所謂的一個一個處理，但是相對的，性能完全是大打折，這做法幾乎就是 mysql 開 serializable 級別一樣。&lt;/p&gt;
&lt;p&gt;不過這個答案不是絕對，只是個人看法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小備註 ~&lt;/strong&gt;
架構師之路這一系列文章中，有專門在討探緩存這一塊，其中作者是支持『 第四種: 先淘汰緩存，後寫 db』，有興趣的友人可以去看看裡面留言的一堆論戰。不過好像連結看不到留言，要用微信……&lt;/p&gt;
&lt;p&gt;但於它贊成的原因在於，就是因為第二種會碰到上述問題，不過感覺它裡面沒有說的很清楚，第四種他的解法是如何處理……，不過這不影響這個作者寫的『 架構師之路 』這一系列文章的價值，他真的寫的很好。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/YBpOz1dQ0sG15vGL7N0PeQ&#34;&gt;缓存，究竟是淘汰，还是修改？&lt;/a&gt;
&lt;a href=&#34;https://mp.weixin.qq.com/s/7IgtwzGC0i7Qh9iTk99Bww&#34;&gt;Cache Aside Pattern&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章中咱們大概理了一下，基本上緩存策略，其中讀的流程比較不會有問題，問題出在『 寫 』的過程，而最後咱們大概離出只有這兩種選擇 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第二種: 先寫 db 後淘汰援存 ( Cache Aside Pattern )&lt;/li&gt;
&lt;li&gt;第四種: 先淘汰緩存，後寫 db&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中這裡是比較建議用第二種，不過也是有人支持第四種，詳細可以參考上面說的那幾篇文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;建議走第二種 : 先寫 DB 後淘汰援存 ( Cache Aside Pattern )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最後說一下，從上面可以知道，事實上這四種方法都還是會有一些不一致情況產生，而且都是在『 寫 』這一塊會發生問題，所以這裡也可以總結一下幾個 cache 使用時機 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;緩存適合用在大量讀取，且更新頻率較少的資料&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果在常更新的資料上進行快取，那和找死沒差多少。&lt;/p&gt;
&lt;p&gt;最後這裡提一下。&lt;/p&gt;
&lt;p&gt;現階段我們都是假設資料庫是單機的情況，如果多機的情況，答案或需有可能不同。之後會談到。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你想想資料庫讀寫分離方案，緩存策略這裡還是一樣嗎 ?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;heading6&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/CY4jntpM7VNkBrz1FKRsOw&#34;&gt;缓存架构设计细节二三事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/ALSDqOslGXx2Qz7e5YKtFg&#34;&gt;细聊冗余表数据一致性（架构师之路）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/z364m8iWgk2tSag_q7VUiQ&#34;&gt;缓存与数据库一致性保证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/58536781&#34;&gt;Redis缓存和MySQL数据一致性方案详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://coolshell.cn/articles/17416.html&#34;&gt;缓存更新的套路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend&#34;&gt;Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf&#34;&gt;Scaling Memcache at Facebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/59167071&#34;&gt;Redis与Mysql双写一致性方案解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.kido.site/2018/12/01/db-and-cache-01/&#34;&gt;缓存与数据库一致性系列-01&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>30-18 之資料緩存層的服務 - Redis 概念與一致性難題</title>
      <link>https://mark-lin.com/posts/20190918/</link>
      <pubDate>Wed, 18 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190918/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191003/20089358TlDk3NkQlM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正文開始&lt;/h2&gt;
&lt;p&gt;前面幾篇文章咱們已經學習完了資料層性能相關的知識，而接下來這篇文章，咱們要來學習，如何進一步的讓系統可以做更多的事情。&lt;/p&gt;
&lt;p&gt;資料庫單機性能優化到最後，仍然還是逃不過性能的貧頸，但這並不是說單機優化沒有意義，因為單機如果沒有將它優化好，而直接開機器來增加性能，那只能說是拿錢堆起來的性能，而且可能會出問題。&lt;/p&gt;
&lt;p&gt;那要如何在增加性能呢 ? 這時通常會使用以下的策略 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;緩存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是說架構會變的如上圖 1 所示，在 mysql 前面會多增加一個緩存服務，這個服務我們通常會選擇用 redis。當資料在緩存服務有時直接回傳，沒有則去資料庫服務取得。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191003/200893588PWrlNAPlc.png&#34; alt=&#34;&#34;&gt;
圖 1 : 加入緩存服務圖&lt;/p&gt;
&lt;p&gt;在開始緩存策略前，咱們要先來研究一下基本的緩存服務『 redis 』。&lt;/p&gt;
&lt;p&gt;本篇文章分為以下幾個章節 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis 的架構&lt;/li&gt;
&lt;li&gt;Redis 的一致性難題處理&lt;/li&gt;
&lt;li&gt;Redis 性能使用的要點&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-&#34;&gt;Redis 的架構&lt;/h2&gt;
&lt;p&gt;首先咱們簡單的介紹一下 redis 是啥 ?&lt;/p&gt;
&lt;p&gt;簡單的說它算是一種資料庫，redis 是將所有的資料存在『 記憶體 』中，而 mysql 則是將主要資料存在『 硬碟中 』。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它適合當緩存服務的重點就在於儲『 記憶體 』。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而它適合當緩存服務的重點就在於這裡，它將資料儲放在記憶體，因此操作速度非常的快，咱們來簡單複習一下儲硬碟和記憶體取資料的差異，如下圖 2 所示，mysql 讀取資料，基本上要運行 3 次的拷貝，而 redis 則只需要 1 次 ( 每條線就是一次拷貝 )。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191003/20089358tYqyutDJMu.png&#34; alt=&#34;&#34;&gt;
圖 2 : redis vs mysql 讀取資料比較&lt;/p&gt;
&lt;p&gt;接下來看一下 redis 的架構，如下圖，基本上它是屬於單線程非阻塞 i/o 架構，也就是咱們之前文章所說的類型，詳細非阻塞 i/o 說明，請到那篇文章看看。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10219203&#34;&gt;30-07 之應用層的 I/O 優化 - 非阻塞 I/O 模型 Reactor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191003/20089358sCUxM8FYIx.png&#34; alt=&#34;&#34;&gt;
圖 3 : redis 的架構&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;問個問題 ~ 為什麼 redis 要選單線程的架構呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;會選這種架構的主要原因在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redis 不多 cpu 運算，而是比較多 i/o (網路) 處理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有用過 redis 的友人應該都知道，咱們使用 redis 時後，大部份就是指定某個 key 然後來抓取資料。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis&amp;gt; GET {key}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它幾乎不會像 mysql 那樣會有一些很複雜的運算啥的操作，它就只是單純的指定 key 然後拿取，因此這種情況下，它如果選擇用多線線來處理多 i/o 情境下反而會有以下的缺點 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上下文切換頻繁。&lt;/li&gt;
&lt;li&gt;多線程你還要不一致性資料問題。( 請看看之前 mysql 的一致性難題那幾篇，搞到快出人命 )&lt;/li&gt;
&lt;li&gt;可能會面臨線程過多爆炸問題。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此因為這些些原因，redis 才選擇這種單線程非阻塞 i/o 架構。&lt;/p&gt;
&lt;h2 id=&#34;redis-1&#34;&gt;Redis 的一致性難題處理&lt;/h2&gt;
&lt;p&gt;redis 有沒有前幾篇 mysql 的一致性難題呢 ?&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10222851&#34;&gt;30-15 之資料庫層的難題 - 單機『 故障 』一致性難題&lt;/a&gt;
&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10223427&#34;&gt;30-16 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 1 )&lt;/a&gt;
&lt;a href=&#34;&#34;&gt;30-17 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 2 )&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;嚴格來說少了非常的多。&lt;/p&gt;
&lt;p&gt;先說一下『 並行 』的難題。這個在 redis 中是沒這煩腦的。&lt;/p&gt;
&lt;p&gt;主要的原因在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redis 它是 single process 且 single thread 架構，所有它沒有並行的問題&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這事實上也代表這 redis 的事務有 acid 中的 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;隔離性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;acid 中的隔離性所代表的意思為，多個事務『 並行 』執行時，不會相互的影響到對方，而當 redis 的結構為單進程時，就代表所有的事務只能『 串行 』處理，所以它當然有這個特性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191003/20089358u2dA1eQr8M.png&#34; alt=&#34;&#34;&gt;
圖 3 : redis 的事務執行圖&lt;/p&gt;
&lt;p&gt;那另一個&lt;strong&gt;固障不一致性難題&lt;/strong&gt;呢 ?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這個問題事實上還是有的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先 redis 中也有提供『 事務 』這一種概念，然後接下來咱們來看看固障各種情境。&lt;/p&gt;
&lt;h3 id=&#34;-1--&#34;&gt;固障不一致性問題 1 : 某項操作故障&lt;/h3&gt;
&lt;p&gt;這種情況如下圖 4 所示，也就是第二個操作失敗了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/20089358bzdYTcWXVB.png&#34; alt=&#34;&#34;&gt;
圖 4 : 某項操作故障導致不一致&lt;/p&gt;
&lt;p&gt;在 mysql 的文章中，咱們有提到它的解決方法為 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事務 + undo log&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以當 mysql 第二個操作出了問題，它可以使用 undo log 來回復資料庫。&lt;/p&gt;
&lt;p&gt;而在 redis 中它也有提供事務，它的使用方式如下 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MULTI
SET A-Account &amp;quot;0&amp;quot;
SET B-Account &amp;quot;1000&amp;quot;
SET C-Account &amp;quot;1000&amp;quot;
EXEC
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面指令，它在 redis 實際上的運行流程如下。事實上就只是將操作寫入到 redis 的隊列中，然後 exec 時在一個一個執行，這樣也代表同一個時間，只會此事務的所有操作，中間不會有其它事務的操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MULTI ( 開始事務 )
SET A-Account &amp;quot;0&amp;quot; ( 加入隊列 )
SET B-Account &amp;quot;1000&amp;quot; ( 加入隊列 )
SET C-Account &amp;quot;1000&amp;quot; ( 加入隊列 )
EXEC ( 執行隊列操作 )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但這裡咱們就要來想想一件事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;redis 執行 exec 後，在執行第二個 set 指定失敗會怎麼樣呢 ?&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它會執行第三個&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;對 redis 的事務沒有所謂的『 要麻全完成 』或『 要麻全失敗 』這個概念。&lt;/p&gt;
&lt;p&gt;它的事務只是用來保證同一個時間內只會執行該事務的操作，而不會被其它事務所影響。&lt;/p&gt;
&lt;p&gt;所以這也代表 redis 的事務它事實上沒有所謂的原子性，因為它沒有保證事務內全部完成，或全部不完成。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redis 事務沒有所謂的『 原子性 』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這裡簡單在提一下，但如果是在發送隊列時出錯，那就整個事務不會處理，所以這裡就有『 全部不完成 』這點，但整體而言，它還是沒辦法包證全部都有『 全部完成 』與『 全部不完成 』這個原子特性。&lt;/p&gt;
&lt;h3 id=&#34;-2--&#34;&gt;固障不一致性原因 2 : 單機故障&lt;/h3&gt;
&lt;p&gt;這個問題在 mysql 的問題是如下圖 5 所示，在事務提交以後，寫到緩衝區後，如果機器炸了，那資料會移失的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190930/20089358v7bUvpv87o.png&#34; alt=&#34;&#34;&gt;
圖 5 : mysql 單機故障導致一致性問題。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那 redis 由於都是存在應用層的記憶體中，那這樣 redis 服務重開不是就炸了 ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嗯對，基本觀念沒有錯，任何的應用程式，如果重開了，那記憶體裡的資料是會不見沒錯，所以 redis 它有提供兩個持久化機制，如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB&lt;/li&gt;
&lt;li&gt;AOF&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rdb---&#34;&gt;RDB ( 預設使用 )&lt;/h4&gt;
&lt;p&gt;簡單的說它是一個『 自動 』或『 手動 』的將記憶體資料，保存到硬碟的 dump.rdb 去。當 redis 重開時，它會將硬碟 dump.rdb 資料拷貝到記憶體中。&lt;/p&gt;
&lt;p&gt;RDB 的預設自動條件如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;900 秒內有 1 個改動。&lt;/li&gt;
&lt;li&gt;300 秒內有 10 個改動。&lt;/li&gt;
&lt;li&gt;60 秒內有 10000 個改動。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只是上述一個條件有中，就會將記憶體中的資料寫到硬碟去。會有這種預設主要是因為拷貝到硬碟對 redis 是很吃資源的事情，所以不太可能每一秒就拷貝到硬碟一次，所以這也帶出了它的缺點 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RDB 如果要復原，那不太可能是前幾秒的事情，最低也只能回復到 1 分鐘前 ( 如果有觸發條件的話 )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;aof---&#34;&gt;AOF ( 預設關閉 )&lt;/h4&gt;
&lt;p&gt;簡單的說，它會將『 寫 』的操作，記錄到日誌中 ( 有點像 mysql undo )，當 redis 重啟時，就使用這個日誌來回復。&lt;/p&gt;
&lt;p&gt;這個機制預設基本上『 每秒 』寫入到日誌上，而所謂的日誌就是指寫到硬碟，某些方面你可以想成它是用性能來換取，回復資料一致性較高的策略。&lt;/p&gt;
&lt;h4 id=&#34;-redis--rdb--aof--&#34;&gt;所以 redis 它算是有使用 RDB 或 AOF 解決這個問題嗎 ?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;不 ! 沒有 !&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因為你即使 redis 事務提交了，但根據 rdb 與 aof 上面的說明，你仍然還是會有一小段的資料會消失。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rdb 可能會遺失 1 分鐘的提交資料&lt;/li&gt;
&lt;li&gt;aof 可能會遺失 1 秒鐘的提交資料 ( 但耗性能 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以它仍然會發生上圖 5 的問題。&lt;/p&gt;
&lt;p&gt;所以以 acid 特性來看 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;redis 它沒有持久性，因為它沒辦法保證事務『 提交 』後，資料有保存下來&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;acid-&#34;&gt;ACID 小總結&lt;/h4&gt;
&lt;p&gt;從這章節的幾個段落可以得知，redis 雖然有『 事務 』，但這個事務事實上沒有符合『 ACID 』特性。&lt;/p&gt;
&lt;p&gt;因為它只有符合 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔離性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而以下兩個則沒有符合 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性&lt;/li&gt;
&lt;li&gt;持久性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而前一篇文章也說到事務 acid 的特性公式為 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一致性 C  = 隔離性 I + 原子性 A + 持久性 D&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以這也代表 redis 的事務也沒有符合 acid 的『 一致性 』&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;~ 小備註 ~&lt;/strong&gt;
這裡或需有人會說，redis 的有些操作有原子性，嗯沒錯，但我這裡說的是『 事務 』沒有符合原子性。&lt;/p&gt;
&lt;h2 id=&#34;redis-2&#34;&gt;Redis 高性能使用的建議&lt;/h2&gt;
&lt;h3 id=&#34;-1-&#34;&gt;建議 1. 熟知每種操作的時間複雜度&lt;/h3&gt;
&lt;p&gt;redis 有提供以下幾種資料結構來進行儲放，而咱們要用的好的要點之一，就是你要知道每一種操作的時間複雜度，然後更進階點就是要理解，為什麼會是這個時間複雜度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;list&lt;/li&gt;
&lt;li&gt;hash&lt;/li&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;li&gt;sorted set&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這裡建議看下列這篇文章，它已經整理的很詳細了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://redisdoc.com/&#34;&gt;Redis 命令参考&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;-2--pipepine&#34;&gt;建議 2. 懂的使用 Pipepine&lt;/h3&gt;
&lt;p&gt;假設你有一個操作如下，這裡以 php 為範例如下，它要執行 set 100 次 :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;$client = new Predis\Client();

for ($i = 0; $i &amp;lt; &lt;span style=&#34;color:#f92672&#34;&gt;100&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;client-&lt;/span&gt;&amp;gt;set(&amp;#34;key:$i&amp;#34;, &amp;#39;test&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那這種情況建議改成使用 pipeline，因為這樣它就只會發『 一條 』指令給 redis，而這時網路的 latency 與傳輸資料就會減少非常多，如下圖 6 所示。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;$responses = $client-&amp;gt;pipeline(function ($pipe) {
    for ($i = 0; $i &amp;lt; &lt;span style=&#34;color:#f92672&#34;&gt;100&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pipe-&lt;/span&gt;&amp;gt;set(&amp;#34;key:$i&amp;#34;, &amp;#39;test&amp;#39;);
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20191003/20089358QA9TuRQFNl.png&#34; alt=&#34;&#34;&gt;
圖 6 : 大量操作情況下，正常操作與 pipeline 比較圖。&lt;/p&gt;
&lt;h3 id=&#34;-3--keys--scan&#34;&gt;建議 3. 不要使用 Keys 改用 Scan&lt;/h3&gt;
&lt;p&gt;redis 有提供一個指令為 keys，它可以幫你找出你要的 pattern 的 key，如下範例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEYS { pattern }

Ex.

KEYS /users/*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是這個指令非常的危險，因為假設資料量很大，然後你一執行這個指令可能要 1 分鐘，那這時就代表這 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;這一分鐘內你的 redis 沒有辦法處理任何請求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事實上這就是單線程架構缺點，當你進行 cpu 操作時間太長，那就會卡住所有的操作。&lt;/p&gt;
&lt;p&gt;所以當如果要進行類型這種操作請使用 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;請使用 scan，不要用 keys&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因為 scan 是跑一下，讓出來一下，在跑一下，雖然整體查詢時間會拉長，但是至少不會卡住所有操作。&lt;/p&gt;
&lt;h3 id=&#34;-4--key-&#34;&gt;建議 4. 儘可能的都將 Key 設到期時間&lt;/h3&gt;
&lt;p&gt;會這樣建議的原因主因在於 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;儘可能讓 key 的數量保持在一定數量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;當數量大時，可能會發生以下情況 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scan 掃會很慢，scan 這種操作基本上很難完全避掉，而它的速度取決於你的資料量，越大一定越久。&lt;/li&gt;
&lt;li&gt;持久化回復情況，你資料量越大，回復時間越久。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;雖然有人會說，咱們在使用時，業務上的操作都會清除 key，例如用戶離線會清，不會有沒清除掉的，但是事情總是沒有想的如此的美好。如果開發時沒考慮到一些特殊情況，又或是沒有注意到忘了處理，你就會發現 redis 變成你不認識的樣子了。&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;結論與心得&lt;/h2&gt;
&lt;p&gt;本篇文章介紹了網存服務應用 redis 的一些基本知識與一些使用上的小心得，而事實上這些建議事項與知識都和前面的文章有相關，例如 :&lt;/p&gt;
&lt;p&gt;redis 架構，就與下面這一篇文章有關。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20190907/&#34;&gt;30-07 之應用層的 I/O 優化 - 非阻塞 I/O 模型 Reactor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而建議 1 熟細操作時間複雜度，就和下面這篇有。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20190903/&#34;&gt;30-03 之應用層的運算加速 - 演算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;還有持久化機制 : 就和這一篇有關。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://mark-lin.com/posts/20190915/&#34;&gt;30-15 之資料庫層的難題 - 單機『 故障 』一致性難題&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這裡事實上會發現，都是我們之前有學習過的東西，而大部份的系統也都由這些知識建構起來，因此這三十天通了，那事實上你也幾乎可以說通了大部份的系統，這樣你在接下來的學習就會變的非常快，因為它們的基本原理都是相同的東西。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;學久了，就會發現系統的知識每一個都是串連起來的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;heading2&#34;&gt;參考資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000012908434&#34;&gt;redis 持久化详解,RDB和AOF是什么？他们优缺点是什么？运行流程是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://juejin.im/post/5b70dfcf518825610f1f5c16&#34;&gt;一文看懂Redis的持久化原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.techbridge.cc/2016/06/18/redis-introduction/&#34;&gt;資料庫的好夥伴：Redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://redisbook.readthedocs.io/en/latest/feature/transaction.html&#34;&gt;事务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>