<!DOCTYPE html>
<html>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154360458-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154360458-1');
</script>
  <head>
      <link rel="shortcut icon" href="assets/favicon.ico"/>
      <link rel="bookmark" href="assets/favicon.ico"/>

      <script data-ad-client="ca-pub-6564736746698681" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  一個像 Line 的聊天群設計 ~ 安安你好 ~ &ndash; 拿鐵派的馬克 Blog

    </title>
    
    <meta content="socket" name="keywords">
    
    
    <meta name="description" property="og:description" content="本篇文章中，我們講要說明，如何開發一個簡單的聊天群系統，這個東東雖然我們很常見到，到和我們平常開發的一些 WEB 有很大的差別。
差別在那呢 ? 假設我們開一個todolist功能，事實上大部份的工作就是crud的事情，每當要新增一個 todo 時，只要發送 http 到後端新增資料到資料庫裡去，然後在回傳結果就好了，但聊天群這種，如果你每發送一個訊息都使用 http 那一定爆掉的。
像聊天群這樣類型的，我們稱為InstantMessaging IM中文為即時通訊，本篇文章我們將會說明要建立這種IM應用所需要的基本知識。
開始吧 ~
從 Web 到 IM 的通信過程轉變 在最開始時瀏覽器它沒有辦法直接連接到另一個瀏覽器的通信功能，也就是說你不能從 A client 直接傳送訊息到 B client 去，我們只能在它們的中間，建立一個 server ，來將 A 要傳送的訊息儲放起來，然後 B 在自已去 server 取得資料，如下圖 :
這種做不行嗎 ? 說實話，功能是有做出來 ~ 但浪費太多的資源，你想想，根據上面的說法，當 A 發送訊息到 server 後，你 B 要如何知道 server 有你的訊息 ? 記好 http 只能從client發送到server，不能反之，所以這也代表這你 B 只能定時的去 server 問問看，說有沒有我的資料啊 ~
很明顯的，你可能問了十次，只有一次才有你要的訊息，那其它九次，不就都浪費掉了，這也代表你的 IM 系統有 90 % 的效能在處理沒用的事情。
當然中間處理的其它方法先不說，後來 html5 提出了一個應用層的協議websocket，來解決這事兒 ~
Hello WebSocket 這個協議可以幫助我們可以實現，從 server 端推送資料到 client 端，而且從建立的通道是持久連接，在 http 1.|Describe what your web page is about">
    

    <meta name="apple-mobile-web-app-title" content="拿鐵派的馬克 Blog">
    
    
    <link rel="icon" href="/favicon-64.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="mask-icon" size="any" href="/pinned-icon.svg">
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@your_twitter_id">
    <meta name="twitter:creator" content="@your_twitter_id">
    <meta name="twitter:title" content="一個像 Line 的聊天群設計 ~ 安安你好 ~ | 拿鐵派的馬克 Blog">
    <meta name="twitter:description" content="本篇文章中，我們講要說明，如何開發一個簡單的聊天群系統，這個東東雖然我們很常見到，到和我們平常開發的一些 WEB 有很大的差別。
差別在那呢 ? 假設我們開一個todolist功能，事實上大部份的工作就是crud的事情，每當要新增一個 todo 時，只要發送 http 到後端新增資料到資料庫裡去，然後在回傳結果就好了，但聊天群這種，如果你每發送一個訊息都使用 http 那一定爆掉的。
像聊天群這樣類型的，我們稱為InstantMessaging IM中文為即時通訊，本篇文章我們將會說明要建立這種IM應用所需要的基本知識。
開始吧 ~
從 Web 到 IM 的通信過程轉變 在最開始時瀏覽器它沒有辦法直接連接到另一個瀏覽器的通信功能，也就是說你不能從 A client 直接傳送訊息到 B client 去，我們只能在它們的中間，建立一個 server ，來將 A 要傳送的訊息儲放起來，然後 B 在自已去 server 取得資料，如下圖 :
這種做不行嗎 ? 說實話，功能是有做出來 ~ 但浪費太多的資源，你想想，根據上面的說法，當 A 發送訊息到 server 後，你 B 要如何知道 server 有你的訊息 ? 記好 http 只能從client發送到server，不能反之，所以這也代表這你 B 只能定時的去 server 問問看，說有沒有我的資料啊 ~
很明顯的，你可能問了十次，只有一次才有你要的訊息，那其它九次，不就都浪費掉了，這也代表你的 IM 系統有 90 % 的效能在處理沒用的事情。
當然中間處理的其它方法先不說，後來 html5 提出了一個應用層的協議websocket，來解決這事兒 ~
Hello WebSocket 這個協議可以幫助我們可以實現，從 server 端推送資料到 client 端，而且從建立的通道是持久連接，在 http 1.|Describe what your web page is about">
    <meta name="twitter:image" content="https://mark-lin.comtwitter-card.png">
    
    <meta name="author" content="marklin">
    <meta name="author" content="mark lin">
    <meta name="author" content="馬克">
    <meta name="author" content="拿鐵派">
    <meta name="author" content="拿鐵派的馬克">


    <link rel="stylesheet" href="/assets/syntax-1.1.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style-1.7.css">
  </head>


  <body>
        <div id="header" class="px-1 bg-white">
                <nav class="UnderlineNav--right px-2 container-lg">
  <div class="logo">
      <a class="log-main UnderlineNav-actions" href="https://mark-lin.com">
          拿鐵派的馬克 Blog
        </a>
      <span class="logo-small">拿鐵才是王道</span>
  </div>

  
  
</nav>
<div class='header-addd' style='width:600px;height:100px !important'> 
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<ins class="adsbygoogle"
     style="display:inline-block;width:600px;height:100px"
     data-ad-client="ca-pub-6564736746698681"
     data-ad-slot="8706832635"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>



              </div>
    <div id="holy" class="container-lg bg-white h-100">



      <div role="main" id="main" class="holy-main markdown-body px-4">
        




<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">一個像 Line 的聊天群設計 ~ 安安你好 ~</div>
  </div>
  <div class="Subhead-description">
    




<a href='/tags/instant-messaging' class="muted-link">
  <span class="Label Label--gray">instant messaging</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2019-12-15. Published at: 2017-09-11.">
        
          Lastmod: 2019-12-15
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <p>本篇文章中，我們講要說明，如何開發一個<code>簡單</code>的聊天群系統，這個東東雖然我們很常見到，到和我們平常開發的一些 WEB 有很大的差別。</p>
<p>差別在那呢 ? 假設我們開一個<code>todolist功能</code>，事實上大部份的工作就是<code>crud</code>的事情，每當要新增一個 todo 時，只要發送 http 到後端新增資料到資料庫裡去，然後在回傳結果就好了，但聊天群這種，如果你每發送一個訊息都使用 http 那一定爆掉的。</p>
<p>像聊天群這樣類型的，我們稱為<code>InstantMessaging IM</code>中文為即時通訊，本篇文章我們將會說明要建立這種<code>IM應用</code>所需要的基本知識。</p>
<p>開始吧 ~</p>
<h2 id="-web--im-">從 Web 到 IM 的通信過程轉變</h2>
<p>在最開始時瀏覽器它沒有辦法直接連接到另一個瀏覽器的通信功能，也就是說你不能從 A client 直接傳送訊息到 B client 去，我們只能在它們的中間，建立一個 server ，來將 A 要傳送的訊息儲放起來，然後 B 在自已去 server 取得資料，如下圖 :</p>
<p><img src="http://yixiang8780.com/outImg/20170912-1.png" alt=""></p>
<h3 id="-">這種做不行嗎 ?</h3>
<p>說實話，功能是有做出來 ~ 但浪費太多的資源，你想想，根據上面的說法，當 A 發送訊息到 server 後，你 B 要如何知道 server 有你的訊息 ? 記好 http 只能從<code>client</code>發送到<code>server</code>，不能反之，所以這也代表這你 B 只能定時的去 server 問問看，說有沒有我的資料啊 ~</p>
<p>很明顯的，你可能問了十次，只有一次才有你要的訊息，那其它九次，不就都浪費掉了，這也代表你的 IM 系統有 90 % 的效能在處理<code>沒用的事情</code>。</p>
<p>當然中間處理的其它方法先不說，後來 html5 提出了一個應用層的協議<code>websocket</code>，來解決這事兒 ~</p>
<h3 id="hello-websocket">Hello WebSocket</h3>
<p>這個協議可以幫助我們可以實現，從 server 端推送資料到 client 端，而且從建立的通道是持久連接，在 http 1.0 時你每發送一次請求，都需要做一次 tcp 握手，而 http 1.1 時，則可以多次使用一個 tcp，但在 websocket 你就只要建立一次，當完成握手後，就會產生一個全雙工的通道。</p>
<blockquote>
<p>全雙工代表這，可以從任何一方傳送資料或接受資料。</p>
</blockquote>
<p>它的 server 與 client 的運作圖如下 :</p>
<p><img src="http://yixiang8780.com/outImg/20170912-2.png" alt=""></p>
<h2 id="heading">最簡單的聊天群架構</h2>
<p>從上面的概念中我們知道，我們這邊主要需要使用的東西是 websocket，接下來我們可以來開始的規畫我們聊天群的架構。</p>
<p>我們先從最簡單的來看，如下圖 :</p>
<p><img src="http://yixiang8780.com/outImg/20170912-5.png" alt=""></p>
<p><code>Business Server</code> : 用來處理用戶需要用到 http 的操作，例如用戶登入、登出、加入聊天群、離開聊天群之類的，並且每當使用者要加入聊天群時，會發送訊息給 message server 然後它會在往 client 端推送說 ~ 某用戶加入聊天群囉 ~</p>
<p><code>Message Server</code> : 用來發送訊息與接受訊息。</p>
<p>上面的架構很簡單，就是 client 對一個 server，但我們來想想會發生什麼問題 ? 首先假設我們這個系統有多少人，server 就需要建立幾條的 websocket，那我想問，一台 server 可以接受幾個 websocket 連線呢 ?</p>
<h3 id="-server--">一台 server 可以有多少連線呢 ?</h3>
<p>這個問題說實話很難回答，因為還要考慮 server 性能、程式碼撰寫等，不過我這邊會簡單的根據，來大概的算出可能的連線數。</p>
<p>要理解這個問題，我們需要先理解下面這個知識，</p>
<h4 id="file-hanle-">file hanle 的限制</h4>
<p>在 unix 中每一個 tcp 連線都要占用一個<code>file descriptor</code>，而它有一定的限制數量，當使用完後，新的 tcp 連線到來就會發生錯誤以下的錯誤訊息 :</p>
<pre><code>Socket/File: Can't open so many files。
</code></pre><p>那一個 process 我們可以開啟幾個檔案呢 ? 我們可以用以下的指令來看看 :</p>
<pre><code>ulimit -n
</code></pre><p>像我這台 mac pro 的預設是 :</p>
<pre><code>4864
</code></pre><p>而如果是<code>AWS EC2</code>那在最基本版本，什麼都沒動過的則為 :</p>
<pre><code>1024
</code></pre><p>所以白話文的說，如果我沒有修改預設，我在這邊最多同時間，只能連線<code>4864</code>個 tcp 。
它當然可以改預設，不過每一個系統一定都是有上限的，記憶中有些系統的上線大約 1百萬 到2百萬之間，這邊到不確定。</p>
<blockquote>
<p>簡單的總結一下，一個 server 可以有多少連線呢 ? 直說我很難回答正確的答案，但我只能說，如果你沒調整預設的 process 限制，那必定只能連這個系統的上限(大概)。</p>
<p>但是每個系統有設定限制，就代表它預設一定有它的理由，所以不確定修改是不是個好方法。</p>
</blockquote>
<h2 id="-v2">聊天群架構 V-2</h2>
<p>上面的架構非常非常的簡單，但它有什麼問題呢 ? 我們想想以下這個場景 :</p>
<blockquote>
<p>我們某個聊天群裡總共 4 人，其中 A、B、C 三人目前在線上，而 D 不在線上，那麼 ~
要著麼確保 D 上線時，可以看到其它三人所發送的訊息呢 ?</p>
</blockquote>
<p>目前大概的想法為，增加兩個服務，其中第一個為使用 redies 建立的用來保存用戶狀態(上線與未上線)的服務，每當使用者登入或登出時，都會透過<code>business server</code>發送訊息來更新<code>redies</code>狀態。</p>
<p>然後每當有訊息準備要傳送時，<code>message server</code>會先到<code>redies</code>取得聊天群內的用戶資訊，然後如果在線上的，則進行傳送，不在線上的則將知存放到<code>temp message server</code>裡。</p>
<p>然後每當用戶上線時，<code>business server</code>會發個訊息到<code>messge server</code>去，然後去看看<code>temp message server</code>裡有沒有離線訊息，有的話就傳送出去。</p>
<p><img src="http://yixiang8780.com/outImg/20170912-3.png" alt=""></p>
<h2 id="-v3">聊天群架構 V-3</h2>
<p>上面的架構看似沒問題，但是它事實上有個缺點，有沒有注意到，很多的邏輯運算都在<code>message server</code>裡面做，我原本是將它定義成<code>只用來收發訊息</code>，但是我現在很多判斷都在裡面做，雖然在量不大時，還沒什麼問題，但如果量很大的話<code>message server</code>會上天堂的。</p>
<p>所以我決定在增加一個服務，就取名為<code>Logical Server</code>，架構圖如下 :</p>
<p><img src="http://yixiang8780.com/outImg/20170912-4.png" alt=""></p>
<p>它主要的工作就是要處理所有要送出與收到的邏輯運算，像我們剛剛上面說到，要更新使用者狀態也改成從這裡運作，而決定那些訊息要存放到離線 server 也是在這處理，而在每一次使用者登入時，要傳送的訊息也都是從這裡處理好，然後在去通知<code>message server</code>和他說，該送貨囉 ~~</p>
<h2 id="-v4">聊天群架構 V-4</h2>
<p>上面的架構中，我們基本上已經可以處理不少需求了，但我們在思考看看，有沒有那個地方可以改進，我們從一個角度來想，<code>流量</code>，我們仔細想一下那一個地方的流量是最大的 ? 嗯就是<code>message server</code>，假設我們一台<code>message server</code>hold 不住要著麼辦呢 ?</p>
<p>這時就是針對<code>message server</code>進行擴充，架構會變成如下 :</p>
<p><img src="http://yixiang8780.com/outImg/20170912-6.png" alt=""></p>
<p>上面新增加了兩個服務 :</p>
<p><code>Proxy</code> : 用來決定要使用那台<code>message server</code>與<code>client</code>進行連線，事實上就是 load balance 的功能。</p>
<p><code>Dispatch</code> : 用來決定訊息要傳送到那一個<code>message server</code>。</p>
<p>我們每一次要建立 websocket 連線時，都會需要先連到<code>proxy</code>由它來決定你要去那個<code>message server</code>建立 websocket 連線。</p>
<p>然後每當有訊息進來後，會到一個名為<code>dispatch</code>的服務，先將該訊息進行包裝，並且也會注明該訊息是從那個 message server 過來的，然後再傳送到 logical server 中，判斷那將該訊息送到那些用戶上，最後在回送到<code>dispatch</code>上，由它來決定要送到那個<code>message server 上</code>，最後再由它回傳給用戶上。</p>
<h2 id="heading1">結論</h2>
<p>在這篇文章中，我們所討論到的聊天群架構，事實上到 V-4 版本，已經可以處理大致上<code>WEB!</code>聊天群會用的功能，下一篇文章中我們將要來討論如果來設計<code>聊天室</code>。</p>
<h2 id="heading2">參考資料</h2>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/WebSocket">維基</a></li>
<li><a href="http://www.52im.net/forum.php?mod=collection&amp;op=all">IM技術網</a></li>
</ul>

  </section>

  <section>
    
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "mark-lin" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
  </section>

</article>
<div class="disqus markdown">
    <div id="disqus_thread"></div>
<script>





(function() { 
var d = document, s = d.createElement('script');
s.src = 'https://mark-lin.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  </div>

      </div>

      <div id="side" class="pr-1">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>一個像 Line 的聊天群設計 ~ 安安你好 ~</b><nav id="TableOfContents">
  <ul>
    <li><a href="#-web--im-">從 Web 到 IM 的通信過程轉變</a>
      <ul>
        <li><a href="#-">這種做不行嗎 ?</a></li>
        <li><a href="#hello-websocket">Hello WebSocket</a></li>
      </ul>
    </li>
    <li><a href="#heading">最簡單的聊天群架構</a>
      <ul>
        <li><a href="#-server--">一台 server 可以有多少連線呢 ?</a></li>
      </ul>
    </li>
    <li><a href="#-v2">聊天群架構 V-2</a></li>
    <li><a href="#-v3">聊天群架構 V-3</a></li>
    <li><a href="#-v4">聊天群架構 V-4</a></li>
    <li><a href="#heading1">結論</a></li>
    <li><a href="#heading2">參考資料</a></li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 text-center">
        




      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
