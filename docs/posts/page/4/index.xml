<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 拿鐵派的馬克 Blog</title>
    <link>https://mark-lin.com/posts/</link>
    <description>Recent content in Posts on 拿鐵派的馬克 Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <managingEditor>h091237557@gmail.com (marklin)</managingEditor>
    <webMaster>h091237557@gmail.com (marklin)</webMaster>
    <lastBuildDate>Mon, 30 Sep 2019 20:16:57 +0800</lastBuildDate>
    
        <atom:link href="https://mark-lin.com/posts/index.xml" rel="self" type="application/rss+xml" />
    

    
    <item>
      <title>Node之可擴展性 --- Node的Cluster</title>
      <link>https://mark-lin.com/posts/20170605/</link>
      <pubDate>Mon, 05 Jun 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170605/</guid>
      <description>本篇文章中將要說明，要如何的擴展 node 應用，從上一篇文章中我們知道， node 它很適合高 I/O 的任務，而不適合高 cpu 的任務，最主要的原因在於它的架構，它是單執</description>
    </item>
    
    <item>
      <title>Node之CPU吃重的任務要如何處理 ? </title>
      <link>https://mark-lin.com/posts/20170604/</link>
      <pubDate>Sun, 04 Jun 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170604/</guid>
      <description>這篇文章中，我們希望學習到 : 在開發nodejs時，如果遇到cpu密集型的任務時，要如何處理 ? 首先我們先來複習一下nodejs的機制一下。 我們</description>
    </item>
    
    <item>
      <title>Node 設計模式之代理器 ( Proxy )</title>
      <link>https://mark-lin.com/posts/20170603/</link>
      <pubDate>Sat, 03 Jun 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170603/</guid>
      <description>本篇文章中我們將要解決以下的問答。 什麼是代理器模式 ? 我們為什麼要使用它 ? 其中本篇文章還會介紹ES6所提供的Proxy使用方法。 什麼是代理器模</description>
    </item>
    
    <item>
      <title>Node.js 的串流之旅之雙工串流與管道</title>
      <link>https://mark-lin.com/posts/20170602/</link>
      <pubDate>Fri, 02 Jun 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170602/</guid>
      <description>在node js 中雙工串流主要有以下兩種，這兩種直接用白話文來講就是同時有read與write的功能。 Tranform Stream Duplex Stream 那這兩者有什麼差別呢，差別在於du</description>
    </item>
    
    <item>
      <title>Node.js 的串流之旅之基本概念</title>
      <link>https://mark-lin.com/posts/20170601/</link>
      <pubDate>Thu, 01 Jun 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170601/</guid>
      <description>串流是啥，事實上這個東東，我們每天都有使用，簡單的說，它是一種傳送內容的技術，在沒有使用串流技術時，我們想要在網路上看影片，需要將它下載下來</description>
    </item>
    
    <item>
      <title>排序之桶子排序法(Bucket Sort)</title>
      <link>https://mark-lin.com/posts/20170427/</link>
      <pubDate>Thu, 27 Apr 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170427/</guid>
      <description>比較排序法與非比較排序法 桶子排序法原理 桶子排序法使用時機 桶子排序法複雜度 javascript 演算法實作 比較排序法與非比較排序法 前面幾篇我們學的排序演算法都被歸</description>
    </item>
    
    <item>
      <title>排序之合併排序法(Merge Sort)</title>
      <link>https://mark-lin.com/posts/20170426/</link>
      <pubDate>Wed, 26 Apr 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170426/</guid>
      <description>合併排序法的原理 合併排序法的速度效能 合併排序法的空間效能 javascript 演算法實作 合併排序法原理 合併排序法，它也是與上一篇提到的快速排序法一樣，使用分治法</description>
    </item>
    
    <item>
      <title>排序之快速排序法(Quick Sort)</title>
      <link>https://mark-lin.com/posts/20170425/</link>
      <pubDate>Tue, 25 Apr 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170425/</guid>
      <description>快速排序法的原理 快速排序法的速度效能 快速排序法的空間效能 基準點的選擇 javascript 演算法實作 快速排序法的原理 快速排序法，又稱為分割排序法(partioi</description>
    </item>
    
    <item>
      <title>排序之堆積排序法(Heap Sort)</title>
      <link>https://mark-lin.com/posts/20170424/</link>
      <pubDate>Mon, 24 Apr 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170424/</guid>
      <description>本篇文章分成以下幾個章節 : 堆積樹(Heap tree)。 堆積排序法的原理。 堆積排序法的執行效能。 javascript 演算法實作。 堆積樹 Heap Tree 再說明堆積排序排序前，</description>
    </item>
    
    <item>
      <title>排序之選擇排序法(Selection Sort)</title>
      <link>https://mark-lin.com/posts/20170423/</link>
      <pubDate>Sun, 23 Apr 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170423/</guid>
      <description>選擇排序法的原理 插入排序法的執行效能 javascript演算法實作 選擇排序法的原理 選擇排序法，它基本的觀念為 : 將資料分成已排序與未排序，然後</description>
    </item>
    
    <item>
      <title>排序之插入排序法 ( Insertion Sort )</title>
      <link>https://mark-lin.com/posts/20170422/</link>
      <pubDate>Sat, 22 Apr 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170422/</guid>
      <description>插入排序法是我們第一個學習到的排序方法，我們本篇會針對它來詳細的介紹一下。 插入排序法的原理 插入排序法的執行效能 javascript演算法實作</description>
    </item>
    
    <item>
      <title>搜尋之二元搜尋法 Binary search</title>
      <link>https://mark-lin.com/posts/20170421/</link>
      <pubDate>Fri, 21 Apr 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170421/</guid>
      <description>基本上如果我們要在陣列中搜尋一個元素，最簡單的方法就是跑個迴圈一個一個跑，它有個專有名詞叫線性搜尋，這在未排序的資料中，效果還算可以，但是如</description>
    </item>
    
    <item>
      <title>演算法策略---動態規畫法</title>
      <link>https://mark-lin.com/posts/20170325/</link>
      <pubDate>Sat, 25 Mar 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170325/</guid>
      <description>動態規劃法 Dynamic programming ; DP，它與分治法很像，都是將大問題分割成小問題，而它和分治法不同的地方在於，它會將處理過的子問題解答，將它記憶起來，為了避免</description>
    </item>
    
    <item>
      <title>演算法策略---分治法</title>
      <link>https://mark-lin.com/posts/20170324/</link>
      <pubDate>Fri, 24 Mar 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170324/</guid>
      <description>在解決一個問題時，有一種很常見的方法，那就是將這個問題，分成很多個小問題，然後將所以小問題全部解決，最後可以合成一個解答。這種將問題分割變小</description>
    </item>
    
    <item>
      <title>演算法之策略---貪心法</title>
      <link>https://mark-lin.com/posts/20170323/</link>
      <pubDate>Thu, 23 Mar 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170323/</guid>
      <description>通常當我們遇到一個演算法的問題時，通常都有一些策略可以使用，本篇文章中我們將會說明貪心法這種策略。 基本概念 實作問題 基本概念 貪心法在解決問題</description>
    </item>
    
    <item>
      <title>鄂圖曼帝國掰掰後，中東變成什麼樣 ? </title>
      <link>https://mark-lin.com/posts/20170318/</link>
      <pubDate>Sat, 18 Mar 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170318/</guid>
      <description>鄂圖曼帝國是一個曾經強到在歐、亞、非都有領士的伊斯蘭帝國(1299~1922)，在世紀帝國二中，有一個國家上到城堡時代就可以建立土耳其火槍兵</description>
    </item>
    
    <item>
      <title>蘇聯的誕生與結束</title>
      <link>https://mark-lin.com/posts/20170317/</link>
      <pubDate>Fri, 17 Mar 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170317/</guid>
      <description>蘇聯 (Soviet Union)歷史上的超級強國Hyperpower 之一，在 60 年代時，與美國分庭抗禮，同時是社會主義的代表，但『可惜』這個大國在1991年</description>
    </item>
    
    <item>
      <title>資料結構---堆積 Heap</title>
      <link>https://mark-lin.com/posts/20170314/</link>
      <pubDate>Tue, 14 Mar 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170314/</guid>
      <description>這篇文章中，我們將要來說明堆積(heap)這種資料結構，但在說明這個資料結構前，讀者需要先了解二元樹這種資料結構，如果不了解的話，可以看看筆</description>
    </item>
    
    <item>
      <title>資料結構---圖形結構</title>
      <link>https://mark-lin.com/posts/20170311/</link>
      <pubDate>Sat, 11 Mar 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170311/</guid>
      <description>圖學理論(graph theory)它源於1736年的數學家 LeonHard Euler ，它為了解決Koenigsberg bridge問題而發展出來的理論，雖然Koe</description>
    </item>
    
    <item>
      <title>樹狀結構的遍歷 Traversal ( Iteration )</title>
      <link>https://mark-lin.com/posts/20170310/</link>
      <pubDate>Fri, 10 Mar 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170310/</guid>
      <description>在筆者的『基礎資料結構 3 &amp;mdash; 樹狀結構與二元樹』的這篇文章中，我們介紹了樹的基本概念，也學習了如何遍歷樹的方法，在之前的文章中，我們有說到，如果</description>
    </item>
    
    <item>
      <title>資料結構---樹狀結構與二元樹</title>
      <link>https://mark-lin.com/posts/20170309/</link>
      <pubDate>Thu, 09 Mar 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170309/</guid>
      <description>在這篇文章中，我們將要仔細的來說明樹(Tree)這個資料結構，它在計算機科學中非常的重要，有很多演算法都一定會運用到這種資料結構。接下來我們</description>
    </item>
    
    <item>
      <title>資料結構---串列 Linked List</title>
      <link>https://mark-lin.com/posts/20170213/</link>
      <pubDate>Mon, 13 Feb 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170213/</guid>
      <description>前篇文章中，我們說明三種資料結構、陣列、堆疊、佇列，在開始今天的文章前，我們先簡單的複習一下這三個東西是啥。 array : 最常用使用到的資料結構，它是</description>
    </item>
    
    <item>
      <title>資料結構---陣列(Array)、堆疊(Stack)、佇列(Queue)</title>
      <link>https://mark-lin.com/posts/20170211/</link>
      <pubDate>Sat, 11 Feb 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170211/</guid>
      <description>接下來的幾篇文章，我們將要簡單的說明幾個基礎的資料結構，那麼資料結構又是什麼呢? 根據 wiki 的解答。 資料結構是電腦中儲存、組織資料的方式。 也就是說</description>
    </item>
    
    <item>
      <title>VIM的五四三---vim &#43; syntastic &#43; eslint &#43; react的配置</title>
      <link>https://mark-lin.com/posts/20170201/</link>
      <pubDate>Wed, 01 Feb 2017 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20170201/</guid>
      <description>本篇文章中，我們將要和讀者說明，在使用vim開發javascript應用時，如何可以在每一次儲存時，自動的檢查我們js是否有問題，讓我們在開</description>
    </item>
    
    <item>
      <title>30-30之MongoDB三十天的學習之旅</title>
      <link>https://mark-lin.com/posts/20160930/</link>
      <pubDate>Fri, 30 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160930/</guid>
      <description>不知不覺~漫長的鐵人賽就進入了尾聲，當初會參加鐵人賽也只是因為，沒參加過 ~ 來試試看，而且也剛好我今年的時間比較多點兒，話說回來，為什麼我會選</description>
    </item>
    
    <item>
      <title>30-29之MongoDB--- 事務操作的空虛感</title>
      <link>https://mark-lin.com/posts/20160929/</link>
      <pubDate>Thu, 29 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160929/</guid>
      <description>本篇文章是用來補充一下，前面忘了講的觀念，記得在第一篇時，我們有提過下面這句話。 MongoDB 不支持事務操作 但事實上這段話有很多觀念要來說明說明，不然很</description>
    </item>
    
    <item>
      <title>30-28之MongoDB運用研究---股價應用模擬(3)</title>
      <link>https://mark-lin.com/posts/20160928/</link>
      <pubDate>Wed, 28 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160928/</guid>
      <description>上一篇研究簡單的說明完，股價分析的運用操作後，接下來我們這篇文章將要說明一些程式交易的東西，不過雖然說是程式交易，但事實上也只是簡單的計算出</description>
    </item>
    
    <item>
      <title>30-27之MongoDB運用研究---股價應用模擬(2)</title>
      <link>https://mark-lin.com/posts/20160927/</link>
      <pubDate>Tue, 27 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160927/</guid>
      <description>上一篇文章中，我們已經說明完基本的架構以及索引和分片的選擇，接下來我們就要實際的來使用資料來進行一些分析，能用搜尋時就用搜尋，不能用搜尋時就</description>
    </item>
    
    <item>
      <title>30-26之MongoDB運用研究---股價應用模擬(1)</title>
      <link>https://mark-lin.com/posts/20160926/</link>
      <pubDate>Mon, 26 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160926/</guid>
      <description>前面幾篇文章我們說明完了分片的運用後，我們接下來，就來實際的模擬個情景，我們來學習要如何的一步一步完成，咱們選擇的模擬情境為股價應用，現在F</description>
    </item>
    
    <item>
      <title>30-25之MongoDB分片Sharding(3)---片鍵的選擇</title>
      <link>https://mark-lin.com/posts/20160925/</link>
      <pubDate>Sun, 25 Sep 2016 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20160925/</guid>
      <description>上一篇文章我們詳細的說明完分片的機制後，接下來我們就要來詳細的說明片鍵的選擇，片鍵的選擇關係到你的分片執行速度與效能，並且一但建立後，要再修</description>
    </item>
    
  </channel>
</rss>