<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 拿鐵派的馬克 Blog</title>
    <link>https://mark-lin.com/posts/</link>
    <description>Recent content in Posts on 拿鐵派的馬克 Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <managingEditor>h091237557@gmail.com (marklin)</managingEditor>
    <webMaster>h091237557@gmail.com (marklin)</webMaster>
    <lastBuildDate>Mon, 30 Sep 2019 20:16:57 +0800</lastBuildDate>
    
        <atom:link href="https://mark-lin.com/posts/index.xml" rel="self" type="application/rss+xml" />
    

    
    <item>
      <title>30-30 之馬克版的一個好的系統攻略本 - 性能基礎篇</title>
      <link>https://mark-lin.com/posts/20190930/</link>
      <pubDate>Mon, 30 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190930/</guid>
      <description>這漫長辛苦的 30 天總於結束囉 ~ 接下來依慣例第 30 天都是總結篇。 這 30 天的過程咱們都在追求『 一個好的系統 』中的其中一個重點 : 性能 性能越高的系統，可以</description>
    </item>
    
    <item>
      <title>30-29 之資料庫層擴展中間件 - MyCAT 的淺淺談</title>
      <link>https://mark-lin.com/posts/20190929/</link>
      <pubDate>Sun, 29 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190929/</guid>
      <description>正文開始 前面幾篇文章中，咱們提到了如何擴展資料庫層級服務，讓它可以接更多的客，但是這些擴展方法中，都有提到一個『 中間件 』來使用，接下後本篇文</description>
    </item>
    
    <item>
      <title>30-28 之資料庫層擴展難題 -  MySQL 分散式事務處理</title>
      <link>https://mark-lin.com/posts/20190928/</link>
      <pubDate>Sat, 28 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190928/</guid>
      <description>正文開始 本篇文章中，咱們要來說說分散式系統中，最麻煩的部份『 分散式事務 』這一塊，接下來咱們來認真的理一下這個鬼。 本篇分為以下幾個章節 : 分散式</description>
    </item>
    
    <item>
      <title>30-27之資料庫層的擴展 - 分區表</title>
      <link>https://mark-lin.com/posts/20190927/</link>
      <pubDate>Fri, 27 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190927/</guid>
      <description>正文開始 上一篇文章中，咱們有提到了兩種資料庫層的擴展方式 : 分庫 分表 其中分表是用來解決單表太大的問題，而接下來本章節要來介紹另一種處理單表太的</description>
    </item>
    
    <item>
      <title>30-26之資料庫層的擴展 - 分庫分表架構</title>
      <link>https://mark-lin.com/posts/20190926/</link>
      <pubDate>Thu, 26 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190926/</guid>
      <description>正文開始 上一篇文章中，咱們介紹了資料庫層的分散的第一個起手式『 讀寫分離 』，這個方案是將寫與讀分散在不同的機器上，正常情況下，大部份的系統使用</description>
    </item>
    
    <item>
      <title>30-25之資料庫層的擴展 - 讀寫分離架構</title>
      <link>https://mark-lin.com/posts/20190925/</link>
      <pubDate>Wed, 25 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190925/</guid>
      <description>正文開始 前面的文章我們說明完應用層的分散式架構以後，接下來我們要來思考如果讓『 資料庫層 』做更多的事情。 在正式開始章節之前，我們先來想想看一件</description>
    </item>
    
    <item>
      <title>30-24 之應用層擴展『 外傳 』 - IM 服務擴展與雷坑</title>
      <link>https://mark-lin.com/posts/20190924/</link>
      <pubDate>Tue, 24 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190924/</guid>
      <description>正文開始 上一篇文章中，咱們理解了一般 web 系統的擴展方法後，接下來我們來一篇外傳，來說說關於 即時通訊服務 ( IM Instant Messaging Service ) 的擴展。 本篇文章共分以下幾個</description>
    </item>
    
    <item>
      <title>30-23 之應用層的擴展 - 負載均衡服務</title>
      <link>https://mark-lin.com/posts/20190923/</link>
      <pubDate>Mon, 23 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190923/</guid>
      <description>正文開始 前面幾篇的文章中，我們知道如何儘可能的在單機上，可以以最少的資源做最多的事，但是單機一定有它的限制，因此接下來我們要開始正式進入所謂</description>
    </item>
    
    <item>
      <title>30-22 之網路傳輸的優化 - HTTP 1.0 至 HTTP 3.0</title>
      <link>https://mark-lin.com/posts/20190922/</link>
      <pubDate>Sun, 22 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190922/</guid>
      <description>正文開始 本篇文章中，網路世界最重的協議 http，不只如上圖應用所示只有用戶端那有用到，現階段大部份很多 server 都還是會實用 http 去其它 server 取資料，所以一</description>
    </item>
    
    <item>
      <title>30-21 之網路傳輸的加速 - CDN 與 HTTP 緩存</title>
      <link>https://mark-lin.com/posts/20190921/</link>
      <pubDate>Sat, 21 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190921/</guid>
      <description>正文開始 前幾篇文章中，咱們討論完資料庫層的資料緩存以後，接下來咱們要來談談另外兩個緩存 : CDN ( Content Delivery Network ) HTTP 緩存 本篇文章分為以下幾個章節 : CDN 與運行</description>
    </item>
    
    <item>
      <title>30-20 之資料緩存失效問題</title>
      <link>https://mark-lin.com/posts/20190920/</link>
      <pubDate>Fri, 20 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190920/</guid>
      <description>正文開始 上一篇文章中咱們已經學習了一些緩存基本的策略，那接下來我們要來理解一下一個重要的主題 : 如果緩存失效的情況，與可能會發生什麼事情呢 ? 基</description>
    </item>
    
    <item>
      <title>30-19 之資料庫層的優化  - 資料緩存策略</title>
      <link>https://mark-lin.com/posts/20190919/</link>
      <pubDate>Thu, 19 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190919/</guid>
      <description>正文開始 上一篇咱們基本上已經理解緩存服務 redis 的基本概念後，接下來咱們要進入正題 : 緩存策略 相信不少人應該會覺得這很簡單，不就是將熱資料丟到緩存，</description>
    </item>
    
    <item>
      <title>30-18 之資料緩存層的服務 - Redis 概念與一致性難題</title>
      <link>https://mark-lin.com/posts/20190918/</link>
      <pubDate>Wed, 18 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190918/</guid>
      <description>正文開始 前面幾篇文章咱們已經學習完了資料層性能相關的知識，而接下來這篇文章，咱們要來學習，如何進一步的讓系統可以做更多的事情。 資料庫單機性能</description>
    </item>
    
    <item>
      <title>30-17 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 2 )</title>
      <link>https://mark-lin.com/posts/20190917/</link>
      <pubDate>Tue, 17 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190917/</guid>
      <description>正文開始 上一章節咱們學習到了，在並行情況下 mysql 可能會發生什麼樣的資料不一致問題，並且也學習到了這些問題它又是如何解決。 雖然 innodb 已經儘可能的解決上</description>
    </item>
    
    <item>
      <title>30-16 之資料庫層的難題 - 單機『 並行 』一致性難題 ( 1 )</title>
      <link>https://mark-lin.com/posts/20190916/</link>
      <pubDate>Mon, 16 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190916/</guid>
      <description>正文開始 本篇文章中，咱們要說說另一種資料不一致性產生的場景，那就是 : 『 並行 』產生的不一致性難題 基本上並行所產生的不一致性難題，可以分為以下幾</description>
    </item>
    
    <item>
      <title>30-15 之資料庫層的難題 - 單機『 故障 』一致性難題</title>
      <link>https://mark-lin.com/posts/20190915/</link>
      <pubDate>Sun, 15 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190915/</guid>
      <description>正文開始 前面幾篇文章中，咱們理解完了 mysql 的索引概念與原理，並且理解了在 mysql 中一個查詢的速度與否取決於索引與表的設計。接下來咱們要來理解一些會拖性</description>
    </item>
    
    <item>
      <title>30-14 之資料庫層的優化 - 表的設計</title>
      <link>https://mark-lin.com/posts/20190914/</link>
      <pubDate>Sat, 14 Sep 2019 20:16:57 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190914/</guid>
      <description>正文開始 本篇文章中咱們將要從『 表 』的角度來儘可能的優化性能。 表設計的幾個小建議 正規與非正規的小戰爭 表設計的幾個小建議 這個章節會給一些建立表時</description>
    </item>
    
    <item>
      <title>30-13 之資料庫層的優化 - 索引設計與雷區</title>
      <link>https://mark-lin.com/posts/20190913/</link>
      <pubDate>Fri, 13 Sep 2019 20:12:39 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190913/</guid>
      <description>正文開始 前面兩篇文章中，咱們已經學習完索引的核心觀念以後，接下來咱們學學在使用時有那些的優質的方法與注意事項。 30-11 之資料庫層的核心 - 索引結構演</description>
    </item>
    
    <item>
      <title>30-12 之資料庫層的核心 - MySQL 的索引實現</title>
      <link>https://mark-lin.com/posts/20190912/</link>
      <pubDate>Thu, 12 Sep 2019 20:11:06 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190912/</guid>
      <description>正文開始 上一篇文章中，我們理解了 innoDB 索引的基本原理 b+ 樹的，也理解了為什麼 innoDB 要選擇 b+ 樹的原因後，那接下來，我們要來理解，在 innoDB 中『 實際上 』是如何使</description>
    </item>
    
    <item>
      <title>30-11 之資料庫層的核心 - 索引結構演化論 B&#43;樹</title>
      <link>https://mark-lin.com/posts/20190911/</link>
      <pubDate>Wed, 11 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190911/</guid>
      <description>正文開始 接下來咱們要來理解資料庫系統中最核心的問題 : 要如何儲放資料，才能更快速的找到資料呢 ? 而這個東西的技術就是所謂的 : 索引 而在 mysql 中決定如何</description>
    </item>
    
    <item>
      <title>30-10 之資料庫層架構與優化方向</title>
      <link>https://mark-lin.com/posts/20190910/</link>
      <pubDate>Tue, 10 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190910/</guid>
      <description>正文開始 前面幾篇文章中，咱們大致上學習完了應用層的一些性能優化的基本知識，接下來咱們要來學學資料庫層的高性能優化方向。 在這裡先說一下一個重點</description>
    </item>
    
    <item>
      <title>30-09之應用層的兩個池 - 進 ( 線 ) 程池與連線池</title>
      <link>https://mark-lin.com/posts/20190909/</link>
      <pubDate>Mon, 09 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190909/</guid>
      <description>正文開始 接下來咱們要來談談，在應用層中很常提到的兩個池『線程池』與『連線池』，它們兩個在應用層扮演了性能方面什麼樣的角色。 本篇文章分為以下幾</description>
    </item>
    
    <item>
      <title>30-08 之應用層的 I/O 優化 ( 維護性 ) - 協程 Coroutine</title>
      <link>https://mark-lin.com/posts/20190908/</link>
      <pubDate>Sun, 08 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190908/</guid>
      <description>正文開始 上一篇文章說明完了非阻塞 I/O 模式核心 reactor，並且它可以幫我們建立 : 異步非阻塞的 I/O 操作。 而接下這篇文章我們將要來說說 coroutine 協程這東西</description>
    </item>
    
    <item>
      <title>30-07 之應用層的 I/O 優化 - 非阻塞 I/O 模型 Reactor</title>
      <link>https://mark-lin.com/posts/20190907/</link>
      <pubDate>Sat, 07 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190907/</guid>
      <description>正文開始 接下來本篇文章，咱們要來說明所謂的『 I/O 』模型。 這個東西我當初看到也有點不太能理解，為什麼需要它，但後來理解以後發覺，你只要知道一個 http</description>
    </item>
    
    <item>
      <title>30-06 之應用層的 I/O 優化 - Stream ( 與一些 IPC 知識 )</title>
      <link>https://mark-lin.com/posts/20190906/</link>
      <pubDate>Fri, 06 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190906/</guid>
      <description>正文開始 Stream 這個東東，基本上在每一個語言你都看的到，而今天我們將要深入的來理解它到底是什麼東西，並且它在一些 I/O 操作上可以幫助我們解決什麼事情。</description>
    </item>
    
    <item>
      <title>30-05 之應用層的 I/O 加速 - 零拷貝 ( Zero Copy )</title>
      <link>https://mark-lin.com/posts/20190905/</link>
      <pubDate>Thu, 05 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190905/</guid>
      <description>正文開始 前二篇文章中，咱們已經學習完運算方面的優化，而接下來幾篇文章，咱們要來說明 I/O 優化這個議題。 I/O 基本上可以分為兩種，『 文件 I/O 』與『 網路 I/O</description>
    </item>
    
    <item>
      <title>30-04 之應用層的運算加速 - 並行運算</title>
      <link>https://mark-lin.com/posts/20190904/</link>
      <pubDate>Wed, 04 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190904/</guid>
      <description>正文開始 假設你已經將你的演算法進行了優化，但是這時發現，這一項演算法工作還是需要花到非常多的時間處理，那要怎麼辦呢 ? 假設你所在的機器是多核心</description>
    </item>
    
    <item>
      <title>30-03 之應用層的運算加速 - 演算法</title>
      <link>https://mark-lin.com/posts/20190903/</link>
      <pubDate>Tue, 03 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190903/</guid>
      <description>正文開始 本篇文章開始，我們將要深入的探討，每一個服務，要如何儘可能的達到高性能呢 ? 這首先第一部份，我們要探討以下主題 : 在應用層，要如何儘可能</description>
    </item>
    
    <item>
      <title>30-02 之單機架構的性能優化方向與目標</title>
      <link>https://mark-lin.com/posts/20190902/</link>
      <pubDate>Mon, 02 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190902/</guid>
      <description>接下來咱們會從最基本的開始 : 儘可能的優化單機性能 基本上不少高性能的書籍都是直接跳至分散式架構，但是如果一個開發者連單機都處理不好，我不太相信</description>
    </item>
    
    <item>
      <title>30-01 之何謂一個好的系統呢  ?</title>
      <link>https://mark-lin.com/posts/20190901/</link>
      <pubDate>Sun, 01 Sep 2019 19:51:35 +0800</pubDate>
      <author>h091237557@gmail.com (marklin)</author>
      <guid>https://mark-lin.com/posts/20190901/</guid>
      <description>何謂一個好的系統呢 ? 為什麼會問這個問題呢 ? 因為事實上這個是我原本想要撰寫的主題。咱們工程師在開發系統，所學習的大部份的技術，基本上都是為了追</description>
    </item>
    
  </channel>
</rss>