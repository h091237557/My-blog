<!DOCTYPE html>
<html>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154360458-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154360458-1');
</script>
  <head>
      <link rel="shortcut icon" href="assets/favicon.ico"/>
      <link rel="bookmark" href="assets/favicon.ico"/>

      <script data-ad-client="ca-pub-6564736746698681" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  要如何定期的清除 Elasticsearch 文件 ? &ndash; 拿鐵派的馬克 Blog

    </title>
    
    <meta content="elasticsearch, aws elasticsearch" name="keywords">
    
    
    <meta name="description" property="og:description" content="上一篇文章『一個基於 AWS Elasticsearch 的用戶行為 log 系統建立』中我們說明了，如何使用 AWS Elasticsaerch 來建立收集 log 的系統，而 log 系統通常也有一種需求，那就是需要定期的清除舊...">
    
    <meta property="og:title" content="要如何定期的清除 Elasticsearch 文件 ?">
    <meta property="og:image" content="assets/11474637685936.jpg">

    <meta name="apple-mobile-web-app-title" content="拿鐵派的馬克 Blog">
    
    
    <link rel="icon" href="/favicon-64.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="mask-icon" size="any" href="/pinned-icon.svg">
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@your_twitter_id">
    <meta name="twitter:creator" content="@your_twitter_id">
    <meta name="twitter:title" content="要如何定期的清除 Elasticsearch 文件 ? | 拿鐵派的馬克 Blog">
    <meta name="twitter:description" content="上一篇文章『一個基於 AWS Elasticsearch 的用戶行為 log 系統建立』中我們說明了，如何使用 AWS Elasticsaerch 來建立收集 log 的系統，而 log 系統通常也有一種需求，那就是需要定期的清除舊|Describe what your web page is about">
    <meta name="twitter:image" content="https://mark-lin.comtwitter-card.png">
    
    <meta name="author" content="marklin">
    <meta name="author" content="mark lin">
    <meta name="author" content="馬克">
    <meta name="author" content="拿鐵派">
    <meta name="author" content="拿鐵派的馬克">


    <link rel="stylesheet" href="/assets/syntax-1.1.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style-1.7.css">
  </head>


  <body>
        <div id="header" class="px-1 bg-white">
                <nav class="UnderlineNav--right px-2 container-lg">
  <div class="logo">
      <a class="log-main UnderlineNav-actions" href="https://mark-lin.com">
          拿鐵派的馬克 Blog
        </a>
      <span class="logo-small">拿鐵才是王道</span>
  </div>

  
  
</nav>
<div class='header-addd' style='width:600px;height:100px !important'> 
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<ins class="adsbygoogle"
     style="display:inline-block;width:600px;height:100px"
     data-ad-client="ca-pub-6564736746698681"
     data-ad-slot="8706832635"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>



              </div>
    <div id="holy" class="container-lg bg-white h-100">



      <div role="main" id="main" class="holy-main markdown-body px-4">
        




<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">要如何定期的清除 Elasticsearch 文件 ?</div>
  </div>
  <div class="Subhead-description">
    




<a href='/tags/service-monitor' class="muted-link">
  <span class="Label Label--gray">service monitor</span>
</a>

<a href='/tags/elasticsearch' class="muted-link">
  <span class="Label Label--gray">elasticsearch</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2019-12-15. Published at: 2018-06-29.">
        
          Lastmod: 2019-12-15
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <p>上一篇文章<a href="http://marklin-blog.logdown.com/posts/7801415-establishment-of-a-log-system-based-on-aws-elasticsearch">『一個基於 AWS Elasticsearch 的用戶行為 log 系統建立』</a>中我們說明了，如何使用 AWS Elasticsaerch 來建立收集 log 的系統，而 log 系統通常也有一種需求，那就是需要定期的清除舊的 log ，所以本篇文章的主題為:</p>
<blockquote>
<p>要如何定期的清除 Elasticsearch 文件 ?</p>
</blockquote>
<p>然後我們會分成以下幾個章節:</p>
<ul>
<li>最直覺式的定期刪除方法與缺點。</li>
<li>為什麼大量文件的清除對 Elasticsearch 會很耗資源呢 ?</li>
<li>大量文件清除方法 - 時間索引策略。</li>
</ul>
<h2 id="heading">最直覺式的定期刪除方法與缺點</h2>
<p>假設有以下的資料:</p>
<pre><code>{
  data: 'Hi Mark ~',
  created_at: '20180101'
},
{
  data: 'HI Fuc u Mark',
  created_at: '20180201'
}
</code></pre><p>那我們要清除 1 月份的 log ，那我們最直覺的做法，應該會如下的操作:</p>
<ol>
<li>搜尋所有 created_at 為 1 月的 doc。</li>
<li>再將所有搜尋出的 doc 給清除。</li>
</ol>
<blockquote>
<p>上面這方法在小量資料時，是沒問題的，問題是出在大量資料。</p>
</blockquote>
<p>那為什麼大量資料刪除會有問題呢 ?</p>
<p>Elasticsearch 在進行刪除時，它是將 doc 給一個此 doc 已刪除的 tag ，然後再接下來的搜尋時，會自動將有 tag 的 doc 給過濾掉，這也代表在清除的當下資源沒有被釋放出來。</p>
<p>接下來 Elasticsearch 會在某個條件下，會執行<code>segment merging</code>的工作，這個時後它才會將實際上的文件清除，而且這個工作在大量資料下，會非常的消耗 cpu 與 i/o 的資源。</p>
<h2 id="-elasticsearch--">為什麼大量文件的清除對 Elasticsearch 會很耗資源呢 ?</h2>
<p>要理解這個問題，我們就要從<code>倒排索引</code>開始說起，不熟可以去我這篇<a href="http://marklin-blog.logdown.com/posts/7346272">Elasticsearch 的 Document 建立原理</a>看個兩三下。</p>
<h3 id="heading1">倒排索引的建立</h3>
<p>首先，每當一個 doc 建立時，它會先被丟到一個叫 memory buffer 的地方，等到一段時間 or buffer 滿了，系統會將它建立成一個<code>segment</code>，如下圖。</p>
<p><img src="http://yixiang8780.com/outImg/20180702-01-delete-log.png" alt=""></p>
<p>而這個 segment 就是我們的<code>倒排索引</code>集合，它也是在我們在進行搜尋時，會實際去尋找的地方。這裡有一個很重要的事情要說:</p>
<blockquote>
<p>每一個 segment 內的倒排索引是不可以變的。</p>
</blockquote>
<p>所以說如果你新增了第二個 doc ，它會在去新增一個 segment，那你在『某段時間』內，會有 2 個 segment，然後搜尋時，就是去每個 segment 中搜尋，然後將結果進行合併，得出結果。</p>
<p><img src="http://yixiang8780.com/outImg/20180702-02-delete-log.png" alt=""></p>
<h3 id="-segment--">多個 segment 會有什麼問題呢 ?</h3>
<p>首先 segment 裡面是存放倒排索引的資訊，而這個東西，它是寫在<code>硬碟</code>中。所以如果每一次進行搜尋時，有 100 segment 個代表你要開啟 100 個檔案，如果越來越多，你的 i/o 與 file descriptor 遲早會出問題。</p>
<h3 id="-segment--segment-merging">解決多個 segment 的方法 segment merging，但它很耗資源</h3>
<p>所以 Elasticsearch 提出了一個機制，那就是<code>segment merging</code>。</p>
<p>這個東東將是會定時的將小 segment 合成一個大的 segment，如下圖。</p>
<p><img src="http://yixiang8780.com/outImg/20180702-03-delete-log.png" alt=""></p>
<p>這項工作是非常的消耗資源的，如果你有 100 個小的 segment，你就要將開啟 100 條的 i/o 並且需要進行大量的運算。</p>
<blockquote>
<p>而且如果你還大量刪除了 doc ，它還要去某個檔案中，抓取已刪除的檔案編號，然後在和原本的每一個 segment 進行比對，再組合成 1 個新的 segment。這想也知道會非常的耗 CPU 與 i/o 資源。</p>
</blockquote>
<h2 id="--">大量文件清除方法 - 時間索引策略</h2>
<p>所以為了解決這個問題，我們將會使用時間索引策略來進行 doc 的刪除。</p>
<blockquote>
<p>這策略概念就是每天(or 區間)產生一個 index，然後過時了再砍掉它</p>
</blockquote>
<p>首先為了別讓人搞混，我先畫張圖，此索引非倒排索引。從下圖中我們可以知道一個 Elasticsearch  的 Index 是由不同節點的 shard 組合而成，然後每個 shard 裡面包含了 doc 與 segment。</p>
<p><img src="http://yixiang8780.com/outImg/20180702-04-delete-log.png" alt=""></p>
<p>所以說，我們可以知道每個 segment 都是包含在一個 index 中，那我們想想看下面這個問題 ?</p>
<blockquote>
<p>假如我們直接刪除了 index 後，segment 會著麼樣呢 ?</p>
</blockquote>
<p>答案就是 doc 與 segment 都一起消失，不需要在做那些 segment merging 啥的。</p>
<p>所以我們這裡的策略就是:</p>
<blockquote>
<p>根據時間來建立 index (假設每天) ，然後每當要清除舊 log 時，我們就將指定的 index 給清除就好，這樣就不需要執行 segment merging 這種耗資源的工作了</p>
</blockquote>
<h3 id="-part1---index-template">時間索引策略 part1 - 建立 index template</h3>
<p>首先我們要建立一個 index 的 template，如下，建立完成以後，我們接下來每次只要建立的索引名稱為<code>api-*</code>這種類型 (ex. api-2018-01-01) ，系統就會依照下面的範本來進行建立。</p>
<p>然後<code>aliases</code>就是別命，假設建立出來的索引為 api-2018-01-01，我們就可以使用 api 這個別命來操作它，所以這也代表我們每一次新增 doc 指令索引時，不用一直換啊換。</p>
<pre><code> await client.indices.putTemplate({
      name: 'api-template',
      template: 'api-*',
      body: {
        'settings': {
          'number_of_shards': 5,
          'number_of_replicas': 1
        },
        'aliases': {
          'api': {}
        },
        'mappings': {
          'log': logMapping
        }
      }
    });
</code></pre><h3 id="-part2--">時間索引策略 part2 - 排程每天建立一個新的索引，並將操作指向它</h3>
<p>下面這個 api 就是會依據<code>max_age</code>與<code>max_docs</code>的條件，來決定是否建立索引，其中一個符合，那就會建立新的索引，並且將操作(新增 doc)指向這個新建立的索引。</p>
<p>下面這個範例，rollover 會自動依流水號來建立 index，當然也可以依據時間來建立，請參考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html">官網這篇文章</a>。</p>
<pre><code>POST api/_rollover
{
  &quot;conditions&quot;: {
    &quot;max_age&quot;:   &quot;1d&quot;,
    &quot;max_docs&quot;:  5
  }
}
</code></pre><pre><code>{
  &quot;old_index&quot;: &quot;api-logs-1&quot;,
  &quot;new_index&quot;: &quot;api-logs-2&quot;,
  &quot;rolled_over&quot;: true,
  &quot;dry_run&quot;: false,
  &quot;conditions&quot;: {
    &quot;[max_docs: 5]&quot;: true,
    &quot;[max_age: 7d]&quot;: false
  }
}
</code></pre><blockquote>
<p>P.S 如果是使用 AWS kinesis 的話，這一步可以不用做，在設定它時，有個叫 Index rotation 的參數可以設定，它可以設定 hour、day、week、month，功能就和上面的一樣</p>
</blockquote>
<h3 id="-part3--">時間索引策略 part3 - 定時的清除索引</h3>
<p>如果你的索引名稱如<code>api-2018-01-01</code>這種類型的話，你可以依據它來選擇清除，而如果你的命名不是這樣的話，那你可以使用下面這個 api 來知道每一個索引的建立時間。</p>
<pre><code>curl http://localhost:9200/_cat/indices\?h\=h,s,i,id,p,r,dc,dd,ss,creation.date.string
</code></pre><p>結果如下圖。</p>
<p><img src="http://yixiang8780.com/outImg/20180702-05-delete-log.png" alt=""></p>
<h3 id="-part4--">時間索引策略 part4 - 搜尋的操作</h3>
<p><code>rollover</code> api 上面有提到，會將所以的操作自動的轉向到新的索引，所以你如果要進行搜尋操作時，你可以執行下面的指令，這樣你所有的索引都可以尋找到。</p>
<pre><code>curl http:127.0.0.1:9200/api-*/_search?pretty
</code></pre><h2 id="heading2">參考資料</h2>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/inside-a-shard.html">官網-分配內部原理</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-rollover-index.html">官網 rollover api</a></li>
<li><a href="https://www.elastic.co/blog/managing-time-based-indices-efficiently">managing-time-based-indices-efficiently</a></li>
</ul>

  </section>

  <section>
    
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "mark-lin" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
  </section>

</article>
<div class="disqus markdown">
    <div id="disqus_thread"></div>
<script>





(function() { 
var d = document, s = d.createElement('script');
s.src = 'https://mark-lin.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  </div>

      </div>

      <div id="side" class="pr-1">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>要如何定期的清除 Elasticsearch 文件 ?</b><nav id="TableOfContents">
  <ul>
    <li><a href="#heading">最直覺式的定期刪除方法與缺點</a></li>
    <li><a href="#-elasticsearch--">為什麼大量文件的清除對 Elasticsearch 會很耗資源呢 ?</a>
      <ul>
        <li><a href="#heading1">倒排索引的建立</a></li>
        <li><a href="#-segment--">多個 segment 會有什麼問題呢 ?</a></li>
        <li><a href="#-segment--segment-merging">解決多個 segment 的方法 segment merging，但它很耗資源</a></li>
      </ul>
    </li>
    <li><a href="#--">大量文件清除方法 - 時間索引策略</a>
      <ul>
        <li><a href="#-part1---index-template">時間索引策略 part1 - 建立 index template</a></li>
        <li><a href="#-part2--">時間索引策略 part2 - 排程每天建立一個新的索引，並將操作指向它</a></li>
        <li><a href="#-part3--">時間索引策略 part3 - 定時的清除索引</a></li>
        <li><a href="#-part4--">時間索引策略 part4 - 搜尋的操作</a></li>
      </ul>
    </li>
    <li><a href="#heading2">參考資料</a></li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 text-center">
        




      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
