<!DOCTYPE html>
<html>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154360458-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-154360458-1');
</script>
  <head>
      <link rel="shortcut icon" href="assets/favicon.ico"/>
      <link rel="bookmark" href="assets/favicon.ico"/>

      <script data-ad-client="ca-pub-6564736746698681" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  演算法之策略---貪心法 &ndash; 拿鐵派的馬克 Blog

    </title>
    
    <meta content="algorithm, greedy" name="keywords">
    
    
    <meta name="description" property="og:description" content="通常當我們遇到一個演算法的問題時，通常都有一些策略可以使用，本篇文章中我們將會說明貪心法這種策略。 基本概念 實作問題 基本概念 貪心法在解決問題時，基本上它只會根據當前最好的資料，就做出選擇，如果以心理學...">
    
    <meta property="og:title" content="演算法之策略---貪心法">
    <meta property="og:image" content="https://mark-lin.com/assets/11474637685936.jpg">

    <meta name="apple-mobile-web-app-title" content="拿鐵派的馬克 Blog">
    
    
    <link rel="icon" href="/favicon-64.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="mask-icon" size="any" href="/pinned-icon.svg">
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@your_twitter_id">
    <meta name="twitter:creator" content="@your_twitter_id">
    <meta name="twitter:title" content="演算法之策略---貪心法 | 拿鐵派的馬克 Blog">
    <meta name="twitter:description" content="通常當我們遇到一個演算法的問題時，通常都有一些策略可以使用，本篇文章中我們將會說明貪心法這種策略。 基本概念 實作問題 基本概念 貪心法在解決問題時，基本上它只會根據當前最好的資料，就做出選擇，如果以心理學|Describe what your web page is about">
    <meta name="twitter:image" content="https://mark-lin.comtwitter-card.png">
    
    <meta name="author" content="marklin">
    <meta name="author" content="mark lin">
    <meta name="author" content="馬克">
    <meta name="author" content="拿鐵派">
    <meta name="author" content="拿鐵派的馬克">


    <link rel="stylesheet" href="/assets/syntax-1.1.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style-1.7.css">
  </head>


  <body>
        <div id="header" class="px-1 bg-white">
                <nav class="UnderlineNav--right px-2 container-lg">
  <div class="logo">
      <a class="log-main UnderlineNav-actions" href="https://mark-lin.com">
          拿鐵派的馬克 Blog
        </a>
      <span class="logo-small">拿鐵才是王道</span>
  </div>

  
  
</nav>
<div class='header-addd' style='width:600px;height:100px !important'> 
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<ins class="adsbygoogle"
     style="display:inline-block;width:600px;height:100px"
     data-ad-client="ca-pub-6564736746698681"
     data-ad-slot="8706832635"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>



              </div>
    <div id="holy" class="container-lg bg-white h-100">



      <div role="main" id="main" class="holy-main markdown-body px-4">
        




<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">演算法之策略---貪心法</div>
  </div>
  <div class="Subhead-description">
    




<a href='/tags/algorithm' class="muted-link">
  <span class="Label Label--gray">algorithm</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2019-12-14. Published at: 2017-03-23.">
        
          Lastmod: 2019-12-14
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <p>通常當我們遇到一個演算法的問題時，通常都有一些策略可以使用，本篇文章中我們將會說明<code>貪心法</code>這種策略。</p>
<ul>
<li>基本概念</li>
<li>實作問題</li>
</ul>
<h2 id="heading">基本概念</h2>
<p>貪心法在解決問題時，基本上它只會根據當前最好的資料，就做出選擇，如果以心理學的<code>忍耐實驗</code>來說明 ; 這個實驗會給一堆小孩 1 塊巧克力，然後和小孩說，如果 15 分鐘後沒有吃掉這巧克力，那你就會有 3 塊巧克力，而貪心演算法它就只會考慮當下最佳解，也就是說它會吃掉巧克力。</p>
<p>簡單用一句話說明貪心法的要義那就是</p>
<blockquote>
<p>只選擇『當時最佳的選擇』</p>
</blockquote>
<p>但是對於一個問題時，我們要著麼知道它是否可用貪心法來解決，以及是否得到問題的最佳解 ?
針對第一個問題『我們著麼知道是否可用貪心法』，我們可以看看問題的性質，如果一個問題，我們可以簡單的猜測，這問題是一個簡單的計算方法，並且答案正確，那這種類型的問題就適合它 ; 那第二個問題『 是否得到最佳解 』，這就不一定了，我們很難判斷我們用貪心法得出的答案是否是最佳解。</p>
<p>那貪心法適合什麼樣的問題呢 ? 這和上面的問題是不同的喔 ? 上面是問可用，這邊是問適合。貪心法在最優子結構的問題中特別有用，最優子結構的意思就是局部最優解能決定全局最優解。</p>
<p>根據<code>wiki</code>，我們可以將使用貪心法的過程分解成以下幾個部份。</p>
<ol>
<li>建立數學模型來描述問題。</li>
<li>把求解的問題分成若干個子問題。</li>
<li>對每一個子問題求解，得到子問題的局部最優解。</li>
<li>把子問題的解，合成原來解問題的一個解。</li>
</ol>
<h2 id="heading1">實作練習</h2>
<p>以下的問題都出自於<code>培養與鍛鍊程式設計的邏輯腦</code>這個本書裡，但我們這邊的都會使用<code>JS</code>來進行實作。</p>
<h3 id="heading2">硬幣問題</h3>
<blockquote>
<p>一元、五元、十元、五十元、一百元、五百元硬幣。我們想要儘可能少的硬幣支付 A 元。到底需要幾枚硬幣呢 ? 假設這種付款方式至少會存在一種。</p>
</blockquote>
<p>這個問題基本上是貪心法的基本問題，而且也是日常常見的問題。這個問題的重點是『盡可能少的硬幣』，所以很自然的我們直覺會想盡量多付五百，再來是一百，然後已此類推，就可以得到最小的硬幣數量。</p>
<p>程式碼如下，非常的簡單。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">coins</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">50</span>,<span style="color:#ae81ff">100</span>,<span style="color:#ae81ff">500</span>];
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pay</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2430</span>;

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">greedSol</span>(<span style="color:#a6e22e">coins</span>,<span style="color:#a6e22e">pay</span>){
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> {};
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">=</span><span style="color:#a6e22e">coins</span>.<span style="color:#a6e22e">length</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">--</span>){
		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">coinNum</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">floor</span>(<span style="color:#a6e22e">pay</span><span style="color:#f92672">/</span><span style="color:#a6e22e">coins</span>[<span style="color:#a6e22e">i</span>]);	
		<span style="color:#a6e22e">pay</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">coins</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">*</span> <span style="color:#a6e22e">coinNum</span>;
		<span style="color:#a6e22e">result</span>[<span style="color:#a6e22e">coins</span>[<span style="color:#a6e22e">i</span>]] <span style="color:#f92672">=</span> <span style="color:#a6e22e">coinNum</span>;
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
}

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">greedSol</span>(<span style="color:#a6e22e">coins</span>,<span style="color:#a6e22e">pay</span>));

</code></pre></div><p>輸出結果為。</p>
<pre><code>{
  '1': 0, 
  '5': 0, 
  '10': 3, 
  '50': 0, 
  '100': 4, 
  '500': 4 
 }
</code></pre><h4 id="-20191214">更新於 20191214</h4>
<blockquote>
<p>但是這一題使用貪心法事實上會有問題。</p>
</blockquote>
<p>假設咱們有 1、3、5 硬幣，然後要付 12 元，那這時使用貪心法會這樣取 :</p>
<ol>
<li>取 5 =&gt; pay = 7</li>
<li>取 5 =&gt; pay = 2</li>
<li>取 ?</li>
</ol>
<p>但了 step 3 就會出問題，這題的正解應該是取 4 個 3。這題的正解應該是使用 dp。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * @param coins: a list of integer
</span><span style="color:#75715e">     * @param amount: a total amount of money amount
</span><span style="color:#75715e">     * @return: the fewest number of coins that you need to make up
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">int</span> coinChange(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>coins, <span style="color:#66d9ef">int</span> amount) {
        <span style="color:#75715e">// write your code here
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// def: dp[i] = 代表 i 所需要的最少硬幣數量
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// example. coins [1,2,3] amount = 10
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// dp[10] = min(dp[10-1], dp[10-2], dp[10-3], 1)
</span><span style="color:#75715e"></span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dp (amount<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> amount ; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>){
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> coins.size(); j<span style="color:#f92672">+</span><span style="color:#f92672">+</span>){
                <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> coins[j];
                <span style="color:#66d9ef">if</span>(v <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> dp[v] <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
                    <span style="color:#66d9ef">if</span>(dp[i] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> dp[v] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> dp[i]){
                        dp[i] <span style="color:#f92672">=</span> dp[v] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
                    }
                }
            }
        }
        <span style="color:#66d9ef">return</span> dp[amount];
    }
}
</code></pre></div><h3 id="heading3">行程規劃問題</h3>
<blockquote>
<p>有 n 件工作。各工作分別由時間 Si 開始，並於時間 Ti 結束。你一定要選擇是參加各項工作。如果參加了就一定要全程，另外參加之工作時間不能重疊。</p>
</blockquote>
<p>這個問題基本上也很常日常發生，假設我們有一堆事情要做，但我們時間有限，只能選擇幾個來做，那我們要著麼選擇，才能完成最多的事情 ?</p>
<p>第一版實作程式碼如下，基本的概念就是每次取一工作來做，然後做完後，在取得下一件工作。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">tasks</span> <span style="color:#f92672">=</span> [
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">3</span>}, 
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>},
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">7</span>},
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">6</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">8</span>},
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">8</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">11</span>},
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">12</span>,<span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">14</span>}
];

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">taskPlanSolv</span>(<span style="color:#a6e22e">tasks</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">curEnd</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
		<span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> [];
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">tasks</span>.<span style="color:#a6e22e">length</span>;<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">tasks</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">start</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">curEnd</span>) {
			<span style="color:#a6e22e">curEnd</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">tasks</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">end</span>;
			<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">tasks</span>[<span style="color:#a6e22e">i</span>]);
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
}
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">taskPlanSolv</span>(<span style="color:#a6e22e">tasks</span>));

</code></pre></div><p>執行結果如下，它會取這四件工作來做。</p>
<pre><code>[ { start: 1, end: 3 },
  { start: 4, end: 7 },
  { start: 8, end: 11 },
  { start: 12, end: 14 } ]
</code></pre><p>但上述的演算法有個很大的問題，那就是假設我們第一個工作改成以下這樣，那我們會發現，我們輸出的結果是<code>[ { start: 1, end: 13 } ]</code>，那這樣就錯了，我們要的是能做最多工作的演算法。</p>
<pre><code> { start:1 , end : 13 }
</code></pre><p>所以我們這邊要在上述演算法中修改成如下的目的。</p>
<blockquote>
<p>從以可以選擇的工作中不斷選擇結束時間最早的工作。</p>
</blockquote>
<p>更改後的程式碼如下，我們下面改成會先針對結束時間，將<code>task</code>進行排序，然後在進行工作選取，這樣就完成囉。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">tasks</span> <span style="color:#f92672">=</span> [
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">13</span>}, 
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>},
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">7</span>},
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">6</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">8</span>},
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">8</span>, <span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">11</span>},
{ <span style="color:#a6e22e">start</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">12</span>,<span style="color:#a6e22e">end</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">14</span>}
];

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">taskPlanSolv</span>(<span style="color:#a6e22e">tasks</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">curEnd</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
		<span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> [];
	<span style="color:#a6e22e">tasks</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">sortTaskByEndTime</span>(<span style="color:#a6e22e">tasks</span>);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">tasks</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">tasks</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">start</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">curEnd</span>) {
			<span style="color:#a6e22e">curEnd</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">tasks</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">end</span>;
			<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">tasks</span>[<span style="color:#a6e22e">i</span>]);
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sortTaskByEndTime</span>(<span style="color:#a6e22e">tasks</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">tasks</span>.<span style="color:#a6e22e">sort</span>(<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">end</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">end</span>;
	});
}
</code></pre></div><p>執行結果如下。</p>
<pre><code>var tasks = [
{ start: 2, end: 4},
{ start: 6, end: 8},
{ start: 12,end: 14}
];
</code></pre><h3 id="heading4">字典順序最小問題</h3>
<p>這個問題是<code>POJ 3617</code>的<code>Best Cow Line</code>問題，它的問題如下。以下中文範例<a href="http://www.cnblogs.com/Simon-X/p/5309380.html">來源為此</a>。</p>
<blockquote>
<p>FJ打算带他的N（1 ≤ N ≤ 2,000）头奶牛去参加&quot;Farmer of the Year&quot;比赛。在这个比赛中每个农夫都会把他们的奶牛排成一队，然后经过评审团。</p>
<p>比赛方今年采用了一种新的登记方案：每头牛的出场都以名字首字母进行简要登记（换句话说，如果FJ带了Bessie、Sylvia和Dora参加，那么他只要登记成BSD）。登记结束后，每组评判根据奶牛名字首字母串字典序升序评判。</p>
<p>FJ今年事特多又得赶回农场，想早点完事。因此他决定在登记前把已经排好队的奶牛重排一遍。</p>
<p>FJ找了块地给比赛的奶牛排新队伍。接着他不断把第一头或最后一头牛从旧（或者剩下的）队伍转移到新队伍的尾部。搞定后，FJ会用这个新队伍登记。</p>
<p>给你这群奶牛的大写字母，找出上述方法排列后字典序最小的字符串。</p>
</blockquote>
<p>對真的很長，然後我們整理一下，大概可以簡單的變成如下的問題。</p>
<blockquote>
<p>給定 N 個字完的字串 S ，並建立 N 個字元的字串 T ，然後它從 S 的<code>開頭或尾端</code>刪除一個字元，並將之新增至 T 尾端，並使 T 以字典排序儘可能地小。</p>
</blockquote>
<p>上面就是我們要實作的演算法，我們先說一下字典排序的意思，例如假設我們有以下的字詞。</p>
<pre><code>BAC
ACE
ABF
BCA
</code></pre><p>根據字典排序並且盡可能小的規則，會排序成如下。其中如果第一個字元相同，那就在比第二個字元，第二個字元相同就比第三個，以此類推，這就是<code>字典排序</code>。</p>
<pre><code>ABF
ACE
BAC
BCA
</code></pre><p>然後我們來說明演算法的流程，假設我們有<code>ACDBCB</code>字元 N ，然後我們根據以上的規則，選擇<code>開頭或尾端</code>的值，新增到一個新字串 T 上，然後這新字串的字典排序會儘可能的小，我們的流程如下。</p>
<ul>
<li>Step1. <code>ACDBCB</code>，頭與尾比<code>A</code>比<code>B</code>小，新增進T字串，T 字串為<code>A</code>。</li>
<li>Step2. <code>CDBCB</code>，頭與尾比<code>C</code>比<code>B</code>大，所以<code>B</code>新增進T字串，T 字串為<code>AB</code>。</li>
<li>Step3. <code>CDBC</code>，頭與尾比<code>C</code>等於<code>C</code>，隨便取一個，就取前好了，T 字串為<code>ABC</code>。</li>
<li>Step4. <code>DBC</code>，頭與尾比<code>D</code>比<code>C</code>大，所以<code>C</code>新增至T字串，T 字串為<code>ABCC</code>。</li>
<li>Step5. <code>DB</code>，頭與尾比<code>D</code>比<code>B</code>大，所以<code>B</code>新增至T字串，T 字串為<code>ABCCB</code>。</li>
<li>最後結果就為<code>ABCCBD</code>。</li>
</ul>
<p>這就是很典形的貪心演算法的問題，不斷的取開頭或字尾較小字元加到 T 內，它不會在意之後的解如何，只會取當前最有利的值。</p>
<p>我們實作的程式碼如下。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">debugger</span>;
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">N</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ACDBCB&#34;</span>;

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">bestCowLineSolve</span>(<span style="color:#a6e22e">text</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">leftPosition</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
		<span style="color:#a6e22e">rightPosition</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>,
		<span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> [],
		<span style="color:#a6e22e">textLen</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>;

	<span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">textLen</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
		<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">leftChar</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>[<span style="color:#a6e22e">leftPosition</span>];
		<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rightChar</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>[<span style="color:#a6e22e">rightPosition</span>];

		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">leftChar</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">rightChar</span>) {
			<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">leftChar</span>);
			<span style="color:#a6e22e">leftPosition</span><span style="color:#f92672">++</span>;
		} <span style="color:#66d9ef">else</span>  {
			<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">rightChar</span>);
			<span style="color:#a6e22e">rightPosition</span><span style="color:#f92672">--</span>;
		} 
		<span style="color:#a6e22e">textLen</span><span style="color:#f92672">--</span>;
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
}

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">bestCowLineSolve</span>(<span style="color:#a6e22e">N</span>));

</code></pre></div><p>輸出結果如下。</p>
<pre><code>[ 'A', 'B', 'C', 'B', 'C', 'D' ]
</code></pre><p>但我們發現到一個問題，我們上面在說明演算法的流程結果為<code>ABCCBD </code>，而我們實作寫的程式碼結果為<code>ABCBCD</code>，問題是出在那 ?</p>
<p>答案是在<code>Step3</code>由於兩邊相同，所以我們隨便取了<code>頭</code>，而實作演算法我們則取<code>尾</code>，所以才導至結果不同。但這兩個字串很明顯的在字典排序時<code>ABCBCD</code>才是較小的，那著麼時我們要如何修改我們的演算法呢 ?</p>
<p>答案是遇到相同的，例如上例<code>CDBC</code>時，我們會產生針對<code>CDBC</code>取名為<code>N</code>與相反的<code>CBDC</code>取名為<code>N'</code>進行字典排序，如果<code>N</code>小於<code>N'</code>時，則從<code>N</code>的開頭取字元新增至新字串，而反之則取<code>N'</code>的開頭字元新增至新字串。</p>
<p>所以說如果是<code>CDBC</code>與<code>CBDC</code>這例子，我們會取<code>CBDC</code>這字串的開頭，這樣我們的結果就是正確的<code>ABCBCD</code>了。</p>
<p>修正後程式碼如下。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">debugger</span>;
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">N</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ACDBCB&#34;</span>;

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">bestCowLineSolve</span>(<span style="color:#a6e22e">text</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">leftPosition</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
		<span style="color:#a6e22e">rightPosition</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>,
		<span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> [],
		<span style="color:#a6e22e">textLen</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">length</span>,
		<span style="color:#a6e22e">tempStr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>;

	<span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">textLen</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
		<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">leftChar</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>[<span style="color:#a6e22e">leftPosition</span>];
		<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">rightChar</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">text</span>[<span style="color:#a6e22e">rightPosition</span>];
		<span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">textLen</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>){
			<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">leftChar</span>);
			<span style="color:#a6e22e">textLen</span><span style="color:#f92672">--</span>;
			<span style="color:#66d9ef">break</span>;
		}

		<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">leftChar</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">rightChar</span>) {
			<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">leftChar</span>);
			<span style="color:#a6e22e">leftPosition</span><span style="color:#f92672">++</span>;
			<span style="color:#a6e22e">tempStr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">tempStr</span>.<span style="color:#a6e22e">substr</span>(<span style="color:#a6e22e">leftPosition</span>, <span style="color:#a6e22e">textLen</span>);
		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">rightChar</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">leftChar</span>) {
			<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">rightChar</span>);
			<span style="color:#a6e22e">rightPosition</span><span style="color:#f92672">--</span>;
			<span style="color:#a6e22e">tempStr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">tempStr</span>.<span style="color:#a6e22e">substr</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">rightPosition</span>);
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">reverseStr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">tempStr</span>.<span style="color:#a6e22e">split</span>(<span style="color:#e6db74">&#34;&#34;</span>).<span style="color:#a6e22e">reverse</span>().<span style="color:#a6e22e">join</span>(<span style="color:#e6db74">&#34;&#34;</span>);
			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">reverseStr</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">tempStr</span>) {
				<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">reverseStr</span>[<span style="color:#ae81ff">0</span>]);
				<span style="color:#a6e22e">rightPosition</span><span style="color:#f92672">--</span>;
				<span style="color:#a6e22e">tempStr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">tempStr</span>.<span style="color:#a6e22e">substr</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">rightPosition</span>);
			} <span style="color:#66d9ef">else</span> {
				<span style="color:#a6e22e">result</span>.<span style="color:#a6e22e">push</span>(<span style="color:#a6e22e">tempStr</span>[<span style="color:#ae81ff">0</span>]);
				<span style="color:#a6e22e">leftPosition</span><span style="color:#f92672">--</span>;
				<span style="color:#a6e22e">tempStr</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">tempStr</span>.<span style="color:#a6e22e">substr</span>(<span style="color:#a6e22e">leftPosition</span>, <span style="color:#a6e22e">textLen</span>);
			}

		}
		<span style="color:#a6e22e">textLen</span><span style="color:#f92672">--</span>;
		<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">tempStr</span>);
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
}

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">bestCowLineSolve</span>(<span style="color:#a6e22e">N</span>));
</code></pre></div><h2 id="heading5">參考資料</h2>
<ul>
<li><a href="http://www.cnblogs.com/Simon-X/p/5309380.html"><a href="http://www.cnblogs.com/Simon-X/p/5309380.html">http://www.cnblogs.com/Simon-X/p/5309380.html</a></a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95"><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95">https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95</a></a></li>
<li><a href="http://www.csie.ntnu.edu.tw/~u91029/KnapsackProblem.html"><a href="http://www.csie.ntnu.edu.tw/~u91029/KnapsackProblem.html">http://www.csie.ntnu.edu.tw/~u91029/KnapsackProblem.html</a></a></li>
</ul>

  </section>

  <section>
    
      <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "mark-lin" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
  </section>

</article>
<div class="disqus markdown">
    <div id="disqus_thread"></div>
<script>





(function() { 
var d = document, s = d.createElement('script');
s.src = 'https://mark-lin.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  </div>

      </div>

      <div id="side" class="pr-1">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>演算法之策略---貪心法</b><nav id="TableOfContents">
  <ul>
    <li><a href="#heading">基本概念</a></li>
    <li><a href="#heading1">實作練習</a>
      <ul>
        <li><a href="#heading2">硬幣問題</a></li>
        <li><a href="#heading3">行程規劃問題</a></li>
        <li><a href="#heading4">字典順序最小問題</a></li>
      </ul>
    </li>
    <li><a href="#heading5">參考資料</a></li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 text-center">
        




      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
